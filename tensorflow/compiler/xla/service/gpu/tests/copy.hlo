// RUN: hlo_to_llvm_ir %s | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// The script is designed to make adding checks to
// a test case fast, it is *not* designed to be authoritative
// about what constitutes a good test! The CHECK should be
// minimized and named to reflect the test intent.


// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_1:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_2:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_3:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_4:.*]] = getelementptr inbounds i8, i8* %[[VAL_5:.*]], i64 0
// CHECK:         %[[VAL_6:.*]] = bitcast i8* %[[VAL_4]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_7:.*]] = getelementptr inbounds i8, i8* %[[VAL_8:.*]], i64 0
// CHECK:         %[[VAL_9:.*]] = bitcast i8* %[[VAL_7]] to [200 x [100 x float]]*
// CHECK:         %[[VAL_10:.*]] = bitcast [100 x [200 x float]]* %[[VAL_6]] to [1 x [100 x [200 x float]]]*
// CHECK:         %[[VAL_11:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !2
// CHECK:         %[[VAL_12:.*]] = urem i32 %[[VAL_11]], 32
// CHECK:         %[[VAL_13:.*]] = udiv i32 %[[VAL_11]], 32
// CHECK:         %[[VAL_14:.*]] = urem i32 %[[VAL_11]], 32
// CHECK:         %[[VAL_15:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !3
// CHECK:         %[[VAL_16:.*]] = udiv i32 %[[VAL_15]], 1
// CHECK:         %[[VAL_17:.*]] = urem i32 %[[VAL_16]], 4
// CHECK:         %[[VAL_18:.*]] = udiv i32 %[[VAL_15]], 4
// CHECK:         %[[VAL_19:.*]] = urem i32 %[[VAL_18]], 7
// CHECK:         %[[VAL_20:.*]] = udiv i32 %[[VAL_15]], 28
// CHECK:         %[[VAL_21:.*]] = mul i32 %[[VAL_20]], 1
// CHECK:         %[[VAL_22:.*]] = icmp eq i32 %[[VAL_19]], 6
// CHECK:         %[[VAL_23:.*]] = select i1 %[[VAL_22]], i32 8, i32 32
// CHECK:         %[[VAL_24:.*]] = icmp eq i32 %[[VAL_17]], 3
// CHECK:         %[[VAL_25:.*]] = select i1 %[[VAL_24]], i32 4, i32 32
// CHECK:         %[[VAL_26:.*]] = mul i32 %[[VAL_19]], 32
// CHECK:         %[[VAL_27:.*]] = mul i32 %[[VAL_17]], 32
// CHECK:         %[[VAL_28:.*]] = mul i32 %[[VAL_12]], 1
// CHECK:         %[[VAL_29:.*]] = add i32 %[[VAL_26]], %[[VAL_28]]
// CHECK:         store i32 %[[VAL_13]], i32* %[[VAL_3]], align 4
// CHECK:         br label %[[VAL_30:.*]]
// CHECK:       input_y_in_tile.loop_header:                      ; preds = %[[VAL_31:.*]], %[[VAL_32:.*]]
// CHECK:         %[[VAL_33:.*]] = load i32, i32* %[[VAL_3]], align 4
// CHECK:         %[[VAL_34:.*]] = icmp uge i32 %[[VAL_33]], %[[VAL_25]]
// CHECK:         br i1 %[[VAL_34]], label %[[VAL_35:.*]], label %[[VAL_36:.*]]
// CHECK:       input_y_in_tile.loop_body:                        ; preds = %[[VAL_30]]
// CHECK:         %[[VAL_37:.*]] = add nuw nsw i32 %[[VAL_33]], 4
// CHECK:         store i32 %[[VAL_37]], i32* %[[VAL_3]], align 4
// CHECK:         %[[VAL_38:.*]] = icmp eq i32 %[[VAL_33]], %[[VAL_13]]
// CHECK:         %[[VAL_39:.*]] = add i32 %[[VAL_27]], %[[VAL_33]]
// CHECK:         store i32 0, i32* %[[VAL_2]], align 4
// CHECK:         br label %[[VAL_40:.*]]
// CHECK:       tile_loop.loop_header:                            ; preds = %[[VAL_41:.*]], %[[VAL_36]]
// CHECK:         %[[VAL_42:.*]] = load i32, i32* %[[VAL_2]], align 4
// CHECK:         %[[VAL_43:.*]] = icmp uge i32 %[[VAL_42]], 1
// CHECK:         br i1 %[[VAL_43]], label %[[VAL_31]], label %[[VAL_44:.*]]
// CHECK:       tile_loop.loop_body:                              ; preds = %[[VAL_40]]
// CHECK:         %[[VAL_45:.*]] = add nuw nsw i32 %[[VAL_42]], 1
// CHECK:         store i32 %[[VAL_45]], i32* %[[VAL_2]], align 4
// CHECK:         %[[VAL_46:.*]] = icmp eq i32 %[[VAL_42]], 0
// CHECK:         %[[VAL_47:.*]] = mul i32 %[[VAL_42]], 1
// CHECK:         %[[VAL_48:.*]] = add i32 %[[VAL_47]], 0
// CHECK:         %[[VAL_49:.*]] = mul i32 %[[VAL_42]], 1
// CHECK:         %[[VAL_50:.*]] = add i32 %[[VAL_49]], 0
// CHECK:         %[[VAL_51:.*]] = add i32 %[[VAL_50]], %[[VAL_28]]
// CHECK:         %[[VAL_52:.*]] = mul i32 %[[VAL_42]], 1
// CHECK:         %[[VAL_53:.*]] = add i32 %[[VAL_52]], 0
// CHECK:         %[[VAL_54:.*]] = add i32 %[[VAL_29]], %[[VAL_53]]
// CHECK:         %[[VAL_55:.*]] = icmp ult i32 %[[VAL_51]], %[[VAL_23]]
// CHECK:         br i1 %[[VAL_55]], label %[[VAL_56:.*]], label %[[VAL_41]]
// CHECK:       input_x_in_tile-after:                            ; preds = %[[VAL_56]], %[[VAL_44]]
// CHECK:         br label %[[VAL_40]], !llvm.loop !4
// CHECK:       tile_loop.loop_exit:                              ; preds = %[[VAL_40]]
// CHECK:         br label %[[VAL_30]], !llvm.loop !7
// CHECK:       input_y_in_tile.loop_exit:                        ; preds = %[[VAL_30]]
// CHECK:         call void @llvm.nvvm.barrier0()
// CHECK:         %[[VAL_57:.*]] = mul i32 %[[VAL_12]], 1
// CHECK:         %[[VAL_58:.*]] = add i32 %[[VAL_27]], %[[VAL_57]]
// CHECK:         store i32 %[[VAL_13]], i32* %[[VAL_1]], align 4
// CHECK:         br label %[[VAL_59:.*]]
// CHECK:       output_y_in_tile.loop_header:                     ; preds = %[[VAL_60:.*]], %[[VAL_35]]
// CHECK:         %[[VAL_61:.*]] = load i32, i32* %[[VAL_1]], align 4
// CHECK:         %[[VAL_62:.*]] = icmp uge i32 %[[VAL_61]], %[[VAL_23]]
// CHECK:         br i1 %[[VAL_62]], label %[[VAL_63:.*]], label %[[VAL_64:.*]]
// CHECK:       output_y_in_tile.loop_body:                       ; preds = %[[VAL_59]]
// CHECK:         %[[VAL_65:.*]] = add nuw nsw i32 %[[VAL_61]], 4
// CHECK:         store i32 %[[VAL_65]], i32* %[[VAL_1]], align 4
// CHECK:         %[[VAL_66:.*]] = icmp eq i32 %[[VAL_61]], %[[VAL_13]]
// CHECK:         %[[VAL_67:.*]] = add i32 %[[VAL_26]], %[[VAL_61]]
// CHECK:         store i32 0, i32* %[[VAL_0]], align 4
// CHECK:         br label %[[VAL_68:.*]]
// CHECK:       tile_loop.loop_header6:                           ; preds = %[[VAL_69:.*]], %[[VAL_64]]
// CHECK:         %[[VAL_70:.*]] = load i32, i32* %[[VAL_0]], align 4
// CHECK:         %[[VAL_71:.*]] = icmp uge i32 %[[VAL_70]], 1
// CHECK:         br i1 %[[VAL_71]], label %[[VAL_60]], label %[[VAL_72:.*]]
// CHECK:       tile_loop.loop_body7:                             ; preds = %[[VAL_68]]
// CHECK:         %[[VAL_73:.*]] = add nuw nsw i32 %[[VAL_70]], 1
// CHECK:         store i32 %[[VAL_73]], i32* %[[VAL_0]], align 4
// CHECK:         %[[VAL_74:.*]] = icmp eq i32 %[[VAL_70]], 0
// CHECK:         %[[VAL_75:.*]] = mul i32 %[[VAL_70]], 1
// CHECK:         %[[VAL_76:.*]] = add i32 %[[VAL_75]], 0
// CHECK:         %[[VAL_77:.*]] = mul i32 %[[VAL_70]], 1
// CHECK:         %[[VAL_78:.*]] = add i32 %[[VAL_77]], 0
// CHECK:         %[[VAL_79:.*]] = add i32 %[[VAL_78]], %[[VAL_57]]
// CHECK:         %[[VAL_80:.*]] = mul i32 %[[VAL_70]], 1
// CHECK:         %[[VAL_81:.*]] = add i32 %[[VAL_80]], 0
// CHECK:         %[[VAL_82:.*]] = add i32 %[[VAL_58]], %[[VAL_81]]
// CHECK:         %[[VAL_83:.*]] = icmp ult i32 %[[VAL_79]], %[[VAL_25]]
// CHECK:         br i1 %[[VAL_83]], label %[[VAL_84:.*]], label %[[VAL_69]]
// CHECK:       output_x_in_tile-after:                           ; preds = %[[VAL_84]], %[[VAL_72]]
// CHECK:         br label %[[VAL_68]], !llvm.loop !8
// CHECK:       tile_loop.loop_exit5:                             ; preds = %[[VAL_68]]
// CHECK:         br label %[[VAL_59]], !llvm.loop !9
// CHECK:       output_y_in_tile.loop_exit:                       ; preds = %[[VAL_59]]
// CHECK:         ret void
// CHECK:       input_x_in_tile-true:                             ; preds = %[[VAL_44]]
// CHECK:         %[[VAL_85:.*]] = getelementptr inbounds [1 x [100 x [200 x float]]], [1 x [100 x [200 x float]]]* %[[VAL_10]], i32 0, i32 0, i32 %[[VAL_39]], i32 %[[VAL_54]]
// CHECK:         %[[VAL_86:.*]] = load float, float* %[[VAL_85]], align 4, !invariant.load !10
// CHECK:         %[[VAL_87:.*]] = getelementptr [32 x [33 x float]], [32 x [33 x float]] addrspace(3)* @b.tile0, i32 0, i32 %[[VAL_33]], i32 %[[VAL_51]]
// CHECK:         store float %[[VAL_86]], float addrspace(3)* %[[VAL_87]], align 4
// CHECK:         br label %[[VAL_41]]
// CHECK:       output_x_in_tile-true:                            ; preds = %[[VAL_72]]
// CHECK:         %[[VAL_88:.*]] = getelementptr [32 x [33 x float]], [32 x [33 x float]] addrspace(3)* @b.tile0, i32 0, i32 %[[VAL_79]], i32 %[[VAL_61]]
// CHECK:         %[[VAL_89:.*]] = load float, float addrspace(3)* %[[VAL_88]], align 4
// CHECK:         %[[VAL_90:.*]] = getelementptr inbounds [200 x [100 x float]], [200 x [100 x float]]* %[[VAL_9]], i32 0, i32 %[[VAL_67]], i32 %[[VAL_82]]
// CHECK:         store float %[[VAL_89]], float* %[[VAL_90]], align 4
// CHECK:         br label %[[VAL_69]]

HloModule Test

ENTRY main {
  a = f32[100, 200]{1,0} parameter(0)
  ROOT b = f32[100, 200]{0,1} copy(a)
}

// RUN: hlo_to_llvm_ir %s | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// The script is designed to make adding checks to
// a test case fast, it is *not* designed to be authoritative
// about what constitutes a good test! The CHECK should be
// minimized and named to reflect the test intent.


// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_1:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_2:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_3:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_4:.*]] = getelementptr inbounds i8, ptr %[[VAL_5:.*]], i64 0
// CHECK:         %[[VAL_6:.*]] = getelementptr inbounds i8, ptr %[[VAL_7:.*]], i64 0
// CHECK:         %[[VAL_8:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !2
// CHECK:         %[[VAL_9:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !3
// CHECK:         %[[VAL_10:.*]] = urem i32 %[[VAL_8]], 128
// CHECK:         %[[VAL_11:.*]] = udiv i32 %[[VAL_8]], 128
// CHECK:         %[[VAL_12:.*]] = mul i32 %[[VAL_9]], 1
// CHECK:         %[[VAL_13:.*]] = add i32 %[[VAL_12]], %[[VAL_11]]
// CHECK:         %[[VAL_14:.*]] = icmp ult i32 %[[VAL_13]], 28
// CHECK:         br i1 %[[VAL_14]], label %[[VAL_15:.*]], label %[[VAL_16:.*]]
// CHECK:       9:                                                ; preds = %[[VAL_17:.*]]
// CHECK:         %[[VAL_18:.*]] = urem i32 %[[VAL_10]], 32
// CHECK:         %[[VAL_19:.*]] = udiv i32 %[[VAL_10]], 32
// CHECK:         %[[VAL_20:.*]] = urem i32 %[[VAL_10]], 32
// CHECK:         %[[VAL_21:.*]] = udiv i32 %[[VAL_13]], 1
// CHECK:         %[[VAL_22:.*]] = urem i32 %[[VAL_21]], 4
// CHECK:         %[[VAL_23:.*]] = udiv i32 %[[VAL_13]], 4
// CHECK:         %[[VAL_24:.*]] = urem i32 %[[VAL_23]], 7
// CHECK:         %[[VAL_25:.*]] = udiv i32 %[[VAL_13]], 28
// CHECK:         %[[VAL_26:.*]] = mul i32 %[[VAL_25]], 1
// CHECK:         %[[VAL_27:.*]] = icmp eq i32 %[[VAL_24]], 6
// CHECK:         %[[VAL_28:.*]] = select i1 %[[VAL_27]], i32 8, i32 32
// CHECK:         %[[VAL_29:.*]] = icmp eq i32 %[[VAL_22]], 3
// CHECK:         %[[VAL_30:.*]] = select i1 %[[VAL_29]], i32 4, i32 32
// CHECK:         %[[VAL_31:.*]] = mul i32 %[[VAL_24]], 32
// CHECK:         %[[VAL_32:.*]] = mul i32 %[[VAL_22]], 32
// CHECK:         %[[VAL_33:.*]] = mul i32 %[[VAL_18]], 1
// CHECK:         %[[VAL_34:.*]] = add i32 %[[VAL_31]], %[[VAL_33]]
// CHECK:         store i32 %[[VAL_19]], ptr %[[VAL_3]], align 4
// CHECK:         br label %[[VAL_35:.*]]
// CHECK:       y_in_tile.loop_header:                            ; preds = %[[VAL_36:.*]], %[[VAL_15]]
// CHECK:         %[[VAL_37:.*]] = load i32, ptr %[[VAL_3]], align 4
// CHECK:         %[[VAL_38:.*]] = icmp uge i32 %[[VAL_37]], %[[VAL_30]]
// CHECK:         br i1 %[[VAL_38]], label %[[VAL_39:.*]], label %[[VAL_40:.*]]
// CHECK:       y_in_tile.loop_body:                              ; preds = %[[VAL_35]]
// CHECK:         %[[VAL_41:.*]] = add nuw nsw i32 %[[VAL_37]], 4
// CHECK:         store i32 %[[VAL_41]], ptr %[[VAL_3]], align 4
// CHECK:         %[[VAL_42:.*]] = icmp eq i32 %[[VAL_37]], %[[VAL_19]]
// CHECK:         %[[VAL_43:.*]] = add i32 %[[VAL_32]], %[[VAL_37]]
// CHECK:         store i32 0, ptr %[[VAL_2]], align 4
// CHECK:         br label %[[VAL_44:.*]]
// CHECK:       tile_loop.loop_header:                            ; preds = %[[VAL_45:.*]], %[[VAL_40]]
// CHECK:         %[[VAL_46:.*]] = load i32, ptr %[[VAL_2]], align 4
// CHECK:         %[[VAL_47:.*]] = icmp uge i32 %[[VAL_46]], 1
// CHECK:         br i1 %[[VAL_47]], label %[[VAL_36]], label %[[VAL_48:.*]]
// CHECK:       tile_loop.loop_body:                              ; preds = %[[VAL_44]]
// CHECK:         %[[VAL_49:.*]] = add nuw nsw i32 %[[VAL_46]], 1
// CHECK:         store i32 %[[VAL_49]], ptr %[[VAL_2]], align 4
// CHECK:         %[[VAL_50:.*]] = icmp eq i32 %[[VAL_46]], 0
// CHECK:         %[[VAL_51:.*]] = mul i32 %[[VAL_46]], 1
// CHECK:         %[[VAL_52:.*]] = add i32 %[[VAL_51]], 0
// CHECK:         %[[VAL_53:.*]] = mul i32 %[[VAL_46]], 1
// CHECK:         %[[VAL_54:.*]] = add i32 %[[VAL_53]], 0
// CHECK:         %[[VAL_55:.*]] = add i32 %[[VAL_54]], %[[VAL_33]]
// CHECK:         %[[VAL_56:.*]] = mul i32 %[[VAL_46]], 1
// CHECK:         %[[VAL_57:.*]] = add i32 %[[VAL_56]], 0
// CHECK:         %[[VAL_58:.*]] = add i32 %[[VAL_34]], %[[VAL_57]]
// CHECK:         %[[VAL_59:.*]] = icmp ult i32 %[[VAL_55]], %[[VAL_28]]
// CHECK:         br i1 %[[VAL_59]], label %[[VAL_60:.*]], label %[[VAL_45]]
// CHECK:       x_in_tile-after:                                  ; preds = %[[VAL_60]], %[[VAL_48]]
// CHECK:         br label %[[VAL_44]], !llvm.loop !4
// CHECK:       tile_loop.loop_exit:                              ; preds = %[[VAL_44]]
// CHECK:         br label %[[VAL_35]], !llvm.loop !7
// CHECK:       y_in_tile.loop_exit:                              ; preds = %[[VAL_35]]
// CHECK:         call void @llvm.nvvm.barrier0()
// CHECK:         %[[VAL_61:.*]] = mul i32 %[[VAL_18]], 1
// CHECK:         %[[VAL_62:.*]] = add i32 %[[VAL_32]], %[[VAL_61]]
// CHECK:         store i32 %[[VAL_19]], ptr %[[VAL_1]], align 4
// CHECK:         br label %[[VAL_63:.*]]
// CHECK:       y_in_tile.loop_header5:                           ; preds = %[[VAL_64:.*]], %[[VAL_39]]
// CHECK:         %[[VAL_65:.*]] = load i32, ptr %[[VAL_1]], align 4
// CHECK:         %[[VAL_66:.*]] = icmp uge i32 %[[VAL_65]], %[[VAL_28]]
// CHECK:         br i1 %[[VAL_66]], label %[[VAL_67:.*]], label %[[VAL_68:.*]]
// CHECK:       y_in_tile.loop_body6:                             ; preds = %[[VAL_63]]
// CHECK:         %[[VAL_69:.*]] = add nuw nsw i32 %[[VAL_65]], 4
// CHECK:         store i32 %[[VAL_69]], ptr %[[VAL_1]], align 4
// CHECK:         %[[VAL_70:.*]] = icmp eq i32 %[[VAL_65]], %[[VAL_19]]
// CHECK:         %[[VAL_71:.*]] = add i32 %[[VAL_31]], %[[VAL_65]]
// CHECK:         store i32 0, ptr %[[VAL_0]], align 4
// CHECK:         br label %[[VAL_72:.*]]
// CHECK:       tile_loop.loop_header11:                          ; preds = %[[VAL_73:.*]], %[[VAL_68]]
// CHECK:         %[[VAL_74:.*]] = load i32, ptr %[[VAL_0]], align 4
// CHECK:         %[[VAL_75:.*]] = icmp uge i32 %[[VAL_74]], 1
// CHECK:         br i1 %[[VAL_75]], label %[[VAL_64]], label %[[VAL_76:.*]]
// CHECK:       tile_loop.loop_body12:                            ; preds = %[[VAL_72]]
// CHECK:         %[[VAL_77:.*]] = add nuw nsw i32 %[[VAL_74]], 1
// CHECK:         store i32 %[[VAL_77]], ptr %[[VAL_0]], align 4
// CHECK:         %[[VAL_78:.*]] = icmp eq i32 %[[VAL_74]], 0
// CHECK:         %[[VAL_79:.*]] = mul i32 %[[VAL_74]], 1
// CHECK:         %[[VAL_80:.*]] = add i32 %[[VAL_79]], 0
// CHECK:         %[[VAL_81:.*]] = mul i32 %[[VAL_74]], 1
// CHECK:         %[[VAL_82:.*]] = add i32 %[[VAL_81]], 0
// CHECK:         %[[VAL_83:.*]] = add i32 %[[VAL_82]], %[[VAL_61]]
// CHECK:         %[[VAL_84:.*]] = mul i32 %[[VAL_74]], 1
// CHECK:         %[[VAL_85:.*]] = add i32 %[[VAL_84]], 0
// CHECK:         %[[VAL_86:.*]] = add i32 %[[VAL_62]], %[[VAL_85]]
// CHECK:         %[[VAL_87:.*]] = icmp ult i32 %[[VAL_83]], %[[VAL_30]]
// CHECK:         br i1 %[[VAL_87]], label %[[VAL_88:.*]], label %[[VAL_73]]
// CHECK:       x_in_tile-after18:                                ; preds = %[[VAL_88]], %[[VAL_76]]
// CHECK:         br label %[[VAL_72]], !llvm.loop !8
// CHECK:       tile_loop.loop_exit10:                            ; preds = %[[VAL_72]]
// CHECK:         br label %[[VAL_63]], !llvm.loop !9
// CHECK:       y_in_tile.loop_exit4:                             ; preds = %[[VAL_63]]
// CHECK:         ret void
// CHECK:       early_return:                                     ; preds = %[[VAL_17]]
// CHECK:         ret void
// CHECK:       x_in_tile-true:                                   ; preds = %[[VAL_48]]
// CHECK:         %[[VAL_89:.*]] = getelementptr inbounds [1 x [100 x [200 x float]]], ptr %[[VAL_4]], i32 0, i32 0, i32 %[[VAL_43]], i32 %[[VAL_58]]
// CHECK:         %[[VAL_90:.*]] = load float, ptr %[[VAL_89]], align 4, !invariant.load !10
// CHECK:         %[[VAL_91:.*]] = getelementptr inbounds [1 x [32 x [33 x float]]], ptr addrspace(3) @b.tile0, i32 0, i32 %[[VAL_11]], i32 %[[VAL_37]], i32 %[[VAL_55]]
// CHECK:         %[[VAL_92:.*]] = addrspacecast ptr addrspace(3) %[[VAL_91]] to ptr
// CHECK:         store float %[[VAL_90]], ptr %[[VAL_92]], align 4
// CHECK:         br label %[[VAL_45]]
// CHECK:       x_in_tile-true17:                                 ; preds = %[[VAL_76]]
// CHECK:         %[[VAL_93:.*]] = getelementptr inbounds [1 x [32 x [33 x float]]], ptr addrspace(3) @b.tile0, i32 0, i32 %[[VAL_11]], i32 %[[VAL_83]], i32 %[[VAL_65]]
// CHECK:         %[[VAL_94:.*]] = addrspacecast ptr addrspace(3) %[[VAL_93]] to ptr
// CHECK:         %[[VAL_95:.*]] = load float, ptr %[[VAL_94]], align 4
// CHECK:         %[[VAL_96:.*]] = getelementptr inbounds [200 x [100 x float]], ptr %[[VAL_6]], i32 0, i32 %[[VAL_71]], i32 %[[VAL_86]]
// CHECK:         store float %[[VAL_95]], ptr %[[VAL_96]], align 4
// CHECK:         br label %[[VAL_73]]

HloModule Test

ENTRY main {
  a = f32[100, 200]{1,0} parameter(0)
  ROOT b = f32[100, 200]{0,1} copy(a)
}

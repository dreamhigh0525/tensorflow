From 9134fbb13794865a45288d2e722ad47c362e0ae4 Mon Sep 17 00:00:00 2001
From: Daniel Nguyen <nguyendaniel@google.com>
Date: Thu, 18 Jun 2020 23:13:11 +0000
Subject: [PATCH] summary_op needs tstring C API sync

---
 tensorflow/c/kernels/diff.patch         |   0
 tensorflow/c/kernels/ops/summary.cc     |  70 ++++++++++
 tensorflow/c/kernels/summary_op.cc      | 171 ++++++++++++++++++++++++
 tensorflow/c/kernels/summary_op_test.cc |  96 +++++++++++++
 4 files changed, 337 insertions(+)
 create mode 100644 tensorflow/c/kernels/diff.patch
 create mode 100644 tensorflow/c/kernels/ops/summary.cc
 create mode 100644 tensorflow/c/kernels/summary_op.cc
 create mode 100644 tensorflow/c/kernels/summary_op_test.cc

diff --git a/tensorflow/c/kernels/diff.patch b/tensorflow/c/kernels/diff.patch
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/tensorflow/c/kernels/ops/summary.cc b/tensorflow/c/kernels/ops/summary.cc
new file mode 100644
index 0000000000..550a663d00
--- /dev/null
+++ b/tensorflow/c/kernels/ops/summary.cc
@@ -0,0 +1,70 @@
+/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#include <sstream>
+#include <string>
+
+#include "tensorflow/c/ops.h"
+#include "tensorflow/core/framework/selective_registration.h"
+#include "tensorflow/core/platform/logging.h"
+#include "tensorflow/core/platform/macros.h"
+
+
+static void TF_ScalarSummary_shape_inference_fn(TF_ShapeInferenceContext* ctx,
+                                       TF_Status* status) {
+  TF_ShapeHandle* result = TF_NewShapeHandle();
+  // TODO: what to do in the case of unknown input shape? 
+  if (TF_GetCode(status) == TF_OK &&
+      !TF_ShapeInferenceContextRankKnown(ctx, result)) {
+    TF_ShapeInferenceContextSetUnknownShape(ctx, status);
+    CHECK_EQ(TF_OK, TF_GetCode(status))
+    << "Error while setting unknown shape function";
+    TF_DeleteShapeHandle(result);
+    return;
+  }
+  // make shape handle a scalar value (empty shape)
+  if (TF_GetCode(status) == TF_OK) {
+    TF_ShapeInferenceContextSetOutput(ctx, 0, result, status);
+        CHECK_EQ(TF_OK, TF_GetCode(status))
+    << "Error while setting shape function";
+  }
+  TF_DeleteShapeHandle(result);
+}
+
+void Register_ScalarSummaryOp() {
+  TF_Status* status = TF_NewStatus();
+
+  TF_OpDefinitionBuilder* op_builder = TF_NewOpDefinitionBuilder("SummaryScalar");
+  TF_OpDefinitionBuilderAddInput(op_builder, "tags: string");
+    TF_OpDefinitionBuilderAddInput(op_builder, "values: T");
+  TF_OpDefinitionBuilderAddOutput(op_builder, "summary: string");
+  TF_OpDefinitionBuilderAddAttr(
+      op_builder,
+      "T: realnumbertype");
+  TF_OpDefinitionBuilderSetShapeInferenceFunction(op_builder,
+                                                  &TF_ScalarSummary_shape_inference_fn);
+
+  TF_RegisterOpDefinition(op_builder, status);
+  CHECK_EQ(TF_GetCode(status), TF_OK)
+      << "TF_ScalarSummary op registration failed: " << TF_Message(status);
+  TF_DeleteStatus(status);
+}
+
+TF_ATTRIBUTE_UNUSED static bool SummaryScalarOpRegistered = []() {
+  if (SHOULD_REGISTER_OP("SummaryScalar")) {
+    Register_ScalarSummaryOp();
+  }
+  return true;
+}();
diff --git a/tensorflow/c/kernels/summary_op.cc b/tensorflow/c/kernels/summary_op.cc
new file mode 100644
index 0000000000..3a78d321d7
--- /dev/null
+++ b/tensorflow/c/kernels/summary_op.cc
@@ -0,0 +1,171 @@
+
+/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#include <sstream>
+
+#include "tensorflow/c/kernels.h"
+#include "tensorflow/c/ops.h"
+#include "tensorflow/c/tf_tensor.h"
+#include "tensorflow/core/framework/common_shape_fns.h"
+#include "tensorflow/core/framework/op.h"
+#include "tensorflow/core/framework/selective_registration.h"
+#include "tensorflow/core/framework/shape_inference.h"
+#include "tensorflow/core/platform/macros.h"
+#include "tensorflow/core/framework/summary.pb.h"
+#include "tensorflow/core/platform/protobuf.h"
+#include "tensorflow/core/framework/register_types.h"
+
+#include "tensorflow/core/framework/types.h"
+
+// BitcastOp implements a bitcast kernel, creating an output tensor that shares
+// the same data buffer as the input but with a different shape and/or data
+// type. Its inputs are:
+//
+//   * the input tensor
+//   * an attribute named "T" containing the TF_DataType of the input tensor
+//   * an attribute named "type" containing the TF_DataType of the output tensor
+//
+// Given an input tensor of shape [...], if the input DataType "T" is larger
+// than the output DataType "type", then the shape changes from [...]
+// to [..., sizeof(T)/sizeof(type)].
+//
+// If "T" is smaller than "type", the operator requires that the rightmost
+// dimension be equal to sizeof(type)/sizeof(T). The shape then goes from
+// [..., sizeof(type)/sizeof(T)] to [...].
+//
+// Bitcast is implemented as a low-level cast, so machines with different endian
+// orderings will give different results.
+
+static void* SummaryScalarOp_Create(TF_OpKernelConstruction* ctx) {
+  // TODO: replace with a void* pointer type later 
+  int a = 4; 
+  return static_cast<void*>(&a); 
+}
+
+static void SummaryScalarOp_Delete(void* kernel) {
+  return;
+}
+
+bool IsSameSize(TF_Tensor* tensor1, TF_Tensor* tensor2){ 
+  if (TF_NumDims(tensor1) != TF_NumDims(tensor2)){
+    return false; 
+  }
+  for(int d = 0; d < TF_NumDims(tensor1); d++){
+    if (TF_Dim(tensor1, d) != TF_Dim(tensor2, d)){
+      return false; 
+    }
+  }
+  return true; 
+}
+
+template<typename T>
+static void SummaryScalarOp_Compute(void* kernel, TF_OpKernelContext* ctx) {
+  TF_Tensor* tags;
+  TF_Tensor* values; 
+  TF_Status* status = TF_NewStatus();
+  TF_GetInput(ctx, 0, &tags, status);
+          CHECK_EQ(TF_OK, TF_GetCode(status))
+    << "Error while getting input"; 
+  if (TF_GetCode(status) == TF_OK){
+    TF_GetInput(ctx, 1, &values, status);
+  } 
+  CHECK_EQ(TF_OK, TF_GetCode(status))
+    << "Error while getting input";
+  if (TF_GetCode(status) == TF_OK) {
+    if (!IsSameSize(tags, values)) {
+      std::ostringstream err;
+      err << "tags and values not the same shape: "; 
+      TF_SetStatus(status, TF_INVALID_ARGUMENT, err.str().c_str());
+    }
+  }
+
+  tensorflow::Summary s; 
+  if (TF_GetCode(status) == TF_OK) {
+    auto Ttags_array = static_cast<TF_TString**>(TF_TensorData(tags)); 
+    auto values_array = static_cast<T*>(TF_TensorData(values)); 
+    for (int i = 0; i < TF_TensorElementCount(tags); ++i){ 
+      tensorflow::Summary::Value* v = s.add_value(); 
+      TF_TString_Init(Ttags_array[i]); 
+      v->set_tag(TF_TString_GetDataPointer(Ttags_array[i]), TF_TString_GetSize(Ttags_array[i]));
+      v->set_simple_value(float(values_array[i]));
+    }
+
+
+    // TF_Tensor* summary_tensor = TF_AllocateOutput(ctx, 0, TF_ExpectedOutputDataType(ctx, 0), 0, 0)  
+
+    // TF_Tensor* output = TF_AllocateTensor(k->output_data_type, dims, 0,
+    //                                       TF_DataTypeSize(k->output_data_type));
+    // if (TF_GetCode(status) == TF_OK) {
+    //   TF_SetOutput(ctx, 0, output, status);
+    // }
+    // TF_DeleteTensor(output);
+  }
+
+  // if (TF_GetCode(status) != TF_OK) {
+  //   TF_OpKernelContext_Failure(ctx, status);
+  // }
+  // TF_DeleteStatus(status);
+  // TF_DeleteTensor(tags);
+}
+
+template <typename T>
+void RegisterSummaryScalarOpKernel() {
+  TF_Status* status = TF_NewStatus();
+  {
+    auto* builder = TF_NewKernelBuilder("SummaryScalar", tensorflow::DEVICE_CPU,
+                                        &SummaryScalarOp_Create, &SummaryScalarOp_Compute<T>,
+                                        &SummaryScalarOp_Delete);
+    TF_KernelBuilder_TypeConstraint(builder, "T", static_cast<TF_DataType>(tensorflow::DataTypeToEnum<T>::v()), status); 
+    CHECK_EQ(TF_OK, TF_GetCode(status))
+        << "Error while adding type constraint";
+    TF_RegisterKernelBuilder("SummaryScalar", builder, status);
+    CHECK_EQ(TF_OK, TF_GetCode(status))
+        << "Error while registering Summary Scalar kernel";
+  }
+// template <typename T>
+// #if GOOGLE_CUDA
+//   {
+//     auto* builder = TF_NewKernelBuilder("SummaryScalar", tensorflow::DEVICE_GPU,
+//                                         &SummaryScalarOp_Create, &SummaryScalarOp_Compute,
+//                                         &SummaryScalarOp_Delete);
+//     TF_RegisterKernelBuilder("SummaryScalar", builder, status);
+//     CHECK_EQ(TF_OK, TF_GetCode(status))
+//         << "Error while registering CUDA SummaryScalar kernel";
+//   }
+// #endif
+
+  TF_DeleteStatus(status);
+}
+
+// A dummy static variable initialized by a lambda whose side-effect is to
+// register the bitcast kernel.
+
+                                                          
+TF_ATTRIBUTE_UNUSED static bool  IsSummaryScalarOpKernelRegistered = []() {                  
+  if (SHOULD_REGISTER_OP_KERNEL("SummaryScalar")) {                                                                           
+    RegisterSummaryScalarOpKernel<tensorflow::int64>();          
+    RegisterSummaryScalarOpKernel<tensorflow::int32>();   
+    RegisterSummaryScalarOpKernel<tensorflow::uint16>();   
+    RegisterSummaryScalarOpKernel<tensorflow::int16>();   
+    RegisterSummaryScalarOpKernel<tensorflow::uint8>();   
+    RegisterSummaryScalarOpKernel<Eigen::half>();   
+    RegisterSummaryScalarOpKernel<tensorflow::bfloat16>();   
+    RegisterSummaryScalarOpKernel<float>();   
+    RegisterSummaryScalarOpKernel<double>();                                  
+  }                                                                           
+  return true;                                                                
+}();                                                                          
+
diff --git a/tensorflow/c/kernels/summary_op_test.cc b/tensorflow/c/kernels/summary_op_test.cc
new file mode 100644
index 0000000000..fd6199abd6
--- /dev/null
+++ b/tensorflow/c/kernels/summary_op_test.cc
@@ -0,0 +1,96 @@
+/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#include "tensorflow/core/framework/attr_value.pb.h"
+#include "tensorflow/core/framework/attr_value_util.h"
+#include "tensorflow/core/framework/fake_input.h"
+#include "tensorflow/core/framework/node_def.pb.h"
+#include "tensorflow/core/framework/node_def_builder.h"
+#include "tensorflow/core/framework/op_kernel.h"
+#include "tensorflow/core/framework/shape_inference.h"
+#include "tensorflow/core/platform/test.h"
+
+#include<stdio.h>
+#include<sstream>
+#include<iostream>
+namespace tensorflow {
+namespace {
+
+class DummyDevice : public DeviceBase {
+ public:
+  explicit DummyDevice(Env* env) : DeviceBase(env) {}
+  Allocator* GetAllocator(AllocatorAttributes /*attr*/) override {
+    return cpu_allocator();
+  }
+};
+
+void TestScalarSummaryOp(Tensor* tags, Tensor* values, error::Code expected_code) {
+  Status status;
+  NodeDef def;
+  def.set_op("SummaryScalar");
+
+  def.set_device(DEVICE_CPU);
+
+  AttrValue valuesTypeAttr;
+  SetAttrValue(values->dtype(), &valuesTypeAttr);
+  (*def.mutable_attr())["T"] = valuesTypeAttr;
+
+  def.add_input(
+      strings::StrCat("input1: ", DataTypeString(tags->dtype())));
+  def.add_input(
+    strings::StrCat("input2: ", DataTypeString(values->dtype())));
+
+  std::unique_ptr<OpKernel> kernel =
+      CreateOpKernel(DeviceType(DEVICE_CPU), nullptr, nullptr, def, 1, &status); 
+  ASSERT_TRUE(status.ok()) << status.ToString();
+  OpKernelContext::Params params;
+  DummyDevice dummy_device(nullptr);
+  params.device = &dummy_device;
+  params.op_kernel = kernel.get();
+  gtl::InlinedVector<TensorValue, 4> inputs;
+  inputs.emplace_back(tags);
+  inputs.emplace_back(values);
+  params.inputs = &inputs;
+  OpKernelContext ctx(&params, 1); 
+  kernel->Compute(&ctx);
+
+  ASSERT_EQ(expected_code, ctx.status().code());
+  if (expected_code == error::OK) {
+    ASSERT_EQ(true, false)
+        << ctx.mutable_output(0)->shape().DebugString();
+  }
+}
+
+TEST(ScalarSummaryOpTest, Test) {
+  int vectorSize = 2; 
+  Tensor tags(DT_STRING, {vectorSize}); 
+  Tensor values(DT_FLOAT, {vectorSize}); 
+  for (int i = 0; i < vectorSize; ++i){  
+    values.vec<float>()(i) = static_cast<uint8>(i); 
+  }
+  tags.vec<tstring>()(0) = "tag 1";
+  tags.vec<tstring>()(1) = "tag 2";
+  TestScalarSummaryOp(&tags, &values, error::INVALID_ARGUMENT); 
+}
+
+
+PartialTensorShape S(std::initializer_list<int64> dims) {
+  return PartialTensorShape(dims);
+}
+
+
+
+}  // namespace
+}  // namespace tensorflow
-- 
2.27.0.111.gc72c7da667-goog


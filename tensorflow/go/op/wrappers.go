// Copyright 2017 The TensorFlow Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// DO NOT EDIT
// This file was machine generated by github.com/tensorflow/tensorflow/tensorflow/go/genop/internal
//
// WARNING: This generation of wrapper function for TensorFlow ops is in an
// experimental state. The generated API can change without notice.

package op

import tf "github.com/tensorflow/tensorflow/tensorflow/go"

// optionalAttr is an intentionally un-exported type to hide
// details of how optional attributes to operations are implemented.
type optionalAttr map[string]interface{}

func makeOutputList(op *tf.Operation, start int, output string) ([]tf.Output, int, error) {
	size, err := op.OutputListSize(output)
	if err != nil {
		return nil, start, err
	}
	list := make([]tf.Output, size)
	for i := 0; i < size; i++ {
		list[i] = op.Output(start + i)
	}
	return list, start + size, nil
}

// Outputs a `tf.Event` protocol buffer.
//
// When CreateSummaryDbWriter is being used, this op can be useful for
// importing data from event logs.
//
// Arguments:
//	writer: A handle to a summary writer.
//	event: A string containing a binary-encoded tf.Event proto.
//
// Returns the created operation.
func ImportEvent(scope *Scope, writer tf.Output, event tf.Output) (o *tf.Operation) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "ImportEvent",
		Input: []tf.Input{
			writer, event,
		},
	}
	return scope.AddOperation(opspec)
}

// Outputs a `Summary` protocol buffer with a tensor.
//
// Arguments:
//	writer: A handle to a summary writer.
//	step: The step to write the summary for.
//	tensor: A tensor to serialize.
//	tag: The summary's tag.
//	summary_metadata: Serialized SummaryMetadata protocol buffer containing
// plugin-related metadata for this summary.
//
// Returns the created operation.
func WriteSummary(scope *Scope, writer tf.Output, step tf.Output, tensor tf.Output, tag tf.Output, summary_metadata tf.Output) (o *tf.Operation) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "WriteSummary",
		Input: []tf.Input{
			writer, step, tensor, tag, summary_metadata,
		},
	}
	return scope.AddOperation(opspec)
}

// Flushes and closes the summary writer.
//
// Also removes it from the resource manager. To reopen, use another
// CreateSummaryFileWriter op.
//
// Arguments:
//	writer: A handle to the summary writer resource.
//
// Returns the created operation.
func CloseSummaryWriter(scope *Scope, writer tf.Output) (o *tf.Operation) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "CloseSummaryWriter",
		Input: []tf.Input{
			writer,
		},
	}
	return scope.AddOperation(opspec)
}

// Flushes the writer's unwritten events.
//
// Arguments:
//	writer: A handle to the summary writer resource.
//
// Returns the created operation.
func FlushSummaryWriter(scope *Scope, writer tf.Output) (o *tf.Operation) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "FlushSummaryWriter",
		Input: []tf.Input{
			writer,
		},
	}
	return scope.AddOperation(opspec)
}

// Writes a `Summary` protocol buffer with a histogram.
//
// The generated
// [`Summary`](https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto)
// has one summary value containing a histogram for `values`.
//
// This op reports an `InvalidArgument` error if any value is not finite.
//
// Arguments:
//	writer: A handle to a summary writer.
//	step: The step to write the summary for.
//	tag: Scalar.  Tag to use for the `Summary.Value`.
//	values: Any shape. Values to use to build the histogram.
//
// Returns the created operation.
func WriteHistogramSummary(scope *Scope, writer tf.Output, step tf.Output, tag tf.Output, values tf.Output) (o *tf.Operation) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "WriteHistogramSummary",
		Input: []tf.Input{
			writer, step, tag, values,
		},
	}
	return scope.AddOperation(opspec)
}

// SummaryWriterAttr is an optional argument to SummaryWriter.
type SummaryWriterAttr func(optionalAttr)

// SummaryWriterSharedName sets the optional shared_name attribute to value.
// If not specified, defaults to ""
func SummaryWriterSharedName(value string) SummaryWriterAttr {
	return func(m optionalAttr) {
		m["shared_name"] = value
	}
}

// SummaryWriterContainer sets the optional container attribute to value.
// If not specified, defaults to ""
func SummaryWriterContainer(value string) SummaryWriterAttr {
	return func(m optionalAttr) {
		m["container"] = value
	}
}

// Returns a handle to be used to access a summary writer.
//
// The summary writer is an in-graph resource which can be used by ops to write
// summaries to event files.
//
// Returns the summary writer resource. Scalar handle.
func SummaryWriter(scope *Scope, optional ...SummaryWriterAttr) (writer tf.Output) {
	if scope.Err() != nil {
		return
	}
	attrs := map[string]interface{}{}
	for _, a := range optional {
		a(attrs)
	}
	opspec := tf.OpSpec{
		Type: "SummaryWriter",

		Attrs: attrs,
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Writes a `Summary` protocol buffer with scalar values.
//
// The input `tag` and `value` must have the scalars.
//
// Arguments:
//	writer: A handle to a summary writer.
//	step: The step to write the summary for.
//	tag: Tag for the summary.
//	value: Value for the summary.
//
// Returns the created operation.
func WriteScalarSummary(scope *Scope, writer tf.Output, step tf.Output, tag tf.Output, value tf.Output) (o *tf.Operation) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "WriteScalarSummary",
		Input: []tf.Input{
			writer, step, tag, value,
		},
	}
	return scope.AddOperation(opspec)
}

// WriteAudioSummaryAttr is an optional argument to WriteAudioSummary.
type WriteAudioSummaryAttr func(optionalAttr)

// WriteAudioSummaryMaxOutputs sets the optional max_outputs attribute to value.
//
// value: Max number of batch elements to generate audio for.
// If not specified, defaults to 3
//
// REQUIRES: value >= 1
func WriteAudioSummaryMaxOutputs(value int64) WriteAudioSummaryAttr {
	return func(m optionalAttr) {
		m["max_outputs"] = value
	}
}

// Writes a `Summary` protocol buffer with audio.
//
// The summary has up to `max_outputs` summary values containing audio. The
// audio is built from `tensor` which must be 3-D with shape `[batch_size,
// frames, channels]` or 2-D with shape `[batch_size, frames]`. The values are
// assumed to be in the range of `[-1.0, 1.0]` with a sample rate of `sample_rate`.
//
// The `tag` argument is a scalar `Tensor` of type `string`.  It is used to
// build the `tag` of the summary values:
//
// *  If `max_outputs` is 1, the summary value tag is '*tag*/audio'.
// *  If `max_outputs` is greater than 1, the summary value tags are
//    generated sequentially as '*tag*/audio/0', '*tag*/audio/1', etc.
//
// Arguments:
//	writer: A handle to a summary writer.
//	step: The step to write the summary for.
//	tag: Scalar. Used to build the `tag` attribute of the summary values.
//	tensor: 2-D of shape `[batch_size, frames]`.
//	sample_rate: The sample rate of the signal in hertz.
//
// Returns the created operation.
func WriteAudioSummary(scope *Scope, writer tf.Output, step tf.Output, tag tf.Output, tensor tf.Output, sample_rate tf.Output, optional ...WriteAudioSummaryAttr) (o *tf.Operation) {
	if scope.Err() != nil {
		return
	}
	attrs := map[string]interface{}{}
	for _, a := range optional {
		a(attrs)
	}
	opspec := tf.OpSpec{
		Type: "WriteAudioSummary",
		Input: []tf.Input{
			writer, step, tag, tensor, sample_rate,
		},
		Attrs: attrs,
	}
	return scope.AddOperation(opspec)
}

// WriteImageSummaryAttr is an optional argument to WriteImageSummary.
type WriteImageSummaryAttr func(optionalAttr)

// WriteImageSummaryMaxImages sets the optional max_images attribute to value.
//
// value: Max number of batch elements to generate images for.
// If not specified, defaults to 3
//
// REQUIRES: value >= 1
func WriteImageSummaryMaxImages(value int64) WriteImageSummaryAttr {
	return func(m optionalAttr) {
		m["max_images"] = value
	}
}

// Writes a `Summary` protocol buffer with images.
//
// The summary has up to `max_images` summary values containing images. The
// images are built from `tensor` which must be 4-D with shape `[batch_size,
// height, width, channels]` and where `channels` can be:
//
// *  1: `tensor` is interpreted as Grayscale.
// *  3: `tensor` is interpreted as RGB.
// *  4: `tensor` is interpreted as RGBA.
//
// The images have the same number of channels as the input tensor. For float
// input, the values are normalized one image at a time to fit in the range
// `[0, 255]`.  `uint8` values are unchanged.  The op uses two different
// normalization algorithms:
//
// *  If the input values are all positive, they are rescaled so the largest one
//    is 255.
//
// *  If any input value is negative, the values are shifted so input value 0.0
//    is at 127.  They are then rescaled so that either the smallest value is 0,
//    or the largest one is 255.
//
// The `tag` argument is a scalar `Tensor` of type `string`.  It is used to
// build the `tag` of the summary values:
//
// *  If `max_images` is 1, the summary value tag is '*tag*/image'.
// *  If `max_images` is greater than 1, the summary value tags are
//    generated sequentially as '*tag*/image/0', '*tag*/image/1', etc.
//
// The `bad_color` argument is the color to use in the generated images for
// non-finite input values.  It is a `unit8` 1-D tensor of length `channels`.
// Each element must be in the range `[0, 255]` (It represents the value of a
// pixel in the output image).  Non-finite values in the input tensor are
// replaced by this tensor in the output image.  The default value is the color
// red.
//
// Arguments:
//	writer: A handle to a summary writer.
//	step: The step to write the summary for.
//	tag: Scalar. Used to build the `tag` attribute of the summary values.
//	tensor: 4-D of shape `[batch_size, height, width, channels]` where
// `channels` is 1, 3, or 4.
//	bad_color: Color to use for pixels with non-finite values.
//
// Returns the created operation.
func WriteImageSummary(scope *Scope, writer tf.Output, step tf.Output, tag tf.Output, tensor tf.Output, bad_color tf.Output, optional ...WriteImageSummaryAttr) (o *tf.Operation) {
	if scope.Err() != nil {
		return
	}
	attrs := map[string]interface{}{}
	for _, a := range optional {
		a(attrs)
	}
	opspec := tf.OpSpec{
		Type: "WriteImageSummary",
		Input: []tf.Input{
			writer, step, tag, tensor, bad_color,
		},
		Attrs: attrs,
	}
	return scope.AddOperation(opspec)
}

// Creates a summary file writer accessible by the given resource handle.
//
// Arguments:
//	writer: A handle to the summary writer resource
//	logdir: Directory where the event file will be written.
//	max_queue: Size of the queue of pending events and summaries.
//	flush_millis: How often, in milliseconds, to flush the pending events and
// summaries to disk.
//	filename_suffix: Every event file's name is suffixed with this suffix.
//
// Returns the created operation.
func CreateSummaryFileWriter(scope *Scope, writer tf.Output, logdir tf.Output, max_queue tf.Output, flush_millis tf.Output, filename_suffix tf.Output) (o *tf.Operation) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "CreateSummaryFileWriter",
		Input: []tf.Input{
			writer, logdir, max_queue, flush_millis, filename_suffix,
		},
	}
	return scope.AddOperation(opspec)
}

// Writes a `GraphDef` protocol buffer to a `SummaryWriter`.
//
// Arguments:
//	writer: Handle of `SummaryWriter`.
//	step: The step to write the summary for.
//	tensor: A scalar string of the serialized tf.GraphDef proto.
//
// Returns the created operation.
func WriteGraphSummary(scope *Scope, writer tf.Output, step tf.Output, tensor tf.Output) (o *tf.Operation) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "WriteGraphSummary",
		Input: []tf.Input{
			writer, step, tensor,
		},
	}
	return scope.AddOperation(opspec)
}

// Creates summary database writer accessible by given resource handle.
//
// This can be used to write tensors from the execution graph directly
// to a database. Only SQLite is supported right now. This function
// will create the schema if it doesn't exist. Entries in the Users,
// Experiments, and Runs tables will be created automatically if they
// don't already exist.
//
// Arguments:
//	writer: Handle to SummaryWriter resource to overwrite.
//	db_uri: For example "file:/tmp/foo.sqlite".
//	experiment_name: Can't contain ASCII control characters or <>. Case
// sensitive. If empty, then the Run will not be associated with any
// Experiment.
//	run_name: Can't contain ASCII control characters or <>. Case sensitive.
// If empty, then each Tag will not be associated with any Run.
//	user_name: Must be valid as both a DNS label and Linux username. If
// empty, then the Experiment will not be associated with any User.
//
// Returns the created operation.
func CreateSummaryDbWriter(scope *Scope, writer tf.Output, db_uri tf.Output, experiment_name tf.Output, run_name tf.Output, user_name tf.Output) (o *tf.Operation) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "CreateSummaryDbWriter",
		Input: []tf.Input{
			writer, db_uri, experiment_name, run_name, user_name,
		},
	}
	return scope.AddOperation(opspec)
}

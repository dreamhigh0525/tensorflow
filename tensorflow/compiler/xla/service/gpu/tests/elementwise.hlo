// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py
// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = getelementptr inbounds i8, i8* %[[VAL_1:.*]], i64 0
// CHECK:         %[[VAL_2:.*]] = bitcast i8* %[[VAL_0]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_3:.*]] = getelementptr inbounds i8, i8* %[[VAL_4:.*]], i64 0
// CHECK:         %[[VAL_5:.*]] = bitcast i8* %[[VAL_3]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_6:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_7:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_8:.*]] = mul nuw nsw i32 %[[VAL_6]], 256
// CHECK:         %[[VAL_9:.*]] = add nuw nsw i32 %[[VAL_8]], %[[VAL_7]]
// CHECK:         %[[VAL_10:.*]] = icmp ult i32 %[[VAL_9]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_10]])
// CHECK:         %[[VAL_11:.*]] = mul nuw nsw i32 %[[VAL_9]], 4
// CHECK:         %[[VAL_12:.*]] = udiv i32 %[[VAL_11]], 1
// CHECK:         %[[VAL_13:.*]] = urem i32 %[[VAL_12]], 200
// CHECK:         %[[VAL_14:.*]] = udiv i32 %[[VAL_11]], 200
// CHECK:         %[[VAL_15:.*]] = add nuw nsw i32 %[[VAL_11]], 1
// CHECK:         %[[VAL_16:.*]] = udiv i32 %[[VAL_15]], 1
// CHECK:         %[[VAL_17:.*]] = urem i32 %[[VAL_16]], 200
// CHECK:         %[[VAL_18:.*]] = udiv i32 %[[VAL_15]], 200
// CHECK:         %[[VAL_19:.*]] = add nuw nsw i32 %[[VAL_11]], 2
// CHECK:         %[[VAL_20:.*]] = udiv i32 %[[VAL_19]], 1
// CHECK:         %[[VAL_21:.*]] = urem i32 %[[VAL_20]], 200
// CHECK:         %[[VAL_22:.*]] = udiv i32 %[[VAL_19]], 200
// CHECK:         %[[VAL_23:.*]] = add nuw nsw i32 %[[VAL_11]], 3
// CHECK:         %[[VAL_24:.*]] = udiv i32 %[[VAL_23]], 1
// CHECK:         %[[VAL_25:.*]] = urem i32 %[[VAL_24]], 200
// CHECK:         %[[VAL_26:.*]] = udiv i32 %[[VAL_23]], 200
// CHECK:         %[[VAL_27:.*]] = icmp ult i32 %[[VAL_11]], 20000
// CHECK:         br i1 %[[VAL_27]], label %[[VAL_28:.*]], label %[[VAL_29:.*]]
// CHECK:       r0.in_bounds-after:                               ; preds = %[[VAL_28]], %[[VAL_30:.*]]
// CHECK:         ret void
// CHECK:       r0.in_bounds-true:                                ; preds = %[[VAL_30]]
// CHECK:         %[[VAL_31:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2]] to float*
// CHECK:         %[[VAL_32:.*]] = getelementptr inbounds float, float* %[[VAL_31]], i32 %[[VAL_11]]
// CHECK:         %[[VAL_33:.*]] = load float, float* %[[VAL_32]], align 4, !invariant.load !94
// CHECK:         %[[VAL_34:.*]] = call float @llvm.fabs.f32(float %[[VAL_33]])
// CHECK:         %[[VAL_35:.*]] = bitcast [100 x [200 x float]]* %[[VAL_5]] to float*
// CHECK:         %[[VAL_36:.*]] = getelementptr inbounds float, float* %[[VAL_35]], i32 %[[VAL_11]]
// CHECK:         store float %[[VAL_34]], float* %[[VAL_36]], align 4
// CHECK:         %[[VAL_37:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2]] to float*
// CHECK:         %[[VAL_38:.*]] = getelementptr inbounds float, float* %[[VAL_37]], i32 %[[VAL_15]]
// CHECK:         %[[VAL_39:.*]] = load float, float* %[[VAL_38]], align 4, !invariant.load !94
// CHECK:         %[[VAL_40:.*]] = call float @llvm.fabs.f32(float %[[VAL_39]])
// CHECK:         %[[VAL_41:.*]] = bitcast [100 x [200 x float]]* %[[VAL_5]] to float*
// CHECK:         %[[VAL_42:.*]] = getelementptr inbounds float, float* %[[VAL_41]], i32 %[[VAL_15]]
// CHECK:         store float %[[VAL_40]], float* %[[VAL_42]], align 4
// CHECK:         %[[VAL_43:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2]] to float*
// CHECK:         %[[VAL_44:.*]] = getelementptr inbounds float, float* %[[VAL_43]], i32 %[[VAL_19]]
// CHECK:         %[[VAL_45:.*]] = load float, float* %[[VAL_44]], align 4, !invariant.load !94
// CHECK:         %[[VAL_46:.*]] = call float @llvm.fabs.f32(float %[[VAL_45]])
// CHECK:         %[[VAL_47:.*]] = bitcast [100 x [200 x float]]* %[[VAL_5]] to float*
// CHECK:         %[[VAL_48:.*]] = getelementptr inbounds float, float* %[[VAL_47]], i32 %[[VAL_19]]
// CHECK:         store float %[[VAL_46]], float* %[[VAL_48]], align 4
// CHECK:         %[[VAL_49:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2]] to float*
// CHECK:         %[[VAL_50:.*]] = getelementptr inbounds float, float* %[[VAL_49]], i32 %[[VAL_23]]
// CHECK:         %[[VAL_51:.*]] = load float, float* %[[VAL_50]], align 4, !invariant.load !94
// CHECK:         %[[VAL_52:.*]] = call float @llvm.fabs.f32(float %[[VAL_51]])
// CHECK:         %[[VAL_53:.*]] = bitcast [100 x [200 x float]]* %[[VAL_5]] to float*
// CHECK:         %[[VAL_54:.*]] = getelementptr inbounds float, float* %[[VAL_53]], i32 %[[VAL_23]]
// CHECK:         store float %[[VAL_52]], float* %[[VAL_54]], align 4
// CHECK:         br label %[[VAL_29]]
// CHECK:       entry:
// CHECK:         %[[VAL_55:.*]] = getelementptr inbounds i8, i8* %[[VAL_56:.*]], i64 0
// CHECK:         %[[VAL_57:.*]] = bitcast i8* %[[VAL_55]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_58:.*]] = getelementptr inbounds i8, i8* %[[VAL_59:.*]], i64 0
// CHECK:         %[[VAL_60:.*]] = bitcast i8* %[[VAL_58]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_61:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_62:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_63:.*]] = mul nuw nsw i32 %[[VAL_61]], 256
// CHECK:         %[[VAL_64:.*]] = add nuw nsw i32 %[[VAL_63]], %[[VAL_62]]
// CHECK:         %[[VAL_65:.*]] = icmp ult i32 %[[VAL_64]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_65]])
// CHECK:         %[[VAL_66:.*]] = mul nuw nsw i32 %[[VAL_64]], 4
// CHECK:         %[[VAL_67:.*]] = udiv i32 %[[VAL_66]], 1
// CHECK:         %[[VAL_68:.*]] = urem i32 %[[VAL_67]], 200
// CHECK:         %[[VAL_69:.*]] = udiv i32 %[[VAL_66]], 200
// CHECK:         %[[VAL_70:.*]] = add nuw nsw i32 %[[VAL_66]], 1
// CHECK:         %[[VAL_71:.*]] = udiv i32 %[[VAL_70]], 1
// CHECK:         %[[VAL_72:.*]] = urem i32 %[[VAL_71]], 200
// CHECK:         %[[VAL_73:.*]] = udiv i32 %[[VAL_70]], 200
// CHECK:         %[[VAL_74:.*]] = add nuw nsw i32 %[[VAL_66]], 2
// CHECK:         %[[VAL_75:.*]] = udiv i32 %[[VAL_74]], 1
// CHECK:         %[[VAL_76:.*]] = urem i32 %[[VAL_75]], 200
// CHECK:         %[[VAL_77:.*]] = udiv i32 %[[VAL_74]], 200
// CHECK:         %[[VAL_78:.*]] = add nuw nsw i32 %[[VAL_66]], 3
// CHECK:         %[[VAL_79:.*]] = udiv i32 %[[VAL_78]], 1
// CHECK:         %[[VAL_80:.*]] = urem i32 %[[VAL_79]], 200
// CHECK:         %[[VAL_81:.*]] = udiv i32 %[[VAL_78]], 200
// CHECK:         %[[VAL_82:.*]] = icmp ult i32 %[[VAL_66]], 20000
// CHECK:         br i1 %[[VAL_82]], label %[[VAL_83:.*]], label %[[VAL_84:.*]]
// CHECK:       r1.in_bounds-after:                               ; preds = %[[VAL_83]], %[[VAL_85:.*]]
// CHECK:         ret void
// CHECK:       r1.in_bounds-true:                                ; preds = %[[VAL_85]]
// CHECK:         %[[VAL_86:.*]] = bitcast [100 x [200 x float]]* %[[VAL_57]] to float*
// CHECK:         %[[VAL_87:.*]] = getelementptr inbounds float, float* %[[VAL_86]], i32 %[[VAL_66]]
// CHECK:         %[[VAL_88:.*]] = load float, float* %[[VAL_87]], align 4, !invariant.load !94
// CHECK:         %[[VAL_89:.*]] = call float @llvm.round.f32(float %[[VAL_88]])
// CHECK:         %[[VAL_90:.*]] = bitcast [100 x [200 x float]]* %[[VAL_60]] to float*
// CHECK:         %[[VAL_91:.*]] = getelementptr inbounds float, float* %[[VAL_90]], i32 %[[VAL_66]]
// CHECK:         store float %[[VAL_89]], float* %[[VAL_91]], align 4
// CHECK:         %[[VAL_92:.*]] = bitcast [100 x [200 x float]]* %[[VAL_57]] to float*
// CHECK:         %[[VAL_93:.*]] = getelementptr inbounds float, float* %[[VAL_92]], i32 %[[VAL_70]]
// CHECK:         %[[VAL_94:.*]] = load float, float* %[[VAL_93]], align 4, !invariant.load !94
// CHECK:         %[[VAL_95:.*]] = call float @llvm.round.f32(float %[[VAL_94]])
// CHECK:         %[[VAL_96:.*]] = bitcast [100 x [200 x float]]* %[[VAL_60]] to float*
// CHECK:         %[[VAL_97:.*]] = getelementptr inbounds float, float* %[[VAL_96]], i32 %[[VAL_70]]
// CHECK:         store float %[[VAL_95]], float* %[[VAL_97]], align 4
// CHECK:         %[[VAL_98:.*]] = bitcast [100 x [200 x float]]* %[[VAL_57]] to float*
// CHECK:         %[[VAL_99:.*]] = getelementptr inbounds float, float* %[[VAL_98]], i32 %[[VAL_74]]
// CHECK:         %[[VAL_100:.*]] = load float, float* %[[VAL_99]], align 4, !invariant.load !94
// CHECK:         %[[VAL_101:.*]] = call float @llvm.round.f32(float %[[VAL_100]])
// CHECK:         %[[VAL_102:.*]] = bitcast [100 x [200 x float]]* %[[VAL_60]] to float*
// CHECK:         %[[VAL_103:.*]] = getelementptr inbounds float, float* %[[VAL_102]], i32 %[[VAL_74]]
// CHECK:         store float %[[VAL_101]], float* %[[VAL_103]], align 4
// CHECK:         %[[VAL_104:.*]] = bitcast [100 x [200 x float]]* %[[VAL_57]] to float*
// CHECK:         %[[VAL_105:.*]] = getelementptr inbounds float, float* %[[VAL_104]], i32 %[[VAL_78]]
// CHECK:         %[[VAL_106:.*]] = load float, float* %[[VAL_105]], align 4, !invariant.load !94
// CHECK:         %[[VAL_107:.*]] = call float @llvm.round.f32(float %[[VAL_106]])
// CHECK:         %[[VAL_108:.*]] = bitcast [100 x [200 x float]]* %[[VAL_60]] to float*
// CHECK:         %[[VAL_109:.*]] = getelementptr inbounds float, float* %[[VAL_108]], i32 %[[VAL_78]]
// CHECK:         store float %[[VAL_107]], float* %[[VAL_109]], align 4
// CHECK:         br label %[[VAL_84]]
// CHECK:       entry:
// CHECK:         %[[VAL_110:.*]] = getelementptr inbounds i8, i8* %[[VAL_111:.*]], i64 0
// CHECK:         %[[VAL_112:.*]] = bitcast i8* %[[VAL_110]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_113:.*]] = getelementptr inbounds i8, i8* %[[VAL_114:.*]], i64 0
// CHECK:         %[[VAL_115:.*]] = bitcast i8* %[[VAL_113]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_116:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_117:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_118:.*]] = mul nuw nsw i32 %[[VAL_116]], 256
// CHECK:         %[[VAL_119:.*]] = add nuw nsw i32 %[[VAL_118]], %[[VAL_117]]
// CHECK:         %[[VAL_120:.*]] = icmp ult i32 %[[VAL_119]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_120]])
// CHECK:         %[[VAL_121:.*]] = mul nuw nsw i32 %[[VAL_119]], 4
// CHECK:         %[[VAL_122:.*]] = udiv i32 %[[VAL_121]], 1
// CHECK:         %[[VAL_123:.*]] = urem i32 %[[VAL_122]], 200
// CHECK:         %[[VAL_124:.*]] = udiv i32 %[[VAL_121]], 200
// CHECK:         %[[VAL_125:.*]] = add nuw nsw i32 %[[VAL_121]], 1
// CHECK:         %[[VAL_126:.*]] = udiv i32 %[[VAL_125]], 1
// CHECK:         %[[VAL_127:.*]] = urem i32 %[[VAL_126]], 200
// CHECK:         %[[VAL_128:.*]] = udiv i32 %[[VAL_125]], 200
// CHECK:         %[[VAL_129:.*]] = add nuw nsw i32 %[[VAL_121]], 2
// CHECK:         %[[VAL_130:.*]] = udiv i32 %[[VAL_129]], 1
// CHECK:         %[[VAL_131:.*]] = urem i32 %[[VAL_130]], 200
// CHECK:         %[[VAL_132:.*]] = udiv i32 %[[VAL_129]], 200
// CHECK:         %[[VAL_133:.*]] = add nuw nsw i32 %[[VAL_121]], 3
// CHECK:         %[[VAL_134:.*]] = udiv i32 %[[VAL_133]], 1
// CHECK:         %[[VAL_135:.*]] = urem i32 %[[VAL_134]], 200
// CHECK:         %[[VAL_136:.*]] = udiv i32 %[[VAL_133]], 200
// CHECK:         %[[VAL_137:.*]] = icmp ult i32 %[[VAL_121]], 20000
// CHECK:         br i1 %[[VAL_137]], label %[[VAL_138:.*]], label %[[VAL_139:.*]]
// CHECK:       r2.in_bounds-after:                               ; preds = %[[VAL_138]], %[[VAL_140:.*]]
// CHECK:         ret void
// CHECK:       r2.in_bounds-true:                                ; preds = %[[VAL_140]]
// CHECK:         %[[VAL_141:.*]] = bitcast [100 x [200 x float]]* %[[VAL_112]] to float*
// CHECK:         %[[VAL_142:.*]] = getelementptr inbounds float, float* %[[VAL_141]], i32 %[[VAL_121]]
// CHECK:         %[[VAL_143:.*]] = load float, float* %[[VAL_142]], align 4, !invariant.load !94
// CHECK:         %[[VAL_144:.*]] = call float @llvm.ceil.f32(float %[[VAL_143]])
// CHECK:         %[[VAL_145:.*]] = bitcast [100 x [200 x float]]* %[[VAL_115]] to float*
// CHECK:         %[[VAL_146:.*]] = getelementptr inbounds float, float* %[[VAL_145]], i32 %[[VAL_121]]
// CHECK:         store float %[[VAL_144]], float* %[[VAL_146]], align 4
// CHECK:         %[[VAL_147:.*]] = bitcast [100 x [200 x float]]* %[[VAL_112]] to float*
// CHECK:         %[[VAL_148:.*]] = getelementptr inbounds float, float* %[[VAL_147]], i32 %[[VAL_125]]
// CHECK:         %[[VAL_149:.*]] = load float, float* %[[VAL_148]], align 4, !invariant.load !94
// CHECK:         %[[VAL_150:.*]] = call float @llvm.ceil.f32(float %[[VAL_149]])
// CHECK:         %[[VAL_151:.*]] = bitcast [100 x [200 x float]]* %[[VAL_115]] to float*
// CHECK:         %[[VAL_152:.*]] = getelementptr inbounds float, float* %[[VAL_151]], i32 %[[VAL_125]]
// CHECK:         store float %[[VAL_150]], float* %[[VAL_152]], align 4
// CHECK:         %[[VAL_153:.*]] = bitcast [100 x [200 x float]]* %[[VAL_112]] to float*
// CHECK:         %[[VAL_154:.*]] = getelementptr inbounds float, float* %[[VAL_153]], i32 %[[VAL_129]]
// CHECK:         %[[VAL_155:.*]] = load float, float* %[[VAL_154]], align 4, !invariant.load !94
// CHECK:         %[[VAL_156:.*]] = call float @llvm.ceil.f32(float %[[VAL_155]])
// CHECK:         %[[VAL_157:.*]] = bitcast [100 x [200 x float]]* %[[VAL_115]] to float*
// CHECK:         %[[VAL_158:.*]] = getelementptr inbounds float, float* %[[VAL_157]], i32 %[[VAL_129]]
// CHECK:         store float %[[VAL_156]], float* %[[VAL_158]], align 4
// CHECK:         %[[VAL_159:.*]] = bitcast [100 x [200 x float]]* %[[VAL_112]] to float*
// CHECK:         %[[VAL_160:.*]] = getelementptr inbounds float, float* %[[VAL_159]], i32 %[[VAL_133]]
// CHECK:         %[[VAL_161:.*]] = load float, float* %[[VAL_160]], align 4, !invariant.load !94
// CHECK:         %[[VAL_162:.*]] = call float @llvm.ceil.f32(float %[[VAL_161]])
// CHECK:         %[[VAL_163:.*]] = bitcast [100 x [200 x float]]* %[[VAL_115]] to float*
// CHECK:         %[[VAL_164:.*]] = getelementptr inbounds float, float* %[[VAL_163]], i32 %[[VAL_133]]
// CHECK:         store float %[[VAL_162]], float* %[[VAL_164]], align 4
// CHECK:         br label %[[VAL_139]]
// CHECK:       entry:
// CHECK:         %[[VAL_165:.*]] = getelementptr inbounds i8, i8* %[[VAL_166:.*]], i64 0
// CHECK:         %[[VAL_167:.*]] = bitcast i8* %[[VAL_165]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_168:.*]] = getelementptr inbounds i8, i8* %[[VAL_169:.*]], i64 0
// CHECK:         %[[VAL_170:.*]] = bitcast i8* %[[VAL_168]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_171:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_172:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_173:.*]] = mul nuw nsw i32 %[[VAL_171]], 256
// CHECK:         %[[VAL_174:.*]] = add nuw nsw i32 %[[VAL_173]], %[[VAL_172]]
// CHECK:         %[[VAL_175:.*]] = icmp ult i32 %[[VAL_174]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_175]])
// CHECK:         %[[VAL_176:.*]] = mul nuw nsw i32 %[[VAL_174]], 4
// CHECK:         %[[VAL_177:.*]] = udiv i32 %[[VAL_176]], 1
// CHECK:         %[[VAL_178:.*]] = urem i32 %[[VAL_177]], 200
// CHECK:         %[[VAL_179:.*]] = udiv i32 %[[VAL_176]], 200
// CHECK:         %[[VAL_180:.*]] = add nuw nsw i32 %[[VAL_176]], 1
// CHECK:         %[[VAL_181:.*]] = udiv i32 %[[VAL_180]], 1
// CHECK:         %[[VAL_182:.*]] = urem i32 %[[VAL_181]], 200
// CHECK:         %[[VAL_183:.*]] = udiv i32 %[[VAL_180]], 200
// CHECK:         %[[VAL_184:.*]] = add nuw nsw i32 %[[VAL_176]], 2
// CHECK:         %[[VAL_185:.*]] = udiv i32 %[[VAL_184]], 1
// CHECK:         %[[VAL_186:.*]] = urem i32 %[[VAL_185]], 200
// CHECK:         %[[VAL_187:.*]] = udiv i32 %[[VAL_184]], 200
// CHECK:         %[[VAL_188:.*]] = add nuw nsw i32 %[[VAL_176]], 3
// CHECK:         %[[VAL_189:.*]] = udiv i32 %[[VAL_188]], 1
// CHECK:         %[[VAL_190:.*]] = urem i32 %[[VAL_189]], 200
// CHECK:         %[[VAL_191:.*]] = udiv i32 %[[VAL_188]], 200
// CHECK:         %[[VAL_192:.*]] = icmp ult i32 %[[VAL_176]], 20000
// CHECK:         br i1 %[[VAL_192]], label %[[VAL_193:.*]], label %[[VAL_194:.*]]
// CHECK:       r3.in_bounds-after:                               ; preds = %[[VAL_193]], %[[VAL_195:.*]]
// CHECK:         ret void
// CHECK:       r3.in_bounds-true:                                ; preds = %[[VAL_195]]
// CHECK:         %[[VAL_196:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_167]] to i32*
// CHECK:         %[[VAL_197:.*]] = getelementptr inbounds i32, i32* %[[VAL_196]], i32 %[[VAL_176]]
// CHECK:         %[[VAL_198:.*]] = load i32, i32* %[[VAL_197]], align 4, !invariant.load !94
// CHECK:         %[[VAL_199:.*]] = call i32 @llvm.ctlz.i32(i32 %[[VAL_198]], i1 false)
// CHECK:         %[[VAL_200:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_170]] to i32*
// CHECK:         %[[VAL_201:.*]] = getelementptr inbounds i32, i32* %[[VAL_200]], i32 %[[VAL_176]]
// CHECK:         store i32 %[[VAL_199]], i32* %[[VAL_201]], align 4
// CHECK:         %[[VAL_202:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_167]] to i32*
// CHECK:         %[[VAL_203:.*]] = getelementptr inbounds i32, i32* %[[VAL_202]], i32 %[[VAL_180]]
// CHECK:         %[[VAL_204:.*]] = load i32, i32* %[[VAL_203]], align 4, !invariant.load !94
// CHECK:         %[[VAL_205:.*]] = call i32 @llvm.ctlz.i32(i32 %[[VAL_204]], i1 false)
// CHECK:         %[[VAL_206:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_170]] to i32*
// CHECK:         %[[VAL_207:.*]] = getelementptr inbounds i32, i32* %[[VAL_206]], i32 %[[VAL_180]]
// CHECK:         store i32 %[[VAL_205]], i32* %[[VAL_207]], align 4
// CHECK:         %[[VAL_208:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_167]] to i32*
// CHECK:         %[[VAL_209:.*]] = getelementptr inbounds i32, i32* %[[VAL_208]], i32 %[[VAL_184]]
// CHECK:         %[[VAL_210:.*]] = load i32, i32* %[[VAL_209]], align 4, !invariant.load !94
// CHECK:         %[[VAL_211:.*]] = call i32 @llvm.ctlz.i32(i32 %[[VAL_210]], i1 false)
// CHECK:         %[[VAL_212:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_170]] to i32*
// CHECK:         %[[VAL_213:.*]] = getelementptr inbounds i32, i32* %[[VAL_212]], i32 %[[VAL_184]]
// CHECK:         store i32 %[[VAL_211]], i32* %[[VAL_213]], align 4
// CHECK:         %[[VAL_214:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_167]] to i32*
// CHECK:         %[[VAL_215:.*]] = getelementptr inbounds i32, i32* %[[VAL_214]], i32 %[[VAL_188]]
// CHECK:         %[[VAL_216:.*]] = load i32, i32* %[[VAL_215]], align 4, !invariant.load !94
// CHECK:         %[[VAL_217:.*]] = call i32 @llvm.ctlz.i32(i32 %[[VAL_216]], i1 false)
// CHECK:         %[[VAL_218:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_170]] to i32*
// CHECK:         %[[VAL_219:.*]] = getelementptr inbounds i32, i32* %[[VAL_218]], i32 %[[VAL_188]]
// CHECK:         store i32 %[[VAL_217]], i32* %[[VAL_219]], align 4
// CHECK:         br label %[[VAL_194]]
// CHECK:       entry:
// CHECK:         %[[VAL_220:.*]] = getelementptr inbounds i8, i8* %[[VAL_221:.*]], i64 0
// CHECK:         %[[VAL_222:.*]] = bitcast i8* %[[VAL_220]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_223:.*]] = getelementptr inbounds i8, i8* %[[VAL_224:.*]], i64 0
// CHECK:         %[[VAL_225:.*]] = bitcast i8* %[[VAL_223]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_226:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_227:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_228:.*]] = mul nuw nsw i32 %[[VAL_226]], 256
// CHECK:         %[[VAL_229:.*]] = add nuw nsw i32 %[[VAL_228]], %[[VAL_227]]
// CHECK:         %[[VAL_230:.*]] = icmp ult i32 %[[VAL_229]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_230]])
// CHECK:         %[[VAL_231:.*]] = mul nuw nsw i32 %[[VAL_229]], 4
// CHECK:         %[[VAL_232:.*]] = udiv i32 %[[VAL_231]], 1
// CHECK:         %[[VAL_233:.*]] = urem i32 %[[VAL_232]], 200
// CHECK:         %[[VAL_234:.*]] = udiv i32 %[[VAL_231]], 200
// CHECK:         %[[VAL_235:.*]] = add nuw nsw i32 %[[VAL_231]], 1
// CHECK:         %[[VAL_236:.*]] = udiv i32 %[[VAL_235]], 1
// CHECK:         %[[VAL_237:.*]] = urem i32 %[[VAL_236]], 200
// CHECK:         %[[VAL_238:.*]] = udiv i32 %[[VAL_235]], 200
// CHECK:         %[[VAL_239:.*]] = add nuw nsw i32 %[[VAL_231]], 2
// CHECK:         %[[VAL_240:.*]] = udiv i32 %[[VAL_239]], 1
// CHECK:         %[[VAL_241:.*]] = urem i32 %[[VAL_240]], 200
// CHECK:         %[[VAL_242:.*]] = udiv i32 %[[VAL_239]], 200
// CHECK:         %[[VAL_243:.*]] = add nuw nsw i32 %[[VAL_231]], 3
// CHECK:         %[[VAL_244:.*]] = udiv i32 %[[VAL_243]], 1
// CHECK:         %[[VAL_245:.*]] = urem i32 %[[VAL_244]], 200
// CHECK:         %[[VAL_246:.*]] = udiv i32 %[[VAL_243]], 200
// CHECK:         %[[VAL_247:.*]] = icmp ult i32 %[[VAL_231]], 20000
// CHECK:         br i1 %[[VAL_247]], label %[[VAL_248:.*]], label %[[VAL_249:.*]]
// CHECK:       r4.in_bounds-after:                               ; preds = %[[VAL_248]], %[[VAL_250:.*]]
// CHECK:         ret void
// CHECK:       r4.in_bounds-true:                                ; preds = %[[VAL_250]]
// CHECK:         %[[VAL_251:.*]] = bitcast [100 x [200 x float]]* %[[VAL_222]] to float*
// CHECK:         %[[VAL_252:.*]] = getelementptr inbounds float, float* %[[VAL_251]], i32 %[[VAL_231]]
// CHECK:         %[[VAL_253:.*]] = load float, float* %[[VAL_252]], align 4, !invariant.load !94
// CHECK:         %[[VAL_254:.*]] = bitcast [100 x [200 x float]]* %[[VAL_225]] to float*
// CHECK:         %[[VAL_255:.*]] = getelementptr inbounds float, float* %[[VAL_254]], i32 %[[VAL_231]]
// CHECK:         store float %[[VAL_253]], float* %[[VAL_255]], align 4
// CHECK:         %[[VAL_256:.*]] = bitcast [100 x [200 x float]]* %[[VAL_222]] to float*
// CHECK:         %[[VAL_257:.*]] = getelementptr inbounds float, float* %[[VAL_256]], i32 %[[VAL_235]]
// CHECK:         %[[VAL_258:.*]] = load float, float* %[[VAL_257]], align 4, !invariant.load !94
// CHECK:         %[[VAL_259:.*]] = bitcast [100 x [200 x float]]* %[[VAL_225]] to float*
// CHECK:         %[[VAL_260:.*]] = getelementptr inbounds float, float* %[[VAL_259]], i32 %[[VAL_235]]
// CHECK:         store float %[[VAL_258]], float* %[[VAL_260]], align 4
// CHECK:         %[[VAL_261:.*]] = bitcast [100 x [200 x float]]* %[[VAL_222]] to float*
// CHECK:         %[[VAL_262:.*]] = getelementptr inbounds float, float* %[[VAL_261]], i32 %[[VAL_239]]
// CHECK:         %[[VAL_263:.*]] = load float, float* %[[VAL_262]], align 4, !invariant.load !94
// CHECK:         %[[VAL_264:.*]] = bitcast [100 x [200 x float]]* %[[VAL_225]] to float*
// CHECK:         %[[VAL_265:.*]] = getelementptr inbounds float, float* %[[VAL_264]], i32 %[[VAL_239]]
// CHECK:         store float %[[VAL_263]], float* %[[VAL_265]], align 4
// CHECK:         %[[VAL_266:.*]] = bitcast [100 x [200 x float]]* %[[VAL_222]] to float*
// CHECK:         %[[VAL_267:.*]] = getelementptr inbounds float, float* %[[VAL_266]], i32 %[[VAL_243]]
// CHECK:         %[[VAL_268:.*]] = load float, float* %[[VAL_267]], align 4, !invariant.load !94
// CHECK:         %[[VAL_269:.*]] = bitcast [100 x [200 x float]]* %[[VAL_225]] to float*
// CHECK:         %[[VAL_270:.*]] = getelementptr inbounds float, float* %[[VAL_269]], i32 %[[VAL_243]]
// CHECK:         store float %[[VAL_268]], float* %[[VAL_270]], align 4
// CHECK:         br label %[[VAL_249]]
// CHECK:       entry:
// CHECK:         %[[VAL_271:.*]] = getelementptr inbounds i8, i8* %[[VAL_272:.*]], i64 0
// CHECK:         %[[VAL_273:.*]] = bitcast i8* %[[VAL_271]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_274:.*]] = getelementptr inbounds i8, i8* %[[VAL_275:.*]], i64 0
// CHECK:         %[[VAL_276:.*]] = bitcast i8* %[[VAL_274]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_277:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_278:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_279:.*]] = mul nuw nsw i32 %[[VAL_277]], 256
// CHECK:         %[[VAL_280:.*]] = add nuw nsw i32 %[[VAL_279]], %[[VAL_278]]
// CHECK:         %[[VAL_281:.*]] = icmp ult i32 %[[VAL_280]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_281]])
// CHECK:         %[[VAL_282:.*]] = mul nuw nsw i32 %[[VAL_280]], 4
// CHECK:         %[[VAL_283:.*]] = udiv i32 %[[VAL_282]], 1
// CHECK:         %[[VAL_284:.*]] = urem i32 %[[VAL_283]], 200
// CHECK:         %[[VAL_285:.*]] = udiv i32 %[[VAL_282]], 200
// CHECK:         %[[VAL_286:.*]] = add nuw nsw i32 %[[VAL_282]], 1
// CHECK:         %[[VAL_287:.*]] = udiv i32 %[[VAL_286]], 1
// CHECK:         %[[VAL_288:.*]] = urem i32 %[[VAL_287]], 200
// CHECK:         %[[VAL_289:.*]] = udiv i32 %[[VAL_286]], 200
// CHECK:         %[[VAL_290:.*]] = add nuw nsw i32 %[[VAL_282]], 2
// CHECK:         %[[VAL_291:.*]] = udiv i32 %[[VAL_290]], 1
// CHECK:         %[[VAL_292:.*]] = urem i32 %[[VAL_291]], 200
// CHECK:         %[[VAL_293:.*]] = udiv i32 %[[VAL_290]], 200
// CHECK:         %[[VAL_294:.*]] = add nuw nsw i32 %[[VAL_282]], 3
// CHECK:         %[[VAL_295:.*]] = udiv i32 %[[VAL_294]], 1
// CHECK:         %[[VAL_296:.*]] = urem i32 %[[VAL_295]], 200
// CHECK:         %[[VAL_297:.*]] = udiv i32 %[[VAL_294]], 200
// CHECK:         %[[VAL_298:.*]] = icmp ult i32 %[[VAL_282]], 20000
// CHECK:         br i1 %[[VAL_298]], label %[[VAL_299:.*]], label %[[VAL_300:.*]]
// CHECK:       r5.in_bounds-after:                               ; preds = %[[VAL_299]], %[[VAL_301:.*]]
// CHECK:         ret void
// CHECK:       r5.in_bounds-true:                                ; preds = %[[VAL_301]]
// CHECK:         %[[VAL_302:.*]] = bitcast [100 x [200 x float]]* %[[VAL_273]] to float*
// CHECK:         %[[VAL_303:.*]] = getelementptr inbounds float, float* %[[VAL_302]], i32 %[[VAL_282]]
// CHECK:         %[[VAL_304:.*]] = load float, float* %[[VAL_303]], align 4, !invariant.load !94
// CHECK:         %[[VAL_305:.*]] = bitcast [100 x [200 x float]]* %[[VAL_276]] to float*
// CHECK:         %[[VAL_306:.*]] = getelementptr inbounds float, float* %[[VAL_305]], i32 %[[VAL_282]]
// CHECK:         store float %[[VAL_304]], float* %[[VAL_306]], align 4
// CHECK:         %[[VAL_307:.*]] = bitcast [100 x [200 x float]]* %[[VAL_273]] to float*
// CHECK:         %[[VAL_308:.*]] = getelementptr inbounds float, float* %[[VAL_307]], i32 %[[VAL_286]]
// CHECK:         %[[VAL_309:.*]] = load float, float* %[[VAL_308]], align 4, !invariant.load !94
// CHECK:         %[[VAL_310:.*]] = bitcast [100 x [200 x float]]* %[[VAL_276]] to float*
// CHECK:         %[[VAL_311:.*]] = getelementptr inbounds float, float* %[[VAL_310]], i32 %[[VAL_286]]
// CHECK:         store float %[[VAL_309]], float* %[[VAL_311]], align 4
// CHECK:         %[[VAL_312:.*]] = bitcast [100 x [200 x float]]* %[[VAL_273]] to float*
// CHECK:         %[[VAL_313:.*]] = getelementptr inbounds float, float* %[[VAL_312]], i32 %[[VAL_290]]
// CHECK:         %[[VAL_314:.*]] = load float, float* %[[VAL_313]], align 4, !invariant.load !94
// CHECK:         %[[VAL_315:.*]] = bitcast [100 x [200 x float]]* %[[VAL_276]] to float*
// CHECK:         %[[VAL_316:.*]] = getelementptr inbounds float, float* %[[VAL_315]], i32 %[[VAL_290]]
// CHECK:         store float %[[VAL_314]], float* %[[VAL_316]], align 4
// CHECK:         %[[VAL_317:.*]] = bitcast [100 x [200 x float]]* %[[VAL_273]] to float*
// CHECK:         %[[VAL_318:.*]] = getelementptr inbounds float, float* %[[VAL_317]], i32 %[[VAL_294]]
// CHECK:         %[[VAL_319:.*]] = load float, float* %[[VAL_318]], align 4, !invariant.load !94
// CHECK:         %[[VAL_320:.*]] = bitcast [100 x [200 x float]]* %[[VAL_276]] to float*
// CHECK:         %[[VAL_321:.*]] = getelementptr inbounds float, float* %[[VAL_320]], i32 %[[VAL_294]]
// CHECK:         store float %[[VAL_319]], float* %[[VAL_321]], align 4
// CHECK:         br label %[[VAL_300]]
// CHECK:       entry:
// CHECK:         %[[VAL_322:.*]] = getelementptr inbounds i8, i8* %[[VAL_323:.*]], i64 0
// CHECK:         %[[VAL_324:.*]] = bitcast i8* %[[VAL_322]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_325:.*]] = getelementptr inbounds i8, i8* %[[VAL_326:.*]], i64 0
// CHECK:         %[[VAL_327:.*]] = bitcast i8* %[[VAL_325]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_328:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_329:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !95
// CHECK:         %[[VAL_330:.*]] = mul nuw nsw i32 %[[VAL_328]], 1024
// CHECK:         %[[VAL_331:.*]] = add nuw nsw i32 %[[VAL_330]], %[[VAL_329]]
// CHECK:         %[[VAL_332:.*]] = icmp ult i32 %[[VAL_331]], 20480
// CHECK:         call void @llvm.assume(i1 %[[VAL_332]])
// CHECK:         %[[VAL_333:.*]] = udiv i32 %[[VAL_331]], 1
// CHECK:         %[[VAL_334:.*]] = urem i32 %[[VAL_333]], 200
// CHECK:         %[[VAL_335:.*]] = udiv i32 %[[VAL_331]], 200
// CHECK:         %[[VAL_336:.*]] = icmp ult i32 %[[VAL_331]], 20000
// CHECK:         br i1 %[[VAL_336]], label %[[VAL_337:.*]], label %[[VAL_338:.*]]
// CHECK:       r7.in_bounds-after:                               ; preds = %[[VAL_337]], %[[VAL_339:.*]]
// CHECK:         ret void
// CHECK:       r7.in_bounds-true:                                ; preds = %[[VAL_339]]
// CHECK:         %[[VAL_340:.*]] = bitcast [100 x [200 x float]]* %[[VAL_324]] to float*
// CHECK:         %[[VAL_341:.*]] = getelementptr inbounds float, float* %[[VAL_340]], i32 %[[VAL_331]]
// CHECK:         %[[VAL_342:.*]] = load float, float* %[[VAL_341]], align 4, !invariant.load !94
// CHECK:         %[[VAL_343:.*]] = call float @__nv_cosf(float %[[VAL_342]])
// CHECK:         %[[VAL_344:.*]] = bitcast [100 x [200 x float]]* %[[VAL_327]] to float*
// CHECK:         %[[VAL_345:.*]] = getelementptr inbounds float, float* %[[VAL_344]], i32 %[[VAL_331]]
// CHECK:         store float %[[VAL_343]], float* %[[VAL_345]], align 4
// CHECK:         br label %[[VAL_338]]
// CHECK:       entry:
// CHECK:         %[[VAL_346:.*]] = getelementptr inbounds i8, i8* %[[VAL_347:.*]], i64 0
// CHECK:         %[[VAL_348:.*]] = bitcast i8* %[[VAL_346]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_349:.*]] = getelementptr inbounds i8, i8* %[[VAL_350:.*]], i64 0
// CHECK:         %[[VAL_351:.*]] = bitcast i8* %[[VAL_349]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_352:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_353:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_354:.*]] = mul nuw nsw i32 %[[VAL_352]], 256
// CHECK:         %[[VAL_355:.*]] = add nuw nsw i32 %[[VAL_354]], %[[VAL_353]]
// CHECK:         %[[VAL_356:.*]] = icmp ult i32 %[[VAL_355]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_356]])
// CHECK:         %[[VAL_357:.*]] = mul nuw nsw i32 %[[VAL_355]], 4
// CHECK:         %[[VAL_358:.*]] = udiv i32 %[[VAL_357]], 1
// CHECK:         %[[VAL_359:.*]] = urem i32 %[[VAL_358]], 200
// CHECK:         %[[VAL_360:.*]] = udiv i32 %[[VAL_357]], 200
// CHECK:         %[[VAL_361:.*]] = add nuw nsw i32 %[[VAL_357]], 1
// CHECK:         %[[VAL_362:.*]] = udiv i32 %[[VAL_361]], 1
// CHECK:         %[[VAL_363:.*]] = urem i32 %[[VAL_362]], 200
// CHECK:         %[[VAL_364:.*]] = udiv i32 %[[VAL_361]], 200
// CHECK:         %[[VAL_365:.*]] = add nuw nsw i32 %[[VAL_357]], 2
// CHECK:         %[[VAL_366:.*]] = udiv i32 %[[VAL_365]], 1
// CHECK:         %[[VAL_367:.*]] = urem i32 %[[VAL_366]], 200
// CHECK:         %[[VAL_368:.*]] = udiv i32 %[[VAL_365]], 200
// CHECK:         %[[VAL_369:.*]] = add nuw nsw i32 %[[VAL_357]], 3
// CHECK:         %[[VAL_370:.*]] = udiv i32 %[[VAL_369]], 1
// CHECK:         %[[VAL_371:.*]] = urem i32 %[[VAL_370]], 200
// CHECK:         %[[VAL_372:.*]] = udiv i32 %[[VAL_369]], 200
// CHECK:         %[[VAL_373:.*]] = icmp ult i32 %[[VAL_357]], 20000
// CHECK:         br i1 %[[VAL_373]], label %[[VAL_374:.*]], label %[[VAL_375:.*]]
// CHECK:       r8.in_bounds-after:                               ; preds = %[[VAL_374]], %[[VAL_376:.*]]
// CHECK:         ret void
// CHECK:       r8.in_bounds-true:                                ; preds = %[[VAL_376]]
// CHECK:         %[[VAL_377:.*]] = bitcast [100 x [200 x float]]* %[[VAL_348]] to float*
// CHECK:         %[[VAL_378:.*]] = getelementptr inbounds float, float* %[[VAL_377]], i32 %[[VAL_357]]
// CHECK:         %[[VAL_379:.*]] = load float, float* %[[VAL_378]], align 4, !invariant.load !94
// CHECK:         %[[VAL_380:.*]] = call float @__nv_expf(float %[[VAL_379]])
// CHECK:         %[[VAL_381:.*]] = bitcast [100 x [200 x float]]* %[[VAL_351]] to float*
// CHECK:         %[[VAL_382:.*]] = getelementptr inbounds float, float* %[[VAL_381]], i32 %[[VAL_357]]
// CHECK:         store float %[[VAL_380]], float* %[[VAL_382]], align 4
// CHECK:         %[[VAL_383:.*]] = bitcast [100 x [200 x float]]* %[[VAL_348]] to float*
// CHECK:         %[[VAL_384:.*]] = getelementptr inbounds float, float* %[[VAL_383]], i32 %[[VAL_361]]
// CHECK:         %[[VAL_385:.*]] = load float, float* %[[VAL_384]], align 4, !invariant.load !94
// CHECK:         %[[VAL_386:.*]] = call float @__nv_expf(float %[[VAL_385]])
// CHECK:         %[[VAL_387:.*]] = bitcast [100 x [200 x float]]* %[[VAL_351]] to float*
// CHECK:         %[[VAL_388:.*]] = getelementptr inbounds float, float* %[[VAL_387]], i32 %[[VAL_361]]
// CHECK:         store float %[[VAL_386]], float* %[[VAL_388]], align 4
// CHECK:         %[[VAL_389:.*]] = bitcast [100 x [200 x float]]* %[[VAL_348]] to float*
// CHECK:         %[[VAL_390:.*]] = getelementptr inbounds float, float* %[[VAL_389]], i32 %[[VAL_365]]
// CHECK:         %[[VAL_391:.*]] = load float, float* %[[VAL_390]], align 4, !invariant.load !94
// CHECK:         %[[VAL_392:.*]] = call float @__nv_expf(float %[[VAL_391]])
// CHECK:         %[[VAL_393:.*]] = bitcast [100 x [200 x float]]* %[[VAL_351]] to float*
// CHECK:         %[[VAL_394:.*]] = getelementptr inbounds float, float* %[[VAL_393]], i32 %[[VAL_365]]
// CHECK:         store float %[[VAL_392]], float* %[[VAL_394]], align 4
// CHECK:         %[[VAL_395:.*]] = bitcast [100 x [200 x float]]* %[[VAL_348]] to float*
// CHECK:         %[[VAL_396:.*]] = getelementptr inbounds float, float* %[[VAL_395]], i32 %[[VAL_369]]
// CHECK:         %[[VAL_397:.*]] = load float, float* %[[VAL_396]], align 4, !invariant.load !94
// CHECK:         %[[VAL_398:.*]] = call float @__nv_expf(float %[[VAL_397]])
// CHECK:         %[[VAL_399:.*]] = bitcast [100 x [200 x float]]* %[[VAL_351]] to float*
// CHECK:         %[[VAL_400:.*]] = getelementptr inbounds float, float* %[[VAL_399]], i32 %[[VAL_369]]
// CHECK:         store float %[[VAL_398]], float* %[[VAL_400]], align 4
// CHECK:         br label %[[VAL_375]]
// CHECK:       entry:
// CHECK:         %[[VAL_401:.*]] = getelementptr inbounds i8, i8* %[[VAL_402:.*]], i64 0
// CHECK:         %[[VAL_403:.*]] = bitcast i8* %[[VAL_401]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_404:.*]] = getelementptr inbounds i8, i8* %[[VAL_405:.*]], i64 0
// CHECK:         %[[VAL_406:.*]] = bitcast i8* %[[VAL_404]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_407:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_408:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_409:.*]] = mul nuw nsw i32 %[[VAL_407]], 256
// CHECK:         %[[VAL_410:.*]] = add nuw nsw i32 %[[VAL_409]], %[[VAL_408]]
// CHECK:         %[[VAL_411:.*]] = icmp ult i32 %[[VAL_410]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_411]])
// CHECK:         %[[VAL_412:.*]] = mul nuw nsw i32 %[[VAL_410]], 4
// CHECK:         %[[VAL_413:.*]] = udiv i32 %[[VAL_412]], 1
// CHECK:         %[[VAL_414:.*]] = urem i32 %[[VAL_413]], 200
// CHECK:         %[[VAL_415:.*]] = udiv i32 %[[VAL_412]], 200
// CHECK:         %[[VAL_416:.*]] = add nuw nsw i32 %[[VAL_412]], 1
// CHECK:         %[[VAL_417:.*]] = udiv i32 %[[VAL_416]], 1
// CHECK:         %[[VAL_418:.*]] = urem i32 %[[VAL_417]], 200
// CHECK:         %[[VAL_419:.*]] = udiv i32 %[[VAL_416]], 200
// CHECK:         %[[VAL_420:.*]] = add nuw nsw i32 %[[VAL_412]], 2
// CHECK:         %[[VAL_421:.*]] = udiv i32 %[[VAL_420]], 1
// CHECK:         %[[VAL_422:.*]] = urem i32 %[[VAL_421]], 200
// CHECK:         %[[VAL_423:.*]] = udiv i32 %[[VAL_420]], 200
// CHECK:         %[[VAL_424:.*]] = add nuw nsw i32 %[[VAL_412]], 3
// CHECK:         %[[VAL_425:.*]] = udiv i32 %[[VAL_424]], 1
// CHECK:         %[[VAL_426:.*]] = urem i32 %[[VAL_425]], 200
// CHECK:         %[[VAL_427:.*]] = udiv i32 %[[VAL_424]], 200
// CHECK:         %[[VAL_428:.*]] = icmp ult i32 %[[VAL_412]], 20000
// CHECK:         br i1 %[[VAL_428]], label %[[VAL_429:.*]], label %[[VAL_430:.*]]
// CHECK:       r9.in_bounds-after:                               ; preds = %[[VAL_429]], %[[VAL_431:.*]]
// CHECK:         ret void
// CHECK:       r9.in_bounds-true:                                ; preds = %[[VAL_431]]
// CHECK:         %[[VAL_432:.*]] = bitcast [100 x [200 x float]]* %[[VAL_403]] to float*
// CHECK:         %[[VAL_433:.*]] = getelementptr inbounds float, float* %[[VAL_432]], i32 %[[VAL_412]]
// CHECK:         %[[VAL_434:.*]] = load float, float* %[[VAL_433]], align 4, !invariant.load !94
// CHECK:         %[[VAL_435:.*]] = call float @__nv_expm1f(float %[[VAL_434]])
// CHECK:         %[[VAL_436:.*]] = bitcast [100 x [200 x float]]* %[[VAL_406]] to float*
// CHECK:         %[[VAL_437:.*]] = getelementptr inbounds float, float* %[[VAL_436]], i32 %[[VAL_412]]
// CHECK:         store float %[[VAL_435]], float* %[[VAL_437]], align 4
// CHECK:         %[[VAL_438:.*]] = bitcast [100 x [200 x float]]* %[[VAL_403]] to float*
// CHECK:         %[[VAL_439:.*]] = getelementptr inbounds float, float* %[[VAL_438]], i32 %[[VAL_416]]
// CHECK:         %[[VAL_440:.*]] = load float, float* %[[VAL_439]], align 4, !invariant.load !94
// CHECK:         %[[VAL_441:.*]] = call float @__nv_expm1f(float %[[VAL_440]])
// CHECK:         %[[VAL_442:.*]] = bitcast [100 x [200 x float]]* %[[VAL_406]] to float*
// CHECK:         %[[VAL_443:.*]] = getelementptr inbounds float, float* %[[VAL_442]], i32 %[[VAL_416]]
// CHECK:         store float %[[VAL_441]], float* %[[VAL_443]], align 4
// CHECK:         %[[VAL_444:.*]] = bitcast [100 x [200 x float]]* %[[VAL_403]] to float*
// CHECK:         %[[VAL_445:.*]] = getelementptr inbounds float, float* %[[VAL_444]], i32 %[[VAL_420]]
// CHECK:         %[[VAL_446:.*]] = load float, float* %[[VAL_445]], align 4, !invariant.load !94
// CHECK:         %[[VAL_447:.*]] = call float @__nv_expm1f(float %[[VAL_446]])
// CHECK:         %[[VAL_448:.*]] = bitcast [100 x [200 x float]]* %[[VAL_406]] to float*
// CHECK:         %[[VAL_449:.*]] = getelementptr inbounds float, float* %[[VAL_448]], i32 %[[VAL_420]]
// CHECK:         store float %[[VAL_447]], float* %[[VAL_449]], align 4
// CHECK:         %[[VAL_450:.*]] = bitcast [100 x [200 x float]]* %[[VAL_403]] to float*
// CHECK:         %[[VAL_451:.*]] = getelementptr inbounds float, float* %[[VAL_450]], i32 %[[VAL_424]]
// CHECK:         %[[VAL_452:.*]] = load float, float* %[[VAL_451]], align 4, !invariant.load !94
// CHECK:         %[[VAL_453:.*]] = call float @__nv_expm1f(float %[[VAL_452]])
// CHECK:         %[[VAL_454:.*]] = bitcast [100 x [200 x float]]* %[[VAL_406]] to float*
// CHECK:         %[[VAL_455:.*]] = getelementptr inbounds float, float* %[[VAL_454]], i32 %[[VAL_424]]
// CHECK:         store float %[[VAL_453]], float* %[[VAL_455]], align 4
// CHECK:         br label %[[VAL_430]]
// CHECK:       entry:
// CHECK:         %[[VAL_456:.*]] = getelementptr inbounds i8, i8* %[[VAL_457:.*]], i64 0
// CHECK:         %[[VAL_458:.*]] = bitcast i8* %[[VAL_456]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_459:.*]] = getelementptr inbounds i8, i8* %[[VAL_460:.*]], i64 0
// CHECK:         %[[VAL_461:.*]] = bitcast i8* %[[VAL_459]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_462:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_463:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_464:.*]] = mul nuw nsw i32 %[[VAL_462]], 256
// CHECK:         %[[VAL_465:.*]] = add nuw nsw i32 %[[VAL_464]], %[[VAL_463]]
// CHECK:         %[[VAL_466:.*]] = icmp ult i32 %[[VAL_465]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_466]])
// CHECK:         %[[VAL_467:.*]] = mul nuw nsw i32 %[[VAL_465]], 4
// CHECK:         %[[VAL_468:.*]] = udiv i32 %[[VAL_467]], 1
// CHECK:         %[[VAL_469:.*]] = urem i32 %[[VAL_468]], 200
// CHECK:         %[[VAL_470:.*]] = udiv i32 %[[VAL_467]], 200
// CHECK:         %[[VAL_471:.*]] = add nuw nsw i32 %[[VAL_467]], 1
// CHECK:         %[[VAL_472:.*]] = udiv i32 %[[VAL_471]], 1
// CHECK:         %[[VAL_473:.*]] = urem i32 %[[VAL_472]], 200
// CHECK:         %[[VAL_474:.*]] = udiv i32 %[[VAL_471]], 200
// CHECK:         %[[VAL_475:.*]] = add nuw nsw i32 %[[VAL_467]], 2
// CHECK:         %[[VAL_476:.*]] = udiv i32 %[[VAL_475]], 1
// CHECK:         %[[VAL_477:.*]] = urem i32 %[[VAL_476]], 200
// CHECK:         %[[VAL_478:.*]] = udiv i32 %[[VAL_475]], 200
// CHECK:         %[[VAL_479:.*]] = add nuw nsw i32 %[[VAL_467]], 3
// CHECK:         %[[VAL_480:.*]] = udiv i32 %[[VAL_479]], 1
// CHECK:         %[[VAL_481:.*]] = urem i32 %[[VAL_480]], 200
// CHECK:         %[[VAL_482:.*]] = udiv i32 %[[VAL_479]], 200
// CHECK:         %[[VAL_483:.*]] = icmp ult i32 %[[VAL_467]], 20000
// CHECK:         br i1 %[[VAL_483]], label %[[VAL_484:.*]], label %[[VAL_485:.*]]
// CHECK:       r10.in_bounds-after:                              ; preds = %[[VAL_484]], %[[VAL_486:.*]]
// CHECK:         ret void
// CHECK:       r10.in_bounds-true:                               ; preds = %[[VAL_486]]
// CHECK:         %[[VAL_487:.*]] = bitcast [100 x [200 x float]]* %[[VAL_458]] to float*
// CHECK:         %[[VAL_488:.*]] = getelementptr inbounds float, float* %[[VAL_487]], i32 %[[VAL_467]]
// CHECK:         %[[VAL_489:.*]] = load float, float* %[[VAL_488]], align 4, !invariant.load !94
// CHECK:         %[[VAL_490:.*]] = call float @llvm.floor.f32(float %[[VAL_489]])
// CHECK:         %[[VAL_491:.*]] = bitcast [100 x [200 x float]]* %[[VAL_461]] to float*
// CHECK:         %[[VAL_492:.*]] = getelementptr inbounds float, float* %[[VAL_491]], i32 %[[VAL_467]]
// CHECK:         store float %[[VAL_490]], float* %[[VAL_492]], align 4
// CHECK:         %[[VAL_493:.*]] = bitcast [100 x [200 x float]]* %[[VAL_458]] to float*
// CHECK:         %[[VAL_494:.*]] = getelementptr inbounds float, float* %[[VAL_493]], i32 %[[VAL_471]]
// CHECK:         %[[VAL_495:.*]] = load float, float* %[[VAL_494]], align 4, !invariant.load !94
// CHECK:         %[[VAL_496:.*]] = call float @llvm.floor.f32(float %[[VAL_495]])
// CHECK:         %[[VAL_497:.*]] = bitcast [100 x [200 x float]]* %[[VAL_461]] to float*
// CHECK:         %[[VAL_498:.*]] = getelementptr inbounds float, float* %[[VAL_497]], i32 %[[VAL_471]]
// CHECK:         store float %[[VAL_496]], float* %[[VAL_498]], align 4
// CHECK:         %[[VAL_499:.*]] = bitcast [100 x [200 x float]]* %[[VAL_458]] to float*
// CHECK:         %[[VAL_500:.*]] = getelementptr inbounds float, float* %[[VAL_499]], i32 %[[VAL_475]]
// CHECK:         %[[VAL_501:.*]] = load float, float* %[[VAL_500]], align 4, !invariant.load !94
// CHECK:         %[[VAL_502:.*]] = call float @llvm.floor.f32(float %[[VAL_501]])
// CHECK:         %[[VAL_503:.*]] = bitcast [100 x [200 x float]]* %[[VAL_461]] to float*
// CHECK:         %[[VAL_504:.*]] = getelementptr inbounds float, float* %[[VAL_503]], i32 %[[VAL_475]]
// CHECK:         store float %[[VAL_502]], float* %[[VAL_504]], align 4
// CHECK:         %[[VAL_505:.*]] = bitcast [100 x [200 x float]]* %[[VAL_458]] to float*
// CHECK:         %[[VAL_506:.*]] = getelementptr inbounds float, float* %[[VAL_505]], i32 %[[VAL_479]]
// CHECK:         %[[VAL_507:.*]] = load float, float* %[[VAL_506]], align 4, !invariant.load !94
// CHECK:         %[[VAL_508:.*]] = call float @llvm.floor.f32(float %[[VAL_507]])
// CHECK:         %[[VAL_509:.*]] = bitcast [100 x [200 x float]]* %[[VAL_461]] to float*
// CHECK:         %[[VAL_510:.*]] = getelementptr inbounds float, float* %[[VAL_509]], i32 %[[VAL_479]]
// CHECK:         store float %[[VAL_508]], float* %[[VAL_510]], align 4
// CHECK:         br label %[[VAL_485]]
// CHECK:       entry:
// CHECK:         %[[VAL_511:.*]] = getelementptr inbounds i8, i8* %[[VAL_512:.*]], i64 0
// CHECK:         %[[VAL_513:.*]] = bitcast i8* %[[VAL_511]] to [100 x [200 x %[[VAL_514:.*]]]]*
// CHECK:         %[[VAL_515:.*]] = getelementptr inbounds i8, i8* %[[VAL_516:.*]], i64 0
// CHECK:         %[[VAL_517:.*]] = bitcast i8* %[[VAL_515]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_518:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_519:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_520:.*]] = mul nuw nsw i32 %[[VAL_518]], 256
// CHECK:         %[[VAL_521:.*]] = add nuw nsw i32 %[[VAL_520]], %[[VAL_519]]
// CHECK:         %[[VAL_522:.*]] = icmp ult i32 %[[VAL_521]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_522]])
// CHECK:         %[[VAL_523:.*]] = mul nuw nsw i32 %[[VAL_521]], 4
// CHECK:         %[[VAL_524:.*]] = udiv i32 %[[VAL_523]], 1
// CHECK:         %[[VAL_525:.*]] = urem i32 %[[VAL_524]], 200
// CHECK:         %[[VAL_526:.*]] = udiv i32 %[[VAL_523]], 200
// CHECK:         %[[VAL_527:.*]] = add nuw nsw i32 %[[VAL_523]], 1
// CHECK:         %[[VAL_528:.*]] = udiv i32 %[[VAL_527]], 1
// CHECK:         %[[VAL_529:.*]] = urem i32 %[[VAL_528]], 200
// CHECK:         %[[VAL_530:.*]] = udiv i32 %[[VAL_527]], 200
// CHECK:         %[[VAL_531:.*]] = add nuw nsw i32 %[[VAL_523]], 2
// CHECK:         %[[VAL_532:.*]] = udiv i32 %[[VAL_531]], 1
// CHECK:         %[[VAL_533:.*]] = urem i32 %[[VAL_532]], 200
// CHECK:         %[[VAL_534:.*]] = udiv i32 %[[VAL_531]], 200
// CHECK:         %[[VAL_535:.*]] = add nuw nsw i32 %[[VAL_523]], 3
// CHECK:         %[[VAL_536:.*]] = udiv i32 %[[VAL_535]], 1
// CHECK:         %[[VAL_537:.*]] = urem i32 %[[VAL_536]], 200
// CHECK:         %[[VAL_538:.*]] = udiv i32 %[[VAL_535]], 200
// CHECK:         %[[VAL_539:.*]] = icmp ult i32 %[[VAL_523]], 20000
// CHECK:         br i1 %[[VAL_539]], label %[[VAL_540:.*]], label %[[VAL_541:.*]]
// CHECK:       r11.in_bounds-after:                              ; preds = %[[VAL_540]], %[[VAL_542:.*]]
// CHECK:         ret void
// CHECK:       r11.in_bounds-true:                               ; preds = %[[VAL_542]]
// CHECK:         %[[VAL_543:.*]] = bitcast [100 x [200 x %[[VAL_514]]]]* %[[VAL_513]] to %[[VAL_514]]*
// CHECK:         %[[VAL_544:.*]] = getelementptr inbounds %[[VAL_514]], %[[VAL_514]]* %[[VAL_543]], i32 %[[VAL_523]]
// CHECK:         %[[VAL_545:.*]] = load %[[VAL_514]], %[[VAL_514]]* %[[VAL_544]], align 1, !invariant.load !94
// CHECK:         %[[VAL_546:.*]] = extractvalue %[[VAL_514]] %[[VAL_545]], 1
// CHECK:         %[[VAL_547:.*]] = bitcast [100 x [200 x float]]* %[[VAL_517]] to float*
// CHECK:         %[[VAL_548:.*]] = getelementptr inbounds float, float* %[[VAL_547]], i32 %[[VAL_523]]
// CHECK:         store float %[[VAL_546]], float* %[[VAL_548]], align 4
// CHECK:         %[[VAL_549:.*]] = bitcast [100 x [200 x %[[VAL_514]]]]* %[[VAL_513]] to %[[VAL_514]]*
// CHECK:         %[[VAL_550:.*]] = getelementptr inbounds %[[VAL_514]], %[[VAL_514]]* %[[VAL_549]], i32 %[[VAL_527]]
// CHECK:         %[[VAL_551:.*]] = load %[[VAL_514]], %[[VAL_514]]* %[[VAL_550]], align 1, !invariant.load !94
// CHECK:         %[[VAL_552:.*]] = extractvalue %[[VAL_514]] %[[VAL_551]], 1
// CHECK:         %[[VAL_553:.*]] = bitcast [100 x [200 x float]]* %[[VAL_517]] to float*
// CHECK:         %[[VAL_554:.*]] = getelementptr inbounds float, float* %[[VAL_553]], i32 %[[VAL_527]]
// CHECK:         store float %[[VAL_552]], float* %[[VAL_554]], align 4
// CHECK:         %[[VAL_555:.*]] = bitcast [100 x [200 x %[[VAL_514]]]]* %[[VAL_513]] to %[[VAL_514]]*
// CHECK:         %[[VAL_556:.*]] = getelementptr inbounds %[[VAL_514]], %[[VAL_514]]* %[[VAL_555]], i32 %[[VAL_531]]
// CHECK:         %[[VAL_557:.*]] = load %[[VAL_514]], %[[VAL_514]]* %[[VAL_556]], align 1, !invariant.load !94
// CHECK:         %[[VAL_558:.*]] = extractvalue %[[VAL_514]] %[[VAL_557]], 1
// CHECK:         %[[VAL_559:.*]] = bitcast [100 x [200 x float]]* %[[VAL_517]] to float*
// CHECK:         %[[VAL_560:.*]] = getelementptr inbounds float, float* %[[VAL_559]], i32 %[[VAL_531]]
// CHECK:         store float %[[VAL_558]], float* %[[VAL_560]], align 4
// CHECK:         %[[VAL_561:.*]] = bitcast [100 x [200 x %[[VAL_514]]]]* %[[VAL_513]] to %[[VAL_514]]*
// CHECK:         %[[VAL_562:.*]] = getelementptr inbounds %[[VAL_514]], %[[VAL_514]]* %[[VAL_561]], i32 %[[VAL_535]]
// CHECK:         %[[VAL_563:.*]] = load %[[VAL_514]], %[[VAL_514]]* %[[VAL_562]], align 1, !invariant.load !94
// CHECK:         %[[VAL_564:.*]] = extractvalue %[[VAL_514]] %[[VAL_563]], 1
// CHECK:         %[[VAL_565:.*]] = bitcast [100 x [200 x float]]* %[[VAL_517]] to float*
// CHECK:         %[[VAL_566:.*]] = getelementptr inbounds float, float* %[[VAL_565]], i32 %[[VAL_535]]
// CHECK:         store float %[[VAL_564]], float* %[[VAL_566]], align 4
// CHECK:         br label %[[VAL_541]]
// CHECK:       entry:
// CHECK:         %[[VAL_567:.*]] = getelementptr inbounds i8, i8* %[[VAL_568:.*]], i64 0
// CHECK:         %[[VAL_569:.*]] = bitcast i8* %[[VAL_567]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_570:.*]] = getelementptr inbounds i8, i8* %[[VAL_571:.*]], i64 0
// CHECK:         %[[VAL_572:.*]] = bitcast i8* %[[VAL_570]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_573:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_574:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_575:.*]] = mul nuw nsw i32 %[[VAL_573]], 256
// CHECK:         %[[VAL_576:.*]] = add nuw nsw i32 %[[VAL_575]], %[[VAL_574]]
// CHECK:         %[[VAL_577:.*]] = icmp ult i32 %[[VAL_576]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_577]])
// CHECK:         %[[VAL_578:.*]] = mul nuw nsw i32 %[[VAL_576]], 4
// CHECK:         %[[VAL_579:.*]] = udiv i32 %[[VAL_578]], 1
// CHECK:         %[[VAL_580:.*]] = urem i32 %[[VAL_579]], 200
// CHECK:         %[[VAL_581:.*]] = udiv i32 %[[VAL_578]], 200
// CHECK:         %[[VAL_582:.*]] = add nuw nsw i32 %[[VAL_578]], 1
// CHECK:         %[[VAL_583:.*]] = udiv i32 %[[VAL_582]], 1
// CHECK:         %[[VAL_584:.*]] = urem i32 %[[VAL_583]], 200
// CHECK:         %[[VAL_585:.*]] = udiv i32 %[[VAL_582]], 200
// CHECK:         %[[VAL_586:.*]] = add nuw nsw i32 %[[VAL_578]], 2
// CHECK:         %[[VAL_587:.*]] = udiv i32 %[[VAL_586]], 1
// CHECK:         %[[VAL_588:.*]] = urem i32 %[[VAL_587]], 200
// CHECK:         %[[VAL_589:.*]] = udiv i32 %[[VAL_586]], 200
// CHECK:         %[[VAL_590:.*]] = add nuw nsw i32 %[[VAL_578]], 3
// CHECK:         %[[VAL_591:.*]] = udiv i32 %[[VAL_590]], 1
// CHECK:         %[[VAL_592:.*]] = urem i32 %[[VAL_591]], 200
// CHECK:         %[[VAL_593:.*]] = udiv i32 %[[VAL_590]], 200
// CHECK:         %[[VAL_594:.*]] = icmp ult i32 %[[VAL_578]], 20000
// CHECK:         br i1 %[[VAL_594]], label %[[VAL_595:.*]], label %[[VAL_596:.*]]
// CHECK:       r12.in_bounds-after:                              ; preds = %[[VAL_595]], %[[VAL_597:.*]]
// CHECK:         ret void
// CHECK:       r12.in_bounds-true:                               ; preds = %[[VAL_597]]
// CHECK:         %[[VAL_598:.*]] = bitcast [100 x [200 x float]]* %[[VAL_569]] to float*
// CHECK:         %[[VAL_599:.*]] = getelementptr inbounds float, float* %[[VAL_598]], i32 %[[VAL_578]]
// CHECK:         %[[VAL_600:.*]] = load float, float* %[[VAL_599]], align 4, !invariant.load !94
// CHECK:         %[[VAL_601:.*]] = call float @llvm.fabs.f32(float %[[VAL_600]])
// CHECK:         %[[VAL_602:.*]] = fcmp one float %[[VAL_601]], 0x7FF0000000000000
// CHECK:         %[[VAL_603:.*]] = zext i1 %[[VAL_602]] to i8
// CHECK:         %[[VAL_604:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_572]] to i8*
// CHECK:         %[[VAL_605:.*]] = getelementptr inbounds i8, i8* %[[VAL_604]], i32 %[[VAL_578]]
// CHECK:         store i8 %[[VAL_603]], i8* %[[VAL_605]], align 1
// CHECK:         %[[VAL_606:.*]] = bitcast [100 x [200 x float]]* %[[VAL_569]] to float*
// CHECK:         %[[VAL_607:.*]] = getelementptr inbounds float, float* %[[VAL_606]], i32 %[[VAL_582]]
// CHECK:         %[[VAL_608:.*]] = load float, float* %[[VAL_607]], align 4, !invariant.load !94
// CHECK:         %[[VAL_609:.*]] = call float @llvm.fabs.f32(float %[[VAL_608]])
// CHECK:         %[[VAL_610:.*]] = fcmp one float %[[VAL_609]], 0x7FF0000000000000
// CHECK:         %[[VAL_611:.*]] = zext i1 %[[VAL_610]] to i8
// CHECK:         %[[VAL_612:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_572]] to i8*
// CHECK:         %[[VAL_613:.*]] = getelementptr inbounds i8, i8* %[[VAL_612]], i32 %[[VAL_582]]
// CHECK:         store i8 %[[VAL_611]], i8* %[[VAL_613]], align 1
// CHECK:         %[[VAL_614:.*]] = bitcast [100 x [200 x float]]* %[[VAL_569]] to float*
// CHECK:         %[[VAL_615:.*]] = getelementptr inbounds float, float* %[[VAL_614]], i32 %[[VAL_586]]
// CHECK:         %[[VAL_616:.*]] = load float, float* %[[VAL_615]], align 4, !invariant.load !94
// CHECK:         %[[VAL_617:.*]] = call float @llvm.fabs.f32(float %[[VAL_616]])
// CHECK:         %[[VAL_618:.*]] = fcmp one float %[[VAL_617]], 0x7FF0000000000000
// CHECK:         %[[VAL_619:.*]] = zext i1 %[[VAL_618]] to i8
// CHECK:         %[[VAL_620:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_572]] to i8*
// CHECK:         %[[VAL_621:.*]] = getelementptr inbounds i8, i8* %[[VAL_620]], i32 %[[VAL_586]]
// CHECK:         store i8 %[[VAL_619]], i8* %[[VAL_621]], align 1
// CHECK:         %[[VAL_622:.*]] = bitcast [100 x [200 x float]]* %[[VAL_569]] to float*
// CHECK:         %[[VAL_623:.*]] = getelementptr inbounds float, float* %[[VAL_622]], i32 %[[VAL_590]]
// CHECK:         %[[VAL_624:.*]] = load float, float* %[[VAL_623]], align 4, !invariant.load !94
// CHECK:         %[[VAL_625:.*]] = call float @llvm.fabs.f32(float %[[VAL_624]])
// CHECK:         %[[VAL_626:.*]] = fcmp one float %[[VAL_625]], 0x7FF0000000000000
// CHECK:         %[[VAL_627:.*]] = zext i1 %[[VAL_626]] to i8
// CHECK:         %[[VAL_628:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_572]] to i8*
// CHECK:         %[[VAL_629:.*]] = getelementptr inbounds i8, i8* %[[VAL_628]], i32 %[[VAL_590]]
// CHECK:         store i8 %[[VAL_627]], i8* %[[VAL_629]], align 1
// CHECK:         br label %[[VAL_596]]
// CHECK:       entry:
// CHECK:         %[[VAL_630:.*]] = getelementptr inbounds i8, i8* %[[VAL_631:.*]], i64 0
// CHECK:         %[[VAL_632:.*]] = bitcast i8* %[[VAL_630]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_633:.*]] = getelementptr inbounds i8, i8* %[[VAL_634:.*]], i64 0
// CHECK:         %[[VAL_635:.*]] = bitcast i8* %[[VAL_633]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_636:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_637:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_638:.*]] = mul nuw nsw i32 %[[VAL_636]], 256
// CHECK:         %[[VAL_639:.*]] = add nuw nsw i32 %[[VAL_638]], %[[VAL_637]]
// CHECK:         %[[VAL_640:.*]] = icmp ult i32 %[[VAL_639]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_640]])
// CHECK:         %[[VAL_641:.*]] = mul nuw nsw i32 %[[VAL_639]], 4
// CHECK:         %[[VAL_642:.*]] = udiv i32 %[[VAL_641]], 1
// CHECK:         %[[VAL_643:.*]] = urem i32 %[[VAL_642]], 200
// CHECK:         %[[VAL_644:.*]] = udiv i32 %[[VAL_641]], 200
// CHECK:         %[[VAL_645:.*]] = add nuw nsw i32 %[[VAL_641]], 1
// CHECK:         %[[VAL_646:.*]] = udiv i32 %[[VAL_645]], 1
// CHECK:         %[[VAL_647:.*]] = urem i32 %[[VAL_646]], 200
// CHECK:         %[[VAL_648:.*]] = udiv i32 %[[VAL_645]], 200
// CHECK:         %[[VAL_649:.*]] = add nuw nsw i32 %[[VAL_641]], 2
// CHECK:         %[[VAL_650:.*]] = udiv i32 %[[VAL_649]], 1
// CHECK:         %[[VAL_651:.*]] = urem i32 %[[VAL_650]], 200
// CHECK:         %[[VAL_652:.*]] = udiv i32 %[[VAL_649]], 200
// CHECK:         %[[VAL_653:.*]] = add nuw nsw i32 %[[VAL_641]], 3
// CHECK:         %[[VAL_654:.*]] = udiv i32 %[[VAL_653]], 1
// CHECK:         %[[VAL_655:.*]] = urem i32 %[[VAL_654]], 200
// CHECK:         %[[VAL_656:.*]] = udiv i32 %[[VAL_653]], 200
// CHECK:         %[[VAL_657:.*]] = icmp ult i32 %[[VAL_641]], 20000
// CHECK:         br i1 %[[VAL_657]], label %[[VAL_658:.*]], label %[[VAL_659:.*]]
// CHECK:       r13.in_bounds-after:                              ; preds = %[[VAL_658]], %[[VAL_660:.*]]
// CHECK:         ret void
// CHECK:       r13.in_bounds-true:                               ; preds = %[[VAL_660]]
// CHECK:         %[[VAL_661:.*]] = bitcast [100 x [200 x float]]* %[[VAL_632]] to float*
// CHECK:         %[[VAL_662:.*]] = getelementptr inbounds float, float* %[[VAL_661]], i32 %[[VAL_641]]
// CHECK:         %[[VAL_663:.*]] = load float, float* %[[VAL_662]], align 4, !invariant.load !94
// CHECK:         %[[VAL_664:.*]] = call float @__nv_logf(float %[[VAL_663]])
// CHECK:         %[[VAL_665:.*]] = bitcast [100 x [200 x float]]* %[[VAL_635]] to float*
// CHECK:         %[[VAL_666:.*]] = getelementptr inbounds float, float* %[[VAL_665]], i32 %[[VAL_641]]
// CHECK:         store float %[[VAL_664]], float* %[[VAL_666]], align 4
// CHECK:         %[[VAL_667:.*]] = bitcast [100 x [200 x float]]* %[[VAL_632]] to float*
// CHECK:         %[[VAL_668:.*]] = getelementptr inbounds float, float* %[[VAL_667]], i32 %[[VAL_645]]
// CHECK:         %[[VAL_669:.*]] = load float, float* %[[VAL_668]], align 4, !invariant.load !94
// CHECK:         %[[VAL_670:.*]] = call float @__nv_logf(float %[[VAL_669]])
// CHECK:         %[[VAL_671:.*]] = bitcast [100 x [200 x float]]* %[[VAL_635]] to float*
// CHECK:         %[[VAL_672:.*]] = getelementptr inbounds float, float* %[[VAL_671]], i32 %[[VAL_645]]
// CHECK:         store float %[[VAL_670]], float* %[[VAL_672]], align 4
// CHECK:         %[[VAL_673:.*]] = bitcast [100 x [200 x float]]* %[[VAL_632]] to float*
// CHECK:         %[[VAL_674:.*]] = getelementptr inbounds float, float* %[[VAL_673]], i32 %[[VAL_649]]
// CHECK:         %[[VAL_675:.*]] = load float, float* %[[VAL_674]], align 4, !invariant.load !94
// CHECK:         %[[VAL_676:.*]] = call float @__nv_logf(float %[[VAL_675]])
// CHECK:         %[[VAL_677:.*]] = bitcast [100 x [200 x float]]* %[[VAL_635]] to float*
// CHECK:         %[[VAL_678:.*]] = getelementptr inbounds float, float* %[[VAL_677]], i32 %[[VAL_649]]
// CHECK:         store float %[[VAL_676]], float* %[[VAL_678]], align 4
// CHECK:         %[[VAL_679:.*]] = bitcast [100 x [200 x float]]* %[[VAL_632]] to float*
// CHECK:         %[[VAL_680:.*]] = getelementptr inbounds float, float* %[[VAL_679]], i32 %[[VAL_653]]
// CHECK:         %[[VAL_681:.*]] = load float, float* %[[VAL_680]], align 4, !invariant.load !94
// CHECK:         %[[VAL_682:.*]] = call float @__nv_logf(float %[[VAL_681]])
// CHECK:         %[[VAL_683:.*]] = bitcast [100 x [200 x float]]* %[[VAL_635]] to float*
// CHECK:         %[[VAL_684:.*]] = getelementptr inbounds float, float* %[[VAL_683]], i32 %[[VAL_653]]
// CHECK:         store float %[[VAL_682]], float* %[[VAL_684]], align 4
// CHECK:         br label %[[VAL_659]]
// CHECK:       entry:
// CHECK:         %[[VAL_685:.*]] = getelementptr inbounds i8, i8* %[[VAL_686:.*]], i64 0
// CHECK:         %[[VAL_687:.*]] = bitcast i8* %[[VAL_685]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_688:.*]] = getelementptr inbounds i8, i8* %[[VAL_689:.*]], i64 0
// CHECK:         %[[VAL_690:.*]] = bitcast i8* %[[VAL_688]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_691:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_692:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_693:.*]] = mul nuw nsw i32 %[[VAL_691]], 256
// CHECK:         %[[VAL_694:.*]] = add nuw nsw i32 %[[VAL_693]], %[[VAL_692]]
// CHECK:         %[[VAL_695:.*]] = icmp ult i32 %[[VAL_694]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_695]])
// CHECK:         %[[VAL_696:.*]] = mul nuw nsw i32 %[[VAL_694]], 4
// CHECK:         %[[VAL_697:.*]] = udiv i32 %[[VAL_696]], 1
// CHECK:         %[[VAL_698:.*]] = urem i32 %[[VAL_697]], 200
// CHECK:         %[[VAL_699:.*]] = udiv i32 %[[VAL_696]], 200
// CHECK:         %[[VAL_700:.*]] = add nuw nsw i32 %[[VAL_696]], 1
// CHECK:         %[[VAL_701:.*]] = udiv i32 %[[VAL_700]], 1
// CHECK:         %[[VAL_702:.*]] = urem i32 %[[VAL_701]], 200
// CHECK:         %[[VAL_703:.*]] = udiv i32 %[[VAL_700]], 200
// CHECK:         %[[VAL_704:.*]] = add nuw nsw i32 %[[VAL_696]], 2
// CHECK:         %[[VAL_705:.*]] = udiv i32 %[[VAL_704]], 1
// CHECK:         %[[VAL_706:.*]] = urem i32 %[[VAL_705]], 200
// CHECK:         %[[VAL_707:.*]] = udiv i32 %[[VAL_704]], 200
// CHECK:         %[[VAL_708:.*]] = add nuw nsw i32 %[[VAL_696]], 3
// CHECK:         %[[VAL_709:.*]] = udiv i32 %[[VAL_708]], 1
// CHECK:         %[[VAL_710:.*]] = urem i32 %[[VAL_709]], 200
// CHECK:         %[[VAL_711:.*]] = udiv i32 %[[VAL_708]], 200
// CHECK:         %[[VAL_712:.*]] = icmp ult i32 %[[VAL_696]], 20000
// CHECK:         br i1 %[[VAL_712]], label %[[VAL_713:.*]], label %[[VAL_714:.*]]
// CHECK:       r14.in_bounds-after:                              ; preds = %[[VAL_713]], %[[VAL_715:.*]]
// CHECK:         ret void
// CHECK:       r14.in_bounds-true:                               ; preds = %[[VAL_715]]
// CHECK:         %[[VAL_716:.*]] = bitcast [100 x [200 x float]]* %[[VAL_687]] to float*
// CHECK:         %[[VAL_717:.*]] = getelementptr inbounds float, float* %[[VAL_716]], i32 %[[VAL_696]]
// CHECK:         %[[VAL_718:.*]] = load float, float* %[[VAL_717]], align 4, !invariant.load !94
// CHECK:         %[[VAL_719:.*]] = call float @__nv_log1pf(float %[[VAL_718]])
// CHECK:         %[[VAL_720:.*]] = bitcast [100 x [200 x float]]* %[[VAL_690]] to float*
// CHECK:         %[[VAL_721:.*]] = getelementptr inbounds float, float* %[[VAL_720]], i32 %[[VAL_696]]
// CHECK:         store float %[[VAL_719]], float* %[[VAL_721]], align 4
// CHECK:         %[[VAL_722:.*]] = bitcast [100 x [200 x float]]* %[[VAL_687]] to float*
// CHECK:         %[[VAL_723:.*]] = getelementptr inbounds float, float* %[[VAL_722]], i32 %[[VAL_700]]
// CHECK:         %[[VAL_724:.*]] = load float, float* %[[VAL_723]], align 4, !invariant.load !94
// CHECK:         %[[VAL_725:.*]] = call float @__nv_log1pf(float %[[VAL_724]])
// CHECK:         %[[VAL_726:.*]] = bitcast [100 x [200 x float]]* %[[VAL_690]] to float*
// CHECK:         %[[VAL_727:.*]] = getelementptr inbounds float, float* %[[VAL_726]], i32 %[[VAL_700]]
// CHECK:         store float %[[VAL_725]], float* %[[VAL_727]], align 4
// CHECK:         %[[VAL_728:.*]] = bitcast [100 x [200 x float]]* %[[VAL_687]] to float*
// CHECK:         %[[VAL_729:.*]] = getelementptr inbounds float, float* %[[VAL_728]], i32 %[[VAL_704]]
// CHECK:         %[[VAL_730:.*]] = load float, float* %[[VAL_729]], align 4, !invariant.load !94
// CHECK:         %[[VAL_731:.*]] = call float @__nv_log1pf(float %[[VAL_730]])
// CHECK:         %[[VAL_732:.*]] = bitcast [100 x [200 x float]]* %[[VAL_690]] to float*
// CHECK:         %[[VAL_733:.*]] = getelementptr inbounds float, float* %[[VAL_732]], i32 %[[VAL_704]]
// CHECK:         store float %[[VAL_731]], float* %[[VAL_733]], align 4
// CHECK:         %[[VAL_734:.*]] = bitcast [100 x [200 x float]]* %[[VAL_687]] to float*
// CHECK:         %[[VAL_735:.*]] = getelementptr inbounds float, float* %[[VAL_734]], i32 %[[VAL_708]]
// CHECK:         %[[VAL_736:.*]] = load float, float* %[[VAL_735]], align 4, !invariant.load !94
// CHECK:         %[[VAL_737:.*]] = call float @__nv_log1pf(float %[[VAL_736]])
// CHECK:         %[[VAL_738:.*]] = bitcast [100 x [200 x float]]* %[[VAL_690]] to float*
// CHECK:         %[[VAL_739:.*]] = getelementptr inbounds float, float* %[[VAL_738]], i32 %[[VAL_708]]
// CHECK:         store float %[[VAL_737]], float* %[[VAL_739]], align 4
// CHECK:         br label %[[VAL_714]]
// CHECK:       entry:
// CHECK:         %[[VAL_740:.*]] = getelementptr inbounds i8, i8* %[[VAL_741:.*]], i64 0
// CHECK:         %[[VAL_742:.*]] = bitcast i8* %[[VAL_740]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_743:.*]] = getelementptr inbounds i8, i8* %[[VAL_744:.*]], i64 0
// CHECK:         %[[VAL_745:.*]] = bitcast i8* %[[VAL_743]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_746:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_747:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_748:.*]] = mul nuw nsw i32 %[[VAL_746]], 256
// CHECK:         %[[VAL_749:.*]] = add nuw nsw i32 %[[VAL_748]], %[[VAL_747]]
// CHECK:         %[[VAL_750:.*]] = icmp ult i32 %[[VAL_749]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_750]])
// CHECK:         %[[VAL_751:.*]] = mul nuw nsw i32 %[[VAL_749]], 4
// CHECK:         %[[VAL_752:.*]] = udiv i32 %[[VAL_751]], 1
// CHECK:         %[[VAL_753:.*]] = urem i32 %[[VAL_752]], 200
// CHECK:         %[[VAL_754:.*]] = udiv i32 %[[VAL_751]], 200
// CHECK:         %[[VAL_755:.*]] = add nuw nsw i32 %[[VAL_751]], 1
// CHECK:         %[[VAL_756:.*]] = udiv i32 %[[VAL_755]], 1
// CHECK:         %[[VAL_757:.*]] = urem i32 %[[VAL_756]], 200
// CHECK:         %[[VAL_758:.*]] = udiv i32 %[[VAL_755]], 200
// CHECK:         %[[VAL_759:.*]] = add nuw nsw i32 %[[VAL_751]], 2
// CHECK:         %[[VAL_760:.*]] = udiv i32 %[[VAL_759]], 1
// CHECK:         %[[VAL_761:.*]] = urem i32 %[[VAL_760]], 200
// CHECK:         %[[VAL_762:.*]] = udiv i32 %[[VAL_759]], 200
// CHECK:         %[[VAL_763:.*]] = add nuw nsw i32 %[[VAL_751]], 3
// CHECK:         %[[VAL_764:.*]] = udiv i32 %[[VAL_763]], 1
// CHECK:         %[[VAL_765:.*]] = urem i32 %[[VAL_764]], 200
// CHECK:         %[[VAL_766:.*]] = udiv i32 %[[VAL_763]], 200
// CHECK:         %[[VAL_767:.*]] = icmp ult i32 %[[VAL_751]], 20000
// CHECK:         br i1 %[[VAL_767]], label %[[VAL_768:.*]], label %[[VAL_769:.*]]
// CHECK:       r15.in_bounds-after:                              ; preds = %[[VAL_768]], %[[VAL_770:.*]]
// CHECK:         ret void
// CHECK:       r15.in_bounds-true:                               ; preds = %[[VAL_770]]
// CHECK:         %[[VAL_771:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_742]] to i8*
// CHECK:         %[[VAL_772:.*]] = getelementptr inbounds i8, i8* %[[VAL_771]], i32 %[[VAL_751]]
// CHECK:         %[[VAL_773:.*]] = load i8, i8* %[[VAL_772]], align 1, !invariant.load !94
// CHECK:         %[[VAL_774:.*]] = trunc i8 %[[VAL_773]] to i1
// CHECK:         %[[VAL_775:.*]] = xor i1 %[[VAL_774]], true
// CHECK:         %[[VAL_776:.*]] = zext i1 %[[VAL_775]] to i8
// CHECK:         %[[VAL_777:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_745]] to i8*
// CHECK:         %[[VAL_778:.*]] = getelementptr inbounds i8, i8* %[[VAL_777]], i32 %[[VAL_751]]
// CHECK:         store i8 %[[VAL_776]], i8* %[[VAL_778]], align 1
// CHECK:         %[[VAL_779:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_742]] to i8*
// CHECK:         %[[VAL_780:.*]] = getelementptr inbounds i8, i8* %[[VAL_779]], i32 %[[VAL_755]]
// CHECK:         %[[VAL_781:.*]] = load i8, i8* %[[VAL_780]], align 1, !invariant.load !94
// CHECK:         %[[VAL_782:.*]] = trunc i8 %[[VAL_781]] to i1
// CHECK:         %[[VAL_783:.*]] = xor i1 %[[VAL_782]], true
// CHECK:         %[[VAL_784:.*]] = zext i1 %[[VAL_783]] to i8
// CHECK:         %[[VAL_785:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_745]] to i8*
// CHECK:         %[[VAL_786:.*]] = getelementptr inbounds i8, i8* %[[VAL_785]], i32 %[[VAL_755]]
// CHECK:         store i8 %[[VAL_784]], i8* %[[VAL_786]], align 1
// CHECK:         %[[VAL_787:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_742]] to i8*
// CHECK:         %[[VAL_788:.*]] = getelementptr inbounds i8, i8* %[[VAL_787]], i32 %[[VAL_759]]
// CHECK:         %[[VAL_789:.*]] = load i8, i8* %[[VAL_788]], align 1, !invariant.load !94
// CHECK:         %[[VAL_790:.*]] = trunc i8 %[[VAL_789]] to i1
// CHECK:         %[[VAL_791:.*]] = xor i1 %[[VAL_790]], true
// CHECK:         %[[VAL_792:.*]] = zext i1 %[[VAL_791]] to i8
// CHECK:         %[[VAL_793:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_745]] to i8*
// CHECK:         %[[VAL_794:.*]] = getelementptr inbounds i8, i8* %[[VAL_793]], i32 %[[VAL_759]]
// CHECK:         store i8 %[[VAL_792]], i8* %[[VAL_794]], align 1
// CHECK:         %[[VAL_795:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_742]] to i8*
// CHECK:         %[[VAL_796:.*]] = getelementptr inbounds i8, i8* %[[VAL_795]], i32 %[[VAL_763]]
// CHECK:         %[[VAL_797:.*]] = load i8, i8* %[[VAL_796]], align 1, !invariant.load !94
// CHECK:         %[[VAL_798:.*]] = trunc i8 %[[VAL_797]] to i1
// CHECK:         %[[VAL_799:.*]] = xor i1 %[[VAL_798]], true
// CHECK:         %[[VAL_800:.*]] = zext i1 %[[VAL_799]] to i8
// CHECK:         %[[VAL_801:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_745]] to i8*
// CHECK:         %[[VAL_802:.*]] = getelementptr inbounds i8, i8* %[[VAL_801]], i32 %[[VAL_763]]
// CHECK:         store i8 %[[VAL_800]], i8* %[[VAL_802]], align 1
// CHECK:         br label %[[VAL_769]]
// CHECK:       entry:
// CHECK:         %[[VAL_803:.*]] = getelementptr inbounds i8, i8* %[[VAL_804:.*]], i64 0
// CHECK:         %[[VAL_805:.*]] = bitcast i8* %[[VAL_803]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_806:.*]] = getelementptr inbounds i8, i8* %[[VAL_807:.*]], i64 0
// CHECK:         %[[VAL_808:.*]] = bitcast i8* %[[VAL_806]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_809:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_810:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_811:.*]] = mul nuw nsw i32 %[[VAL_809]], 256
// CHECK:         %[[VAL_812:.*]] = add nuw nsw i32 %[[VAL_811]], %[[VAL_810]]
// CHECK:         %[[VAL_813:.*]] = icmp ult i32 %[[VAL_812]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_813]])
// CHECK:         %[[VAL_814:.*]] = mul nuw nsw i32 %[[VAL_812]], 4
// CHECK:         %[[VAL_815:.*]] = udiv i32 %[[VAL_814]], 1
// CHECK:         %[[VAL_816:.*]] = urem i32 %[[VAL_815]], 200
// CHECK:         %[[VAL_817:.*]] = udiv i32 %[[VAL_814]], 200
// CHECK:         %[[VAL_818:.*]] = add nuw nsw i32 %[[VAL_814]], 1
// CHECK:         %[[VAL_819:.*]] = udiv i32 %[[VAL_818]], 1
// CHECK:         %[[VAL_820:.*]] = urem i32 %[[VAL_819]], 200
// CHECK:         %[[VAL_821:.*]] = udiv i32 %[[VAL_818]], 200
// CHECK:         %[[VAL_822:.*]] = add nuw nsw i32 %[[VAL_814]], 2
// CHECK:         %[[VAL_823:.*]] = udiv i32 %[[VAL_822]], 1
// CHECK:         %[[VAL_824:.*]] = urem i32 %[[VAL_823]], 200
// CHECK:         %[[VAL_825:.*]] = udiv i32 %[[VAL_822]], 200
// CHECK:         %[[VAL_826:.*]] = add nuw nsw i32 %[[VAL_814]], 3
// CHECK:         %[[VAL_827:.*]] = udiv i32 %[[VAL_826]], 1
// CHECK:         %[[VAL_828:.*]] = urem i32 %[[VAL_827]], 200
// CHECK:         %[[VAL_829:.*]] = udiv i32 %[[VAL_826]], 200
// CHECK:         %[[VAL_830:.*]] = icmp ult i32 %[[VAL_814]], 20000
// CHECK:         br i1 %[[VAL_830]], label %[[VAL_831:.*]], label %[[VAL_832:.*]]
// CHECK:       r16.in_bounds-after:                              ; preds = %[[VAL_831]], %[[VAL_833:.*]]
// CHECK:         ret void
// CHECK:       r16.in_bounds-true:                               ; preds = %[[VAL_833]]
// CHECK:         %[[VAL_834:.*]] = bitcast [100 x [200 x float]]* %[[VAL_805]] to float*
// CHECK:         %[[VAL_835:.*]] = getelementptr inbounds float, float* %[[VAL_834]], i32 %[[VAL_814]]
// CHECK:         %[[VAL_836:.*]] = load float, float* %[[VAL_835]], align 4, !invariant.load !94
// CHECK:         %[[VAL_837:.*]] = fneg float %[[VAL_836]]
// CHECK:         %[[VAL_838:.*]] = bitcast [100 x [200 x float]]* %[[VAL_808]] to float*
// CHECK:         %[[VAL_839:.*]] = getelementptr inbounds float, float* %[[VAL_838]], i32 %[[VAL_814]]
// CHECK:         store float %[[VAL_837]], float* %[[VAL_839]], align 4
// CHECK:         %[[VAL_840:.*]] = bitcast [100 x [200 x float]]* %[[VAL_805]] to float*
// CHECK:         %[[VAL_841:.*]] = getelementptr inbounds float, float* %[[VAL_840]], i32 %[[VAL_818]]
// CHECK:         %[[VAL_842:.*]] = load float, float* %[[VAL_841]], align 4, !invariant.load !94
// CHECK:         %[[VAL_843:.*]] = fneg float %[[VAL_842]]
// CHECK:         %[[VAL_844:.*]] = bitcast [100 x [200 x float]]* %[[VAL_808]] to float*
// CHECK:         %[[VAL_845:.*]] = getelementptr inbounds float, float* %[[VAL_844]], i32 %[[VAL_818]]
// CHECK:         store float %[[VAL_843]], float* %[[VAL_845]], align 4
// CHECK:         %[[VAL_846:.*]] = bitcast [100 x [200 x float]]* %[[VAL_805]] to float*
// CHECK:         %[[VAL_847:.*]] = getelementptr inbounds float, float* %[[VAL_846]], i32 %[[VAL_822]]
// CHECK:         %[[VAL_848:.*]] = load float, float* %[[VAL_847]], align 4, !invariant.load !94
// CHECK:         %[[VAL_849:.*]] = fneg float %[[VAL_848]]
// CHECK:         %[[VAL_850:.*]] = bitcast [100 x [200 x float]]* %[[VAL_808]] to float*
// CHECK:         %[[VAL_851:.*]] = getelementptr inbounds float, float* %[[VAL_850]], i32 %[[VAL_822]]
// CHECK:         store float %[[VAL_849]], float* %[[VAL_851]], align 4
// CHECK:         %[[VAL_852:.*]] = bitcast [100 x [200 x float]]* %[[VAL_805]] to float*
// CHECK:         %[[VAL_853:.*]] = getelementptr inbounds float, float* %[[VAL_852]], i32 %[[VAL_826]]
// CHECK:         %[[VAL_854:.*]] = load float, float* %[[VAL_853]], align 4, !invariant.load !94
// CHECK:         %[[VAL_855:.*]] = fneg float %[[VAL_854]]
// CHECK:         %[[VAL_856:.*]] = bitcast [100 x [200 x float]]* %[[VAL_808]] to float*
// CHECK:         %[[VAL_857:.*]] = getelementptr inbounds float, float* %[[VAL_856]], i32 %[[VAL_826]]
// CHECK:         store float %[[VAL_855]], float* %[[VAL_857]], align 4
// CHECK:         br label %[[VAL_832]]
// CHECK:       entry:
// CHECK:         %[[VAL_858:.*]] = getelementptr inbounds i8, i8* %[[VAL_859:.*]], i64 0
// CHECK:         %[[VAL_860:.*]] = bitcast i8* %[[VAL_858]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_861:.*]] = getelementptr inbounds i8, i8* %[[VAL_862:.*]], i64 0
// CHECK:         %[[VAL_863:.*]] = bitcast i8* %[[VAL_861]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_864:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_865:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_866:.*]] = mul nuw nsw i32 %[[VAL_864]], 256
// CHECK:         %[[VAL_867:.*]] = add nuw nsw i32 %[[VAL_866]], %[[VAL_865]]
// CHECK:         %[[VAL_868:.*]] = icmp ult i32 %[[VAL_867]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_868]])
// CHECK:         %[[VAL_869:.*]] = mul nuw nsw i32 %[[VAL_867]], 4
// CHECK:         %[[VAL_870:.*]] = udiv i32 %[[VAL_869]], 1
// CHECK:         %[[VAL_871:.*]] = urem i32 %[[VAL_870]], 200
// CHECK:         %[[VAL_872:.*]] = udiv i32 %[[VAL_869]], 200
// CHECK:         %[[VAL_873:.*]] = add nuw nsw i32 %[[VAL_869]], 1
// CHECK:         %[[VAL_874:.*]] = udiv i32 %[[VAL_873]], 1
// CHECK:         %[[VAL_875:.*]] = urem i32 %[[VAL_874]], 200
// CHECK:         %[[VAL_876:.*]] = udiv i32 %[[VAL_873]], 200
// CHECK:         %[[VAL_877:.*]] = add nuw nsw i32 %[[VAL_869]], 2
// CHECK:         %[[VAL_878:.*]] = udiv i32 %[[VAL_877]], 1
// CHECK:         %[[VAL_879:.*]] = urem i32 %[[VAL_878]], 200
// CHECK:         %[[VAL_880:.*]] = udiv i32 %[[VAL_877]], 200
// CHECK:         %[[VAL_881:.*]] = add nuw nsw i32 %[[VAL_869]], 3
// CHECK:         %[[VAL_882:.*]] = udiv i32 %[[VAL_881]], 1
// CHECK:         %[[VAL_883:.*]] = urem i32 %[[VAL_882]], 200
// CHECK:         %[[VAL_884:.*]] = udiv i32 %[[VAL_881]], 200
// CHECK:         %[[VAL_885:.*]] = icmp ult i32 %[[VAL_869]], 20000
// CHECK:         br i1 %[[VAL_885]], label %[[VAL_886:.*]], label %[[VAL_887:.*]]
// CHECK:       r17.in_bounds-after:                              ; preds = %[[VAL_886]], %[[VAL_888:.*]]
// CHECK:         ret void
// CHECK:       r17.in_bounds-true:                               ; preds = %[[VAL_888]]
// CHECK:         %[[VAL_889:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_860]] to i32*
// CHECK:         %[[VAL_890:.*]] = getelementptr inbounds i32, i32* %[[VAL_889]], i32 %[[VAL_869]]
// CHECK:         %[[VAL_891:.*]] = load i32, i32* %[[VAL_890]], align 4, !invariant.load !94
// CHECK:         %[[VAL_892:.*]] = call i32 @llvm.ctpop.i32(i32 %[[VAL_891]])
// CHECK:         %[[VAL_893:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_863]] to i32*
// CHECK:         %[[VAL_894:.*]] = getelementptr inbounds i32, i32* %[[VAL_893]], i32 %[[VAL_869]]
// CHECK:         store i32 %[[VAL_892]], i32* %[[VAL_894]], align 4
// CHECK:         %[[VAL_895:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_860]] to i32*
// CHECK:         %[[VAL_896:.*]] = getelementptr inbounds i32, i32* %[[VAL_895]], i32 %[[VAL_873]]
// CHECK:         %[[VAL_897:.*]] = load i32, i32* %[[VAL_896]], align 4, !invariant.load !94
// CHECK:         %[[VAL_898:.*]] = call i32 @llvm.ctpop.i32(i32 %[[VAL_897]])
// CHECK:         %[[VAL_899:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_863]] to i32*
// CHECK:         %[[VAL_900:.*]] = getelementptr inbounds i32, i32* %[[VAL_899]], i32 %[[VAL_873]]
// CHECK:         store i32 %[[VAL_898]], i32* %[[VAL_900]], align 4
// CHECK:         %[[VAL_901:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_860]] to i32*
// CHECK:         %[[VAL_902:.*]] = getelementptr inbounds i32, i32* %[[VAL_901]], i32 %[[VAL_877]]
// CHECK:         %[[VAL_903:.*]] = load i32, i32* %[[VAL_902]], align 4, !invariant.load !94
// CHECK:         %[[VAL_904:.*]] = call i32 @llvm.ctpop.i32(i32 %[[VAL_903]])
// CHECK:         %[[VAL_905:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_863]] to i32*
// CHECK:         %[[VAL_906:.*]] = getelementptr inbounds i32, i32* %[[VAL_905]], i32 %[[VAL_877]]
// CHECK:         store i32 %[[VAL_904]], i32* %[[VAL_906]], align 4
// CHECK:         %[[VAL_907:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_860]] to i32*
// CHECK:         %[[VAL_908:.*]] = getelementptr inbounds i32, i32* %[[VAL_907]], i32 %[[VAL_881]]
// CHECK:         %[[VAL_909:.*]] = load i32, i32* %[[VAL_908]], align 4, !invariant.load !94
// CHECK:         %[[VAL_910:.*]] = call i32 @llvm.ctpop.i32(i32 %[[VAL_909]])
// CHECK:         %[[VAL_911:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_863]] to i32*
// CHECK:         %[[VAL_912:.*]] = getelementptr inbounds i32, i32* %[[VAL_911]], i32 %[[VAL_881]]
// CHECK:         store i32 %[[VAL_910]], i32* %[[VAL_912]], align 4
// CHECK:         br label %[[VAL_887]]
// CHECK:       entry:
// CHECK:         %[[VAL_913:.*]] = getelementptr inbounds i8, i8* %[[VAL_914:.*]], i64 0
// CHECK:         %[[VAL_915:.*]] = bitcast i8* %[[VAL_913]] to [100 x [200 x %[[VAL_916:.*]]]]*
// CHECK:         %[[VAL_917:.*]] = getelementptr inbounds i8, i8* %[[VAL_918:.*]], i64 0
// CHECK:         %[[VAL_919:.*]] = bitcast i8* %[[VAL_917]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_920:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_921:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_922:.*]] = mul nuw nsw i32 %[[VAL_920]], 256
// CHECK:         %[[VAL_923:.*]] = add nuw nsw i32 %[[VAL_922]], %[[VAL_921]]
// CHECK:         %[[VAL_924:.*]] = icmp ult i32 %[[VAL_923]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_924]])
// CHECK:         %[[VAL_925:.*]] = mul nuw nsw i32 %[[VAL_923]], 4
// CHECK:         %[[VAL_926:.*]] = udiv i32 %[[VAL_925]], 1
// CHECK:         %[[VAL_927:.*]] = urem i32 %[[VAL_926]], 200
// CHECK:         %[[VAL_928:.*]] = udiv i32 %[[VAL_925]], 200
// CHECK:         %[[VAL_929:.*]] = add nuw nsw i32 %[[VAL_925]], 1
// CHECK:         %[[VAL_930:.*]] = udiv i32 %[[VAL_929]], 1
// CHECK:         %[[VAL_931:.*]] = urem i32 %[[VAL_930]], 200
// CHECK:         %[[VAL_932:.*]] = udiv i32 %[[VAL_929]], 200
// CHECK:         %[[VAL_933:.*]] = add nuw nsw i32 %[[VAL_925]], 2
// CHECK:         %[[VAL_934:.*]] = udiv i32 %[[VAL_933]], 1
// CHECK:         %[[VAL_935:.*]] = urem i32 %[[VAL_934]], 200
// CHECK:         %[[VAL_936:.*]] = udiv i32 %[[VAL_933]], 200
// CHECK:         %[[VAL_937:.*]] = add nuw nsw i32 %[[VAL_925]], 3
// CHECK:         %[[VAL_938:.*]] = udiv i32 %[[VAL_937]], 1
// CHECK:         %[[VAL_939:.*]] = urem i32 %[[VAL_938]], 200
// CHECK:         %[[VAL_940:.*]] = udiv i32 %[[VAL_937]], 200
// CHECK:         %[[VAL_941:.*]] = icmp ult i32 %[[VAL_925]], 20000
// CHECK:         br i1 %[[VAL_941]], label %[[VAL_942:.*]], label %[[VAL_943:.*]]
// CHECK:       r18.in_bounds-after:                              ; preds = %[[VAL_942]], %[[VAL_944:.*]]
// CHECK:         ret void
// CHECK:       r18.in_bounds-true:                               ; preds = %[[VAL_944]]
// CHECK:         %[[VAL_945:.*]] = bitcast [100 x [200 x %[[VAL_916]]]]* %[[VAL_915]] to %[[VAL_916]]*
// CHECK:         %[[VAL_946:.*]] = getelementptr inbounds %[[VAL_916]], %[[VAL_916]]* %[[VAL_945]], i32 %[[VAL_925]]
// CHECK:         %[[VAL_947:.*]] = load %[[VAL_916]], %[[VAL_916]]* %[[VAL_946]], align 1, !invariant.load !94
// CHECK:         %[[VAL_948:.*]] = extractvalue %[[VAL_916]] %[[VAL_947]], 0
// CHECK:         %[[VAL_949:.*]] = bitcast [100 x [200 x float]]* %[[VAL_919]] to float*
// CHECK:         %[[VAL_950:.*]] = getelementptr inbounds float, float* %[[VAL_949]], i32 %[[VAL_925]]
// CHECK:         store float %[[VAL_948]], float* %[[VAL_950]], align 4
// CHECK:         %[[VAL_951:.*]] = bitcast [100 x [200 x %[[VAL_916]]]]* %[[VAL_915]] to %[[VAL_916]]*
// CHECK:         %[[VAL_952:.*]] = getelementptr inbounds %[[VAL_916]], %[[VAL_916]]* %[[VAL_951]], i32 %[[VAL_929]]
// CHECK:         %[[VAL_953:.*]] = load %[[VAL_916]], %[[VAL_916]]* %[[VAL_952]], align 1, !invariant.load !94
// CHECK:         %[[VAL_954:.*]] = extractvalue %[[VAL_916]] %[[VAL_953]], 0
// CHECK:         %[[VAL_955:.*]] = bitcast [100 x [200 x float]]* %[[VAL_919]] to float*
// CHECK:         %[[VAL_956:.*]] = getelementptr inbounds float, float* %[[VAL_955]], i32 %[[VAL_929]]
// CHECK:         store float %[[VAL_954]], float* %[[VAL_956]], align 4
// CHECK:         %[[VAL_957:.*]] = bitcast [100 x [200 x %[[VAL_916]]]]* %[[VAL_915]] to %[[VAL_916]]*
// CHECK:         %[[VAL_958:.*]] = getelementptr inbounds %[[VAL_916]], %[[VAL_916]]* %[[VAL_957]], i32 %[[VAL_933]]
// CHECK:         %[[VAL_959:.*]] = load %[[VAL_916]], %[[VAL_916]]* %[[VAL_958]], align 1, !invariant.load !94
// CHECK:         %[[VAL_960:.*]] = extractvalue %[[VAL_916]] %[[VAL_959]], 0
// CHECK:         %[[VAL_961:.*]] = bitcast [100 x [200 x float]]* %[[VAL_919]] to float*
// CHECK:         %[[VAL_962:.*]] = getelementptr inbounds float, float* %[[VAL_961]], i32 %[[VAL_933]]
// CHECK:         store float %[[VAL_960]], float* %[[VAL_962]], align 4
// CHECK:         %[[VAL_963:.*]] = bitcast [100 x [200 x %[[VAL_916]]]]* %[[VAL_915]] to %[[VAL_916]]*
// CHECK:         %[[VAL_964:.*]] = getelementptr inbounds %[[VAL_916]], %[[VAL_916]]* %[[VAL_963]], i32 %[[VAL_937]]
// CHECK:         %[[VAL_965:.*]] = load %[[VAL_916]], %[[VAL_916]]* %[[VAL_964]], align 1, !invariant.load !94
// CHECK:         %[[VAL_966:.*]] = extractvalue %[[VAL_916]] %[[VAL_965]], 0
// CHECK:         %[[VAL_967:.*]] = bitcast [100 x [200 x float]]* %[[VAL_919]] to float*
// CHECK:         %[[VAL_968:.*]] = getelementptr inbounds float, float* %[[VAL_967]], i32 %[[VAL_937]]
// CHECK:         store float %[[VAL_966]], float* %[[VAL_968]], align 4
// CHECK:         br label %[[VAL_943]]
// CHECK:       entry:
// CHECK:         %[[VAL_969:.*]] = getelementptr inbounds i8, i8* %[[VAL_970:.*]], i64 0
// CHECK:         %[[VAL_971:.*]] = bitcast i8* %[[VAL_969]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_972:.*]] = getelementptr inbounds i8, i8* %[[VAL_973:.*]], i64 0
// CHECK:         %[[VAL_974:.*]] = bitcast i8* %[[VAL_972]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_975:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_976:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_977:.*]] = mul nuw nsw i32 %[[VAL_975]], 256
// CHECK:         %[[VAL_978:.*]] = add nuw nsw i32 %[[VAL_977]], %[[VAL_976]]
// CHECK:         %[[VAL_979:.*]] = icmp ult i32 %[[VAL_978]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_979]])
// CHECK:         %[[VAL_980:.*]] = mul nuw nsw i32 %[[VAL_978]], 4
// CHECK:         %[[VAL_981:.*]] = udiv i32 %[[VAL_980]], 1
// CHECK:         %[[VAL_982:.*]] = urem i32 %[[VAL_981]], 200
// CHECK:         %[[VAL_983:.*]] = udiv i32 %[[VAL_980]], 200
// CHECK:         %[[VAL_984:.*]] = add nuw nsw i32 %[[VAL_980]], 1
// CHECK:         %[[VAL_985:.*]] = udiv i32 %[[VAL_984]], 1
// CHECK:         %[[VAL_986:.*]] = urem i32 %[[VAL_985]], 200
// CHECK:         %[[VAL_987:.*]] = udiv i32 %[[VAL_984]], 200
// CHECK:         %[[VAL_988:.*]] = add nuw nsw i32 %[[VAL_980]], 2
// CHECK:         %[[VAL_989:.*]] = udiv i32 %[[VAL_988]], 1
// CHECK:         %[[VAL_990:.*]] = urem i32 %[[VAL_989]], 200
// CHECK:         %[[VAL_991:.*]] = udiv i32 %[[VAL_988]], 200
// CHECK:         %[[VAL_992:.*]] = add nuw nsw i32 %[[VAL_980]], 3
// CHECK:         %[[VAL_993:.*]] = udiv i32 %[[VAL_992]], 1
// CHECK:         %[[VAL_994:.*]] = urem i32 %[[VAL_993]], 200
// CHECK:         %[[VAL_995:.*]] = udiv i32 %[[VAL_992]], 200
// CHECK:         %[[VAL_996:.*]] = icmp ult i32 %[[VAL_980]], 20000
// CHECK:         br i1 %[[VAL_996]], label %[[VAL_997:.*]], label %[[VAL_998:.*]]
// CHECK:       r19.in_bounds-after:                              ; preds = %[[VAL_997]], %[[VAL_999:.*]]
// CHECK:         ret void
// CHECK:       r19.in_bounds-true:                               ; preds = %[[VAL_999]]
// CHECK:         %[[VAL_1000:.*]] = bitcast [100 x [200 x float]]* %[[VAL_971]] to float*
// CHECK:         %[[VAL_1001:.*]] = getelementptr inbounds float, float* %[[VAL_1000]], i32 %[[VAL_980]]
// CHECK:         %[[VAL_1002:.*]] = load float, float* %[[VAL_1001]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1003:.*]] = bitcast float %[[VAL_1002]] to i32
// CHECK:         %[[VAL_1004:.*]] = and i32 %[[VAL_1003]], 2147483647
// CHECK:         %[[VAL_1005:.*]] = icmp ugt i32 %[[VAL_1004]], 2139095040
// CHECK:         %[[VAL_1006:.*]] = and i32 %[[VAL_1003]], 2048
// CHECK:         %[[VAL_1007:.*]] = lshr i32 %[[VAL_1006]], 11
// CHECK:         %[[VAL_1008:.*]] = add i32 %[[VAL_1007]], 1023
// CHECK:         %[[VAL_1009:.*]] = add i32 %[[VAL_1003]], %[[VAL_1008]]
// CHECK:         %[[VAL_1010:.*]] = and i32 %[[VAL_1009]], -2048
// CHECK:         %[[VAL_1011:.*]] = and i32 %[[VAL_1010]], 2139095040
// CHECK:         %[[VAL_1012:.*]] = icmp ugt i32 %[[VAL_1011]], 1191182336
// CHECK:         %[[VAL_1013:.*]] = icmp ule i32 %[[VAL_1011]], 939524096
// CHECK:         %[[VAL_1014:.*]] = and i32 %[[VAL_1010]], -2147483648
// CHECK:         %[[VAL_1015:.*]] = or i32 %[[VAL_1014]], 2139095040
// CHECK:         %[[VAL_1016:.*]] = select i1 %[[VAL_1012]], i32 %[[VAL_1015]], i32 %[[VAL_1010]]
// CHECK:         %[[VAL_1017:.*]] = select i1 %[[VAL_1013]], i32 %[[VAL_1014]], i32 %[[VAL_1016]]
// CHECK:         %[[VAL_1018:.*]] = bitcast i32 %[[VAL_1017]] to float
// CHECK:         %[[VAL_1019:.*]] = select i1 %[[VAL_1005]], float %[[VAL_1002]], float %[[VAL_1018]]
// CHECK:         %[[VAL_1020:.*]] = bitcast [100 x [200 x float]]* %[[VAL_974]] to float*
// CHECK:         %[[VAL_1021:.*]] = getelementptr inbounds float, float* %[[VAL_1020]], i32 %[[VAL_980]]
// CHECK:         store float %[[VAL_1019]], float* %[[VAL_1021]], align 4
// CHECK:         %[[VAL_1022:.*]] = bitcast [100 x [200 x float]]* %[[VAL_971]] to float*
// CHECK:         %[[VAL_1023:.*]] = getelementptr inbounds float, float* %[[VAL_1022]], i32 %[[VAL_984]]
// CHECK:         %[[VAL_1024:.*]] = load float, float* %[[VAL_1023]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1025:.*]] = bitcast float %[[VAL_1024]] to i32
// CHECK:         %[[VAL_1026:.*]] = and i32 %[[VAL_1025]], 2147483647
// CHECK:         %[[VAL_1027:.*]] = icmp ugt i32 %[[VAL_1026]], 2139095040
// CHECK:         %[[VAL_1028:.*]] = and i32 %[[VAL_1025]], 2048
// CHECK:         %[[VAL_1029:.*]] = lshr i32 %[[VAL_1028]], 11
// CHECK:         %[[VAL_1030:.*]] = add i32 %[[VAL_1029]], 1023
// CHECK:         %[[VAL_1031:.*]] = add i32 %[[VAL_1025]], %[[VAL_1030]]
// CHECK:         %[[VAL_1032:.*]] = and i32 %[[VAL_1031]], -2048
// CHECK:         %[[VAL_1033:.*]] = and i32 %[[VAL_1032]], 2139095040
// CHECK:         %[[VAL_1034:.*]] = icmp ugt i32 %[[VAL_1033]], 1191182336
// CHECK:         %[[VAL_1035:.*]] = icmp ule i32 %[[VAL_1033]], 939524096
// CHECK:         %[[VAL_1036:.*]] = and i32 %[[VAL_1032]], -2147483648
// CHECK:         %[[VAL_1037:.*]] = or i32 %[[VAL_1036]], 2139095040
// CHECK:         %[[VAL_1038:.*]] = select i1 %[[VAL_1034]], i32 %[[VAL_1037]], i32 %[[VAL_1032]]
// CHECK:         %[[VAL_1039:.*]] = select i1 %[[VAL_1035]], i32 %[[VAL_1036]], i32 %[[VAL_1038]]
// CHECK:         %[[VAL_1040:.*]] = bitcast i32 %[[VAL_1039]] to float
// CHECK:         %[[VAL_1041:.*]] = select i1 %[[VAL_1027]], float %[[VAL_1024]], float %[[VAL_1040]]
// CHECK:         %[[VAL_1042:.*]] = bitcast [100 x [200 x float]]* %[[VAL_974]] to float*
// CHECK:         %[[VAL_1043:.*]] = getelementptr inbounds float, float* %[[VAL_1042]], i32 %[[VAL_984]]
// CHECK:         store float %[[VAL_1041]], float* %[[VAL_1043]], align 4
// CHECK:         %[[VAL_1044:.*]] = bitcast [100 x [200 x float]]* %[[VAL_971]] to float*
// CHECK:         %[[VAL_1045:.*]] = getelementptr inbounds float, float* %[[VAL_1044]], i32 %[[VAL_988]]
// CHECK:         %[[VAL_1046:.*]] = load float, float* %[[VAL_1045]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1047:.*]] = bitcast float %[[VAL_1046]] to i32
// CHECK:         %[[VAL_1048:.*]] = and i32 %[[VAL_1047]], 2147483647
// CHECK:         %[[VAL_1049:.*]] = icmp ugt i32 %[[VAL_1048]], 2139095040
// CHECK:         %[[VAL_1050:.*]] = and i32 %[[VAL_1047]], 2048
// CHECK:         %[[VAL_1051:.*]] = lshr i32 %[[VAL_1050]], 11
// CHECK:         %[[VAL_1052:.*]] = add i32 %[[VAL_1051]], 1023
// CHECK:         %[[VAL_1053:.*]] = add i32 %[[VAL_1047]], %[[VAL_1052]]
// CHECK:         %[[VAL_1054:.*]] = and i32 %[[VAL_1053]], -2048
// CHECK:         %[[VAL_1055:.*]] = and i32 %[[VAL_1054]], 2139095040
// CHECK:         %[[VAL_1056:.*]] = icmp ugt i32 %[[VAL_1055]], 1191182336
// CHECK:         %[[VAL_1057:.*]] = icmp ule i32 %[[VAL_1055]], 939524096
// CHECK:         %[[VAL_1058:.*]] = and i32 %[[VAL_1054]], -2147483648
// CHECK:         %[[VAL_1059:.*]] = or i32 %[[VAL_1058]], 2139095040
// CHECK:         %[[VAL_1060:.*]] = select i1 %[[VAL_1056]], i32 %[[VAL_1059]], i32 %[[VAL_1054]]
// CHECK:         %[[VAL_1061:.*]] = select i1 %[[VAL_1057]], i32 %[[VAL_1058]], i32 %[[VAL_1060]]
// CHECK:         %[[VAL_1062:.*]] = bitcast i32 %[[VAL_1061]] to float
// CHECK:         %[[VAL_1063:.*]] = select i1 %[[VAL_1049]], float %[[VAL_1046]], float %[[VAL_1062]]
// CHECK:         %[[VAL_1064:.*]] = bitcast [100 x [200 x float]]* %[[VAL_974]] to float*
// CHECK:         %[[VAL_1065:.*]] = getelementptr inbounds float, float* %[[VAL_1064]], i32 %[[VAL_988]]
// CHECK:         store float %[[VAL_1063]], float* %[[VAL_1065]], align 4
// CHECK:         %[[VAL_1066:.*]] = bitcast [100 x [200 x float]]* %[[VAL_971]] to float*
// CHECK:         %[[VAL_1067:.*]] = getelementptr inbounds float, float* %[[VAL_1066]], i32 %[[VAL_992]]
// CHECK:         %[[VAL_1068:.*]] = load float, float* %[[VAL_1067]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1069:.*]] = bitcast float %[[VAL_1068]] to i32
// CHECK:         %[[VAL_1070:.*]] = and i32 %[[VAL_1069]], 2147483647
// CHECK:         %[[VAL_1071:.*]] = icmp ugt i32 %[[VAL_1070]], 2139095040
// CHECK:         %[[VAL_1072:.*]] = and i32 %[[VAL_1069]], 2048
// CHECK:         %[[VAL_1073:.*]] = lshr i32 %[[VAL_1072]], 11
// CHECK:         %[[VAL_1074:.*]] = add i32 %[[VAL_1073]], 1023
// CHECK:         %[[VAL_1075:.*]] = add i32 %[[VAL_1069]], %[[VAL_1074]]
// CHECK:         %[[VAL_1076:.*]] = and i32 %[[VAL_1075]], -2048
// CHECK:         %[[VAL_1077:.*]] = and i32 %[[VAL_1076]], 2139095040
// CHECK:         %[[VAL_1078:.*]] = icmp ugt i32 %[[VAL_1077]], 1191182336
// CHECK:         %[[VAL_1079:.*]] = icmp ule i32 %[[VAL_1077]], 939524096
// CHECK:         %[[VAL_1080:.*]] = and i32 %[[VAL_1076]], -2147483648
// CHECK:         %[[VAL_1081:.*]] = or i32 %[[VAL_1080]], 2139095040
// CHECK:         %[[VAL_1082:.*]] = select i1 %[[VAL_1078]], i32 %[[VAL_1081]], i32 %[[VAL_1076]]
// CHECK:         %[[VAL_1083:.*]] = select i1 %[[VAL_1079]], i32 %[[VAL_1080]], i32 %[[VAL_1082]]
// CHECK:         %[[VAL_1084:.*]] = bitcast i32 %[[VAL_1083]] to float
// CHECK:         %[[VAL_1085:.*]] = select i1 %[[VAL_1071]], float %[[VAL_1068]], float %[[VAL_1084]]
// CHECK:         %[[VAL_1086:.*]] = bitcast [100 x [200 x float]]* %[[VAL_974]] to float*
// CHECK:         %[[VAL_1087:.*]] = getelementptr inbounds float, float* %[[VAL_1086]], i32 %[[VAL_992]]
// CHECK:         store float %[[VAL_1085]], float* %[[VAL_1087]], align 4
// CHECK:         br label %[[VAL_998]]
// CHECK:       entry:
// CHECK:         %[[VAL_1088:.*]] = getelementptr inbounds i8, i8* %[[VAL_1089:.*]], i64 0
// CHECK:         %[[VAL_1090:.*]] = bitcast i8* %[[VAL_1088]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1091:.*]] = getelementptr inbounds i8, i8* %[[VAL_1092:.*]], i64 0
// CHECK:         %[[VAL_1093:.*]] = bitcast i8* %[[VAL_1091]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1094:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1095:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1096:.*]] = mul nuw nsw i32 %[[VAL_1094]], 256
// CHECK:         %[[VAL_1097:.*]] = add nuw nsw i32 %[[VAL_1096]], %[[VAL_1095]]
// CHECK:         %[[VAL_1098:.*]] = icmp ult i32 %[[VAL_1097]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1098]])
// CHECK:         %[[VAL_1099:.*]] = mul nuw nsw i32 %[[VAL_1097]], 4
// CHECK:         %[[VAL_1100:.*]] = udiv i32 %[[VAL_1099]], 1
// CHECK:         %[[VAL_1101:.*]] = urem i32 %[[VAL_1100]], 200
// CHECK:         %[[VAL_1102:.*]] = udiv i32 %[[VAL_1099]], 200
// CHECK:         %[[VAL_1103:.*]] = add nuw nsw i32 %[[VAL_1099]], 1
// CHECK:         %[[VAL_1104:.*]] = udiv i32 %[[VAL_1103]], 1
// CHECK:         %[[VAL_1105:.*]] = urem i32 %[[VAL_1104]], 200
// CHECK:         %[[VAL_1106:.*]] = udiv i32 %[[VAL_1103]], 200
// CHECK:         %[[VAL_1107:.*]] = add nuw nsw i32 %[[VAL_1099]], 2
// CHECK:         %[[VAL_1108:.*]] = udiv i32 %[[VAL_1107]], 1
// CHECK:         %[[VAL_1109:.*]] = urem i32 %[[VAL_1108]], 200
// CHECK:         %[[VAL_1110:.*]] = udiv i32 %[[VAL_1107]], 200
// CHECK:         %[[VAL_1111:.*]] = add nuw nsw i32 %[[VAL_1099]], 3
// CHECK:         %[[VAL_1112:.*]] = udiv i32 %[[VAL_1111]], 1
// CHECK:         %[[VAL_1113:.*]] = urem i32 %[[VAL_1112]], 200
// CHECK:         %[[VAL_1114:.*]] = udiv i32 %[[VAL_1111]], 200
// CHECK:         %[[VAL_1115:.*]] = icmp ult i32 %[[VAL_1099]], 20000
// CHECK:         br i1 %[[VAL_1115]], label %[[VAL_1116:.*]], label %[[VAL_1117:.*]]
// CHECK:       r20.in_bounds-after:                              ; preds = %[[VAL_1116]], %[[VAL_1118:.*]]
// CHECK:         ret void
// CHECK:       r20.in_bounds-true:                               ; preds = %[[VAL_1118]]
// CHECK:         %[[VAL_1119:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1090]] to float*
// CHECK:         %[[VAL_1120:.*]] = getelementptr inbounds float, float* %[[VAL_1119]], i32 %[[VAL_1099]]
// CHECK:         %[[VAL_1121:.*]] = load float, float* %[[VAL_1120]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1122:.*]] = call float @__nv_rsqrtf(float %[[VAL_1121]])
// CHECK:         %[[VAL_1123:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1093]] to float*
// CHECK:         %[[VAL_1124:.*]] = getelementptr inbounds float, float* %[[VAL_1123]], i32 %[[VAL_1099]]
// CHECK:         store float %[[VAL_1122]], float* %[[VAL_1124]], align 4
// CHECK:         %[[VAL_1125:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1090]] to float*
// CHECK:         %[[VAL_1126:.*]] = getelementptr inbounds float, float* %[[VAL_1125]], i32 %[[VAL_1103]]
// CHECK:         %[[VAL_1127:.*]] = load float, float* %[[VAL_1126]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1128:.*]] = call float @__nv_rsqrtf(float %[[VAL_1127]])
// CHECK:         %[[VAL_1129:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1093]] to float*
// CHECK:         %[[VAL_1130:.*]] = getelementptr inbounds float, float* %[[VAL_1129]], i32 %[[VAL_1103]]
// CHECK:         store float %[[VAL_1128]], float* %[[VAL_1130]], align 4
// CHECK:         %[[VAL_1131:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1090]] to float*
// CHECK:         %[[VAL_1132:.*]] = getelementptr inbounds float, float* %[[VAL_1131]], i32 %[[VAL_1107]]
// CHECK:         %[[VAL_1133:.*]] = load float, float* %[[VAL_1132]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1134:.*]] = call float @__nv_rsqrtf(float %[[VAL_1133]])
// CHECK:         %[[VAL_1135:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1093]] to float*
// CHECK:         %[[VAL_1136:.*]] = getelementptr inbounds float, float* %[[VAL_1135]], i32 %[[VAL_1107]]
// CHECK:         store float %[[VAL_1134]], float* %[[VAL_1136]], align 4
// CHECK:         %[[VAL_1137:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1090]] to float*
// CHECK:         %[[VAL_1138:.*]] = getelementptr inbounds float, float* %[[VAL_1137]], i32 %[[VAL_1111]]
// CHECK:         %[[VAL_1139:.*]] = load float, float* %[[VAL_1138]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1140:.*]] = call float @__nv_rsqrtf(float %[[VAL_1139]])
// CHECK:         %[[VAL_1141:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1093]] to float*
// CHECK:         %[[VAL_1142:.*]] = getelementptr inbounds float, float* %[[VAL_1141]], i32 %[[VAL_1111]]
// CHECK:         store float %[[VAL_1140]], float* %[[VAL_1142]], align 4
// CHECK:         br label %[[VAL_1117]]
// CHECK:       entry:
// CHECK:         %[[VAL_1143:.*]] = getelementptr inbounds i8, i8* %[[VAL_1144:.*]], i64 0
// CHECK:         %[[VAL_1145:.*]] = bitcast i8* %[[VAL_1143]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1146:.*]] = getelementptr inbounds i8, i8* %[[VAL_1147:.*]], i64 0
// CHECK:         %[[VAL_1148:.*]] = bitcast i8* %[[VAL_1146]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1149:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1150:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1151:.*]] = mul nuw nsw i32 %[[VAL_1149]], 256
// CHECK:         %[[VAL_1152:.*]] = add nuw nsw i32 %[[VAL_1151]], %[[VAL_1150]]
// CHECK:         %[[VAL_1153:.*]] = icmp ult i32 %[[VAL_1152]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1153]])
// CHECK:         %[[VAL_1154:.*]] = mul nuw nsw i32 %[[VAL_1152]], 4
// CHECK:         %[[VAL_1155:.*]] = udiv i32 %[[VAL_1154]], 1
// CHECK:         %[[VAL_1156:.*]] = urem i32 %[[VAL_1155]], 200
// CHECK:         %[[VAL_1157:.*]] = udiv i32 %[[VAL_1154]], 200
// CHECK:         %[[VAL_1158:.*]] = add nuw nsw i32 %[[VAL_1154]], 1
// CHECK:         %[[VAL_1159:.*]] = udiv i32 %[[VAL_1158]], 1
// CHECK:         %[[VAL_1160:.*]] = urem i32 %[[VAL_1159]], 200
// CHECK:         %[[VAL_1161:.*]] = udiv i32 %[[VAL_1158]], 200
// CHECK:         %[[VAL_1162:.*]] = add nuw nsw i32 %[[VAL_1154]], 2
// CHECK:         %[[VAL_1163:.*]] = udiv i32 %[[VAL_1162]], 1
// CHECK:         %[[VAL_1164:.*]] = urem i32 %[[VAL_1163]], 200
// CHECK:         %[[VAL_1165:.*]] = udiv i32 %[[VAL_1162]], 200
// CHECK:         %[[VAL_1166:.*]] = add nuw nsw i32 %[[VAL_1154]], 3
// CHECK:         %[[VAL_1167:.*]] = udiv i32 %[[VAL_1166]], 1
// CHECK:         %[[VAL_1168:.*]] = urem i32 %[[VAL_1167]], 200
// CHECK:         %[[VAL_1169:.*]] = udiv i32 %[[VAL_1166]], 200
// CHECK:         %[[VAL_1170:.*]] = icmp ult i32 %[[VAL_1154]], 20000
// CHECK:         br i1 %[[VAL_1170]], label %[[VAL_1171:.*]], label %[[VAL_1172:.*]]
// CHECK:       r22.in_bounds-after:                              ; preds = %[[VAL_1171]], %[[VAL_1173:.*]]
// CHECK:         ret void
// CHECK:       r22.in_bounds-true:                               ; preds = %[[VAL_1173]]
// CHECK:         %[[VAL_1174:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1145]] to float*
// CHECK:         %[[VAL_1175:.*]] = getelementptr inbounds float, float* %[[VAL_1174]], i32 %[[VAL_1154]]
// CHECK:         %[[VAL_1176:.*]] = load float, float* %[[VAL_1175]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1177:.*]] = fcmp one float %[[VAL_1176]], 0.000000e+00
// CHECK:         %[[VAL_1178:.*]] = uitofp i1 %[[VAL_1177]] to float
// CHECK:         %[[VAL_1179:.*]] = call float @llvm.copysign.f32(float %[[VAL_1178]], float %[[VAL_1176]])
// CHECK:         %[[VAL_1180:.*]] = fcmp uno float %[[VAL_1176]], %[[VAL_1176]]
// CHECK:         %[[VAL_1181:.*]] = select i1 %[[VAL_1180]], float %[[VAL_1176]], float %[[VAL_1179]]
// CHECK:         %[[VAL_1182:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1148]] to float*
// CHECK:         %[[VAL_1183:.*]] = getelementptr inbounds float, float* %[[VAL_1182]], i32 %[[VAL_1154]]
// CHECK:         store float %[[VAL_1181]], float* %[[VAL_1183]], align 4
// CHECK:         %[[VAL_1184:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1145]] to float*
// CHECK:         %[[VAL_1185:.*]] = getelementptr inbounds float, float* %[[VAL_1184]], i32 %[[VAL_1158]]
// CHECK:         %[[VAL_1186:.*]] = load float, float* %[[VAL_1185]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1187:.*]] = fcmp one float %[[VAL_1186]], 0.000000e+00
// CHECK:         %[[VAL_1188:.*]] = uitofp i1 %[[VAL_1187]] to float
// CHECK:         %[[VAL_1189:.*]] = call float @llvm.copysign.f32(float %[[VAL_1188]], float %[[VAL_1186]])
// CHECK:         %[[VAL_1190:.*]] = fcmp uno float %[[VAL_1186]], %[[VAL_1186]]
// CHECK:         %[[VAL_1191:.*]] = select i1 %[[VAL_1190]], float %[[VAL_1186]], float %[[VAL_1189]]
// CHECK:         %[[VAL_1192:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1148]] to float*
// CHECK:         %[[VAL_1193:.*]] = getelementptr inbounds float, float* %[[VAL_1192]], i32 %[[VAL_1158]]
// CHECK:         store float %[[VAL_1191]], float* %[[VAL_1193]], align 4
// CHECK:         %[[VAL_1194:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1145]] to float*
// CHECK:         %[[VAL_1195:.*]] = getelementptr inbounds float, float* %[[VAL_1194]], i32 %[[VAL_1162]]
// CHECK:         %[[VAL_1196:.*]] = load float, float* %[[VAL_1195]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1197:.*]] = fcmp one float %[[VAL_1196]], 0.000000e+00
// CHECK:         %[[VAL_1198:.*]] = uitofp i1 %[[VAL_1197]] to float
// CHECK:         %[[VAL_1199:.*]] = call float @llvm.copysign.f32(float %[[VAL_1198]], float %[[VAL_1196]])
// CHECK:         %[[VAL_1200:.*]] = fcmp uno float %[[VAL_1196]], %[[VAL_1196]]
// CHECK:         %[[VAL_1201:.*]] = select i1 %[[VAL_1200]], float %[[VAL_1196]], float %[[VAL_1199]]
// CHECK:         %[[VAL_1202:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1148]] to float*
// CHECK:         %[[VAL_1203:.*]] = getelementptr inbounds float, float* %[[VAL_1202]], i32 %[[VAL_1162]]
// CHECK:         store float %[[VAL_1201]], float* %[[VAL_1203]], align 4
// CHECK:         %[[VAL_1204:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1145]] to float*
// CHECK:         %[[VAL_1205:.*]] = getelementptr inbounds float, float* %[[VAL_1204]], i32 %[[VAL_1166]]
// CHECK:         %[[VAL_1206:.*]] = load float, float* %[[VAL_1205]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1207:.*]] = fcmp one float %[[VAL_1206]], 0.000000e+00
// CHECK:         %[[VAL_1208:.*]] = uitofp i1 %[[VAL_1207]] to float
// CHECK:         %[[VAL_1209:.*]] = call float @llvm.copysign.f32(float %[[VAL_1208]], float %[[VAL_1206]])
// CHECK:         %[[VAL_1210:.*]] = fcmp uno float %[[VAL_1206]], %[[VAL_1206]]
// CHECK:         %[[VAL_1211:.*]] = select i1 %[[VAL_1210]], float %[[VAL_1206]], float %[[VAL_1209]]
// CHECK:         %[[VAL_1212:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1148]] to float*
// CHECK:         %[[VAL_1213:.*]] = getelementptr inbounds float, float* %[[VAL_1212]], i32 %[[VAL_1166]]
// CHECK:         store float %[[VAL_1211]], float* %[[VAL_1213]], align 4
// CHECK:         br label %[[VAL_1172]]
// CHECK:       entry:
// CHECK:         %[[VAL_1214:.*]] = getelementptr inbounds i8, i8* %[[VAL_1215:.*]], i64 0
// CHECK:         %[[VAL_1216:.*]] = bitcast i8* %[[VAL_1214]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1217:.*]] = getelementptr inbounds i8, i8* %[[VAL_1218:.*]], i64 0
// CHECK:         %[[VAL_1219:.*]] = bitcast i8* %[[VAL_1217]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1220:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1221:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !95
// CHECK:         %[[VAL_1222:.*]] = mul nuw nsw i32 %[[VAL_1220]], 1024
// CHECK:         %[[VAL_1223:.*]] = add nuw nsw i32 %[[VAL_1222]], %[[VAL_1221]]
// CHECK:         %[[VAL_1224:.*]] = icmp ult i32 %[[VAL_1223]], 20480
// CHECK:         call void @llvm.assume(i1 %[[VAL_1224]])
// CHECK:         %[[VAL_1225:.*]] = udiv i32 %[[VAL_1223]], 1
// CHECK:         %[[VAL_1226:.*]] = urem i32 %[[VAL_1225]], 200
// CHECK:         %[[VAL_1227:.*]] = udiv i32 %[[VAL_1223]], 200
// CHECK:         %[[VAL_1228:.*]] = icmp ult i32 %[[VAL_1223]], 20000
// CHECK:         br i1 %[[VAL_1228]], label %[[VAL_1229:.*]], label %[[VAL_1230:.*]]
// CHECK:       r23.in_bounds-after:                              ; preds = %[[VAL_1229]], %[[VAL_1231:.*]]
// CHECK:         ret void
// CHECK:       r23.in_bounds-true:                               ; preds = %[[VAL_1231]]
// CHECK:         %[[VAL_1232:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1216]] to float*
// CHECK:         %[[VAL_1233:.*]] = getelementptr inbounds float, float* %[[VAL_1232]], i32 %[[VAL_1223]]
// CHECK:         %[[VAL_1234:.*]] = load float, float* %[[VAL_1233]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1235:.*]] = call float @__nv_sinf(float %[[VAL_1234]])
// CHECK:         %[[VAL_1236:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1219]] to float*
// CHECK:         %[[VAL_1237:.*]] = getelementptr inbounds float, float* %[[VAL_1236]], i32 %[[VAL_1223]]
// CHECK:         store float %[[VAL_1235]], float* %[[VAL_1237]], align 4
// CHECK:         br label %[[VAL_1230]]
// CHECK:       entry:
// CHECK:         %[[VAL_1238:.*]] = getelementptr inbounds i8, i8* %[[VAL_1239:.*]], i64 0
// CHECK:         %[[VAL_1240:.*]] = bitcast i8* %[[VAL_1238]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1241:.*]] = getelementptr inbounds i8, i8* %[[VAL_1242:.*]], i64 0
// CHECK:         %[[VAL_1243:.*]] = bitcast i8* %[[VAL_1241]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1244:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1245:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1246:.*]] = mul nuw nsw i32 %[[VAL_1244]], 256
// CHECK:         %[[VAL_1247:.*]] = add nuw nsw i32 %[[VAL_1246]], %[[VAL_1245]]
// CHECK:         %[[VAL_1248:.*]] = icmp ult i32 %[[VAL_1247]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1248]])
// CHECK:         %[[VAL_1249:.*]] = mul nuw nsw i32 %[[VAL_1247]], 4
// CHECK:         %[[VAL_1250:.*]] = udiv i32 %[[VAL_1249]], 1
// CHECK:         %[[VAL_1251:.*]] = urem i32 %[[VAL_1250]], 200
// CHECK:         %[[VAL_1252:.*]] = udiv i32 %[[VAL_1249]], 200
// CHECK:         %[[VAL_1253:.*]] = add nuw nsw i32 %[[VAL_1249]], 1
// CHECK:         %[[VAL_1254:.*]] = udiv i32 %[[VAL_1253]], 1
// CHECK:         %[[VAL_1255:.*]] = urem i32 %[[VAL_1254]], 200
// CHECK:         %[[VAL_1256:.*]] = udiv i32 %[[VAL_1253]], 200
// CHECK:         %[[VAL_1257:.*]] = add nuw nsw i32 %[[VAL_1249]], 2
// CHECK:         %[[VAL_1258:.*]] = udiv i32 %[[VAL_1257]], 1
// CHECK:         %[[VAL_1259:.*]] = urem i32 %[[VAL_1258]], 200
// CHECK:         %[[VAL_1260:.*]] = udiv i32 %[[VAL_1257]], 200
// CHECK:         %[[VAL_1261:.*]] = add nuw nsw i32 %[[VAL_1249]], 3
// CHECK:         %[[VAL_1262:.*]] = udiv i32 %[[VAL_1261]], 1
// CHECK:         %[[VAL_1263:.*]] = urem i32 %[[VAL_1262]], 200
// CHECK:         %[[VAL_1264:.*]] = udiv i32 %[[VAL_1261]], 200
// CHECK:         %[[VAL_1265:.*]] = icmp ult i32 %[[VAL_1249]], 20000
// CHECK:         br i1 %[[VAL_1265]], label %[[VAL_1266:.*]], label %[[VAL_1267:.*]]
// CHECK:       r24.in_bounds-after:                              ; preds = %[[VAL_1266]], %[[VAL_1268:.*]]
// CHECK:         ret void
// CHECK:       r24.in_bounds-true:                               ; preds = %[[VAL_1268]]
// CHECK:         %[[VAL_1269:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1240]] to float*
// CHECK:         %[[VAL_1270:.*]] = getelementptr inbounds float, float* %[[VAL_1269]], i32 %[[VAL_1249]]
// CHECK:         %[[VAL_1271:.*]] = load float, float* %[[VAL_1270]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1272:.*]] = call float @__nv_sqrtf(float %[[VAL_1271]])
// CHECK:         %[[VAL_1273:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1243]] to float*
// CHECK:         %[[VAL_1274:.*]] = getelementptr inbounds float, float* %[[VAL_1273]], i32 %[[VAL_1249]]
// CHECK:         store float %[[VAL_1272]], float* %[[VAL_1274]], align 4
// CHECK:         %[[VAL_1275:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1240]] to float*
// CHECK:         %[[VAL_1276:.*]] = getelementptr inbounds float, float* %[[VAL_1275]], i32 %[[VAL_1253]]
// CHECK:         %[[VAL_1277:.*]] = load float, float* %[[VAL_1276]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1278:.*]] = call float @__nv_sqrtf(float %[[VAL_1277]])
// CHECK:         %[[VAL_1279:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1243]] to float*
// CHECK:         %[[VAL_1280:.*]] = getelementptr inbounds float, float* %[[VAL_1279]], i32 %[[VAL_1253]]
// CHECK:         store float %[[VAL_1278]], float* %[[VAL_1280]], align 4
// CHECK:         %[[VAL_1281:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1240]] to float*
// CHECK:         %[[VAL_1282:.*]] = getelementptr inbounds float, float* %[[VAL_1281]], i32 %[[VAL_1257]]
// CHECK:         %[[VAL_1283:.*]] = load float, float* %[[VAL_1282]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1284:.*]] = call float @__nv_sqrtf(float %[[VAL_1283]])
// CHECK:         %[[VAL_1285:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1243]] to float*
// CHECK:         %[[VAL_1286:.*]] = getelementptr inbounds float, float* %[[VAL_1285]], i32 %[[VAL_1257]]
// CHECK:         store float %[[VAL_1284]], float* %[[VAL_1286]], align 4
// CHECK:         %[[VAL_1287:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1240]] to float*
// CHECK:         %[[VAL_1288:.*]] = getelementptr inbounds float, float* %[[VAL_1287]], i32 %[[VAL_1261]]
// CHECK:         %[[VAL_1289:.*]] = load float, float* %[[VAL_1288]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1290:.*]] = call float @__nv_sqrtf(float %[[VAL_1289]])
// CHECK:         %[[VAL_1291:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1243]] to float*
// CHECK:         %[[VAL_1292:.*]] = getelementptr inbounds float, float* %[[VAL_1291]], i32 %[[VAL_1261]]
// CHECK:         store float %[[VAL_1290]], float* %[[VAL_1292]], align 4
// CHECK:         br label %[[VAL_1267]]
// CHECK:       entry:
// CHECK:         %[[VAL_1293:.*]] = getelementptr inbounds i8, i8* %[[VAL_1294:.*]], i64 0
// CHECK:         %[[VAL_1295:.*]] = bitcast i8* %[[VAL_1293]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1296:.*]] = getelementptr inbounds i8, i8* %[[VAL_1297:.*]], i64 0
// CHECK:         %[[VAL_1298:.*]] = bitcast i8* %[[VAL_1296]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1299:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1300:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1301:.*]] = mul nuw nsw i32 %[[VAL_1299]], 256
// CHECK:         %[[VAL_1302:.*]] = add nuw nsw i32 %[[VAL_1301]], %[[VAL_1300]]
// CHECK:         %[[VAL_1303:.*]] = icmp ult i32 %[[VAL_1302]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1303]])
// CHECK:         %[[VAL_1304:.*]] = mul nuw nsw i32 %[[VAL_1302]], 4
// CHECK:         %[[VAL_1305:.*]] = udiv i32 %[[VAL_1304]], 1
// CHECK:         %[[VAL_1306:.*]] = urem i32 %[[VAL_1305]], 200
// CHECK:         %[[VAL_1307:.*]] = udiv i32 %[[VAL_1304]], 200
// CHECK:         %[[VAL_1308:.*]] = add nuw nsw i32 %[[VAL_1304]], 1
// CHECK:         %[[VAL_1309:.*]] = udiv i32 %[[VAL_1308]], 1
// CHECK:         %[[VAL_1310:.*]] = urem i32 %[[VAL_1309]], 200
// CHECK:         %[[VAL_1311:.*]] = udiv i32 %[[VAL_1308]], 200
// CHECK:         %[[VAL_1312:.*]] = add nuw nsw i32 %[[VAL_1304]], 2
// CHECK:         %[[VAL_1313:.*]] = udiv i32 %[[VAL_1312]], 1
// CHECK:         %[[VAL_1314:.*]] = urem i32 %[[VAL_1313]], 200
// CHECK:         %[[VAL_1315:.*]] = udiv i32 %[[VAL_1312]], 200
// CHECK:         %[[VAL_1316:.*]] = add nuw nsw i32 %[[VAL_1304]], 3
// CHECK:         %[[VAL_1317:.*]] = udiv i32 %[[VAL_1316]], 1
// CHECK:         %[[VAL_1318:.*]] = urem i32 %[[VAL_1317]], 200
// CHECK:         %[[VAL_1319:.*]] = udiv i32 %[[VAL_1316]], 200
// CHECK:         %[[VAL_1320:.*]] = icmp ult i32 %[[VAL_1304]], 20000
// CHECK:         br i1 %[[VAL_1320]], label %[[VAL_1321:.*]], label %[[VAL_1322:.*]]
// CHECK:       r25.in_bounds-after:                              ; preds = %[[VAL_1321]], %[[VAL_1323:.*]]
// CHECK:         ret void
// CHECK:       r25.in_bounds-true:                               ; preds = %[[VAL_1323]]
// CHECK:         %[[VAL_1324:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1295]] to float*
// CHECK:         %[[VAL_1325:.*]] = getelementptr inbounds float, float* %[[VAL_1324]], i32 %[[VAL_1304]]
// CHECK:         %[[VAL_1326:.*]] = load float, float* %[[VAL_1325]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1327:.*]] = call float @llvm.fabs.f32(float %[[VAL_1326]])
// CHECK:         %[[VAL_1328:.*]] = call float @__nv_powf(float %[[VAL_1327]], float 0x3FD5555560000000)
// CHECK:         %[[VAL_1329:.*]] = call float @llvm.copysign.f32(float %[[VAL_1328]], float %[[VAL_1326]])
// CHECK:         %[[VAL_1330:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1298]] to float*
// CHECK:         %[[VAL_1331:.*]] = getelementptr inbounds float, float* %[[VAL_1330]], i32 %[[VAL_1304]]
// CHECK:         store float %[[VAL_1329]], float* %[[VAL_1331]], align 4
// CHECK:         %[[VAL_1332:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1295]] to float*
// CHECK:         %[[VAL_1333:.*]] = getelementptr inbounds float, float* %[[VAL_1332]], i32 %[[VAL_1308]]
// CHECK:         %[[VAL_1334:.*]] = load float, float* %[[VAL_1333]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1335:.*]] = call float @llvm.fabs.f32(float %[[VAL_1334]])
// CHECK:         %[[VAL_1336:.*]] = call float @__nv_powf(float %[[VAL_1335]], float 0x3FD5555560000000)
// CHECK:         %[[VAL_1337:.*]] = call float @llvm.copysign.f32(float %[[VAL_1336]], float %[[VAL_1334]])
// CHECK:         %[[VAL_1338:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1298]] to float*
// CHECK:         %[[VAL_1339:.*]] = getelementptr inbounds float, float* %[[VAL_1338]], i32 %[[VAL_1308]]
// CHECK:         store float %[[VAL_1337]], float* %[[VAL_1339]], align 4
// CHECK:         %[[VAL_1340:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1295]] to float*
// CHECK:         %[[VAL_1341:.*]] = getelementptr inbounds float, float* %[[VAL_1340]], i32 %[[VAL_1312]]
// CHECK:         %[[VAL_1342:.*]] = load float, float* %[[VAL_1341]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1343:.*]] = call float @llvm.fabs.f32(float %[[VAL_1342]])
// CHECK:         %[[VAL_1344:.*]] = call float @__nv_powf(float %[[VAL_1343]], float 0x3FD5555560000000)
// CHECK:         %[[VAL_1345:.*]] = call float @llvm.copysign.f32(float %[[VAL_1344]], float %[[VAL_1342]])
// CHECK:         %[[VAL_1346:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1298]] to float*
// CHECK:         %[[VAL_1347:.*]] = getelementptr inbounds float, float* %[[VAL_1346]], i32 %[[VAL_1312]]
// CHECK:         store float %[[VAL_1345]], float* %[[VAL_1347]], align 4
// CHECK:         %[[VAL_1348:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1295]] to float*
// CHECK:         %[[VAL_1349:.*]] = getelementptr inbounds float, float* %[[VAL_1348]], i32 %[[VAL_1316]]
// CHECK:         %[[VAL_1350:.*]] = load float, float* %[[VAL_1349]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1351:.*]] = call float @llvm.fabs.f32(float %[[VAL_1350]])
// CHECK:         %[[VAL_1352:.*]] = call float @__nv_powf(float %[[VAL_1351]], float 0x3FD5555560000000)
// CHECK:         %[[VAL_1353:.*]] = call float @llvm.copysign.f32(float %[[VAL_1352]], float %[[VAL_1350]])
// CHECK:         %[[VAL_1354:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1298]] to float*
// CHECK:         %[[VAL_1355:.*]] = getelementptr inbounds float, float* %[[VAL_1354]], i32 %[[VAL_1316]]
// CHECK:         store float %[[VAL_1353]], float* %[[VAL_1355]], align 4
// CHECK:         br label %[[VAL_1322]]
// CHECK:       entry:
// CHECK:         %[[VAL_1356:.*]] = getelementptr inbounds i8, i8* %[[VAL_1357:.*]], i64 0
// CHECK:         %[[VAL_1358:.*]] = bitcast i8* %[[VAL_1356]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1359:.*]] = getelementptr inbounds i8, i8* %[[VAL_1360:.*]], i64 0
// CHECK:         %[[VAL_1361:.*]] = bitcast i8* %[[VAL_1359]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1362:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1363:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1364:.*]] = mul nuw nsw i32 %[[VAL_1362]], 256
// CHECK:         %[[VAL_1365:.*]] = add nuw nsw i32 %[[VAL_1364]], %[[VAL_1363]]
// CHECK:         %[[VAL_1366:.*]] = icmp ult i32 %[[VAL_1365]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1366]])
// CHECK:         %[[VAL_1367:.*]] = mul nuw nsw i32 %[[VAL_1365]], 4
// CHECK:         %[[VAL_1368:.*]] = udiv i32 %[[VAL_1367]], 1
// CHECK:         %[[VAL_1369:.*]] = urem i32 %[[VAL_1368]], 200
// CHECK:         %[[VAL_1370:.*]] = udiv i32 %[[VAL_1367]], 200
// CHECK:         %[[VAL_1371:.*]] = add nuw nsw i32 %[[VAL_1367]], 1
// CHECK:         %[[VAL_1372:.*]] = udiv i32 %[[VAL_1371]], 1
// CHECK:         %[[VAL_1373:.*]] = urem i32 %[[VAL_1372]], 200
// CHECK:         %[[VAL_1374:.*]] = udiv i32 %[[VAL_1371]], 200
// CHECK:         %[[VAL_1375:.*]] = add nuw nsw i32 %[[VAL_1367]], 2
// CHECK:         %[[VAL_1376:.*]] = udiv i32 %[[VAL_1375]], 1
// CHECK:         %[[VAL_1377:.*]] = urem i32 %[[VAL_1376]], 200
// CHECK:         %[[VAL_1378:.*]] = udiv i32 %[[VAL_1375]], 200
// CHECK:         %[[VAL_1379:.*]] = add nuw nsw i32 %[[VAL_1367]], 3
// CHECK:         %[[VAL_1380:.*]] = udiv i32 %[[VAL_1379]], 1
// CHECK:         %[[VAL_1381:.*]] = urem i32 %[[VAL_1380]], 200
// CHECK:         %[[VAL_1382:.*]] = udiv i32 %[[VAL_1379]], 200
// CHECK:         %[[VAL_1383:.*]] = icmp ult i32 %[[VAL_1367]], 20000
// CHECK:         br i1 %[[VAL_1383]], label %[[VAL_1384:.*]], label %[[VAL_1385:.*]]
// CHECK:       r26.in_bounds-after:                              ; preds = %[[VAL_1384]], %[[VAL_1386:.*]]
// CHECK:         ret void
// CHECK:       r26.in_bounds-true:                               ; preds = %[[VAL_1386]]
// CHECK:         %[[VAL_1387:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1358]] to float*
// CHECK:         %[[VAL_1388:.*]] = getelementptr inbounds float, float* %[[VAL_1387]], i32 %[[VAL_1367]]
// CHECK:         %[[VAL_1389:.*]] = load float, float* %[[VAL_1388]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1390:.*]] = call float @llvm.fabs.f32(float %[[VAL_1389]])
// CHECK:         %[[VAL_1391:.*]] = call float @llvm.fabs.f32(float %[[VAL_1389]])
// CHECK:         %[[VAL_1392:.*]] = fcmp olt float %[[VAL_1391]], 0x3F3A36E2E0000000
// CHECK:         %[[VAL_1393:.*]] = fcmp uge float %[[VAL_1389]], -9.000000e+00
// CHECK:         %[[VAL_1394:.*]] = select i1 %[[VAL_1393]], float %[[VAL_1389]], float -9.000000e+00
// CHECK:         %[[VAL_1395:.*]] = fcmp ule float %[[VAL_1394]], 9.000000e+00
// CHECK:         %[[VAL_1396:.*]] = select i1 %[[VAL_1395]], float %[[VAL_1394]], float 9.000000e+00
// CHECK:         %[[VAL_1397:.*]] = fmul float %[[VAL_1396]], %[[VAL_1396]]
// CHECK:         %[[VAL_1398:.*]] = fmul float %[[VAL_1397]], 0xBCB3E4B800000000
// CHECK:         %[[VAL_1399:.*]] = fadd float %[[VAL_1398]], 0x3D4C266FC0000000
// CHECK:         %[[VAL_1400:.*]] = fmul float %[[VAL_1397]], %[[VAL_1399]]
// CHECK:         %[[VAL_1401:.*]] = fadd float %[[VAL_1400]], 0xBDD7A6FFE0000000
// CHECK:         %[[VAL_1402:.*]] = fmul float %[[VAL_1397]], %[[VAL_1401]]
// CHECK:         %[[VAL_1403:.*]] = fadd float %[[VAL_1402]], 0x3E6B800820000000
// CHECK:         %[[VAL_1404:.*]] = fmul float %[[VAL_1397]], %[[VAL_1403]]
// CHECK:         %[[VAL_1405:.*]] = fadd float %[[VAL_1404]], 0x3EEF286940000000
// CHECK:         %[[VAL_1406:.*]] = fmul float %[[VAL_1397]], %[[VAL_1405]]
// CHECK:         %[[VAL_1407:.*]] = fadd float %[[VAL_1406]], 0x3F44E1BDA0000000
// CHECK:         %[[VAL_1408:.*]] = fmul float %[[VAL_1397]], %[[VAL_1407]]
// CHECK:         %[[VAL_1409:.*]] = fadd float %[[VAL_1408]], 0x3F740B3B80000000
// CHECK:         %[[VAL_1410:.*]] = fmul float %[[VAL_1396]], %[[VAL_1409]]
// CHECK:         %[[VAL_1411:.*]] = fmul float %[[VAL_1397]], 0x3EB41A7B00000000
// CHECK:         %[[VAL_1412:.*]] = fadd float %[[VAL_1411]], 0x3F1F12BAC0000000
// CHECK:         %[[VAL_1413:.*]] = fmul float %[[VAL_1397]], %[[VAL_1412]]
// CHECK:         %[[VAL_1414:.*]] = fadd float %[[VAL_1413]], 0x3F629540A0000000
// CHECK:         %[[VAL_1415:.*]] = fmul float %[[VAL_1397]], %[[VAL_1414]]
// CHECK:         %[[VAL_1416:.*]] = fadd float %[[VAL_1415]], 0x3F740B3BA0000000
// CHECK:         %[[VAL_1417:.*]] = fdiv float %[[VAL_1410]], %[[VAL_1416]]
// CHECK:         %[[VAL_1418:.*]] = select i1 %[[VAL_1392]], float %[[VAL_1389]], float %[[VAL_1417]]
// CHECK:         %[[VAL_1419:.*]] = call float @llvm.copysign.f32(float 1.000000e+00, float %[[VAL_1389]])
// CHECK:         %[[VAL_1420:.*]] = fcmp ult float %[[VAL_1390]], 2.000000e+01
// CHECK:         %[[VAL_1421:.*]] = select i1 %[[VAL_1420]], float %[[VAL_1418]], float %[[VAL_1419]]
// CHECK:         %[[VAL_1422:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1361]] to float*
// CHECK:         %[[VAL_1423:.*]] = getelementptr inbounds float, float* %[[VAL_1422]], i32 %[[VAL_1367]]
// CHECK:         store float %[[VAL_1421]], float* %[[VAL_1423]], align 4
// CHECK:         %[[VAL_1424:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1358]] to float*
// CHECK:         %[[VAL_1425:.*]] = getelementptr inbounds float, float* %[[VAL_1424]], i32 %[[VAL_1371]]
// CHECK:         %[[VAL_1426:.*]] = load float, float* %[[VAL_1425]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1427:.*]] = call float @llvm.fabs.f32(float %[[VAL_1426]])
// CHECK:         %[[VAL_1428:.*]] = call float @llvm.fabs.f32(float %[[VAL_1426]])
// CHECK:         %[[VAL_1429:.*]] = fcmp olt float %[[VAL_1428]], 0x3F3A36E2E0000000
// CHECK:         %[[VAL_1430:.*]] = fcmp uge float %[[VAL_1426]], -9.000000e+00
// CHECK:         %[[VAL_1431:.*]] = select i1 %[[VAL_1430]], float %[[VAL_1426]], float -9.000000e+00
// CHECK:         %[[VAL_1432:.*]] = fcmp ule float %[[VAL_1431]], 9.000000e+00
// CHECK:         %[[VAL_1433:.*]] = select i1 %[[VAL_1432]], float %[[VAL_1431]], float 9.000000e+00
// CHECK:         %[[VAL_1434:.*]] = fmul float %[[VAL_1433]], %[[VAL_1433]]
// CHECK:         %[[VAL_1435:.*]] = fmul float %[[VAL_1434]], 0xBCB3E4B800000000
// CHECK:         %[[VAL_1436:.*]] = fadd float %[[VAL_1435]], 0x3D4C266FC0000000
// CHECK:         %[[VAL_1437:.*]] = fmul float %[[VAL_1434]], %[[VAL_1436]]
// CHECK:         %[[VAL_1438:.*]] = fadd float %[[VAL_1437]], 0xBDD7A6FFE0000000
// CHECK:         %[[VAL_1439:.*]] = fmul float %[[VAL_1434]], %[[VAL_1438]]
// CHECK:         %[[VAL_1440:.*]] = fadd float %[[VAL_1439]], 0x3E6B800820000000
// CHECK:         %[[VAL_1441:.*]] = fmul float %[[VAL_1434]], %[[VAL_1440]]
// CHECK:         %[[VAL_1442:.*]] = fadd float %[[VAL_1441]], 0x3EEF286940000000
// CHECK:         %[[VAL_1443:.*]] = fmul float %[[VAL_1434]], %[[VAL_1442]]
// CHECK:         %[[VAL_1444:.*]] = fadd float %[[VAL_1443]], 0x3F44E1BDA0000000
// CHECK:         %[[VAL_1445:.*]] = fmul float %[[VAL_1434]], %[[VAL_1444]]
// CHECK:         %[[VAL_1446:.*]] = fadd float %[[VAL_1445]], 0x3F740B3B80000000
// CHECK:         %[[VAL_1447:.*]] = fmul float %[[VAL_1433]], %[[VAL_1446]]
// CHECK:         %[[VAL_1448:.*]] = fmul float %[[VAL_1434]], 0x3EB41A7B00000000
// CHECK:         %[[VAL_1449:.*]] = fadd float %[[VAL_1448]], 0x3F1F12BAC0000000
// CHECK:         %[[VAL_1450:.*]] = fmul float %[[VAL_1434]], %[[VAL_1449]]
// CHECK:         %[[VAL_1451:.*]] = fadd float %[[VAL_1450]], 0x3F629540A0000000
// CHECK:         %[[VAL_1452:.*]] = fmul float %[[VAL_1434]], %[[VAL_1451]]
// CHECK:         %[[VAL_1453:.*]] = fadd float %[[VAL_1452]], 0x3F740B3BA0000000
// CHECK:         %[[VAL_1454:.*]] = fdiv float %[[VAL_1447]], %[[VAL_1453]]
// CHECK:         %[[VAL_1455:.*]] = select i1 %[[VAL_1429]], float %[[VAL_1426]], float %[[VAL_1454]]
// CHECK:         %[[VAL_1456:.*]] = call float @llvm.copysign.f32(float 1.000000e+00, float %[[VAL_1426]])
// CHECK:         %[[VAL_1457:.*]] = fcmp ult float %[[VAL_1427]], 2.000000e+01
// CHECK:         %[[VAL_1458:.*]] = select i1 %[[VAL_1457]], float %[[VAL_1455]], float %[[VAL_1456]]
// CHECK:         %[[VAL_1459:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1361]] to float*
// CHECK:         %[[VAL_1460:.*]] = getelementptr inbounds float, float* %[[VAL_1459]], i32 %[[VAL_1371]]
// CHECK:         store float %[[VAL_1458]], float* %[[VAL_1460]], align 4
// CHECK:         %[[VAL_1461:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1358]] to float*
// CHECK:         %[[VAL_1462:.*]] = getelementptr inbounds float, float* %[[VAL_1461]], i32 %[[VAL_1375]]
// CHECK:         %[[VAL_1463:.*]] = load float, float* %[[VAL_1462]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1464:.*]] = call float @llvm.fabs.f32(float %[[VAL_1463]])
// CHECK:         %[[VAL_1465:.*]] = call float @llvm.fabs.f32(float %[[VAL_1463]])
// CHECK:         %[[VAL_1466:.*]] = fcmp olt float %[[VAL_1465]], 0x3F3A36E2E0000000
// CHECK:         %[[VAL_1467:.*]] = fcmp uge float %[[VAL_1463]], -9.000000e+00
// CHECK:         %[[VAL_1468:.*]] = select i1 %[[VAL_1467]], float %[[VAL_1463]], float -9.000000e+00
// CHECK:         %[[VAL_1469:.*]] = fcmp ule float %[[VAL_1468]], 9.000000e+00
// CHECK:         %[[VAL_1470:.*]] = select i1 %[[VAL_1469]], float %[[VAL_1468]], float 9.000000e+00
// CHECK:         %[[VAL_1471:.*]] = fmul float %[[VAL_1470]], %[[VAL_1470]]
// CHECK:         %[[VAL_1472:.*]] = fmul float %[[VAL_1471]], 0xBCB3E4B800000000
// CHECK:         %[[VAL_1473:.*]] = fadd float %[[VAL_1472]], 0x3D4C266FC0000000
// CHECK:         %[[VAL_1474:.*]] = fmul float %[[VAL_1471]], %[[VAL_1473]]
// CHECK:         %[[VAL_1475:.*]] = fadd float %[[VAL_1474]], 0xBDD7A6FFE0000000
// CHECK:         %[[VAL_1476:.*]] = fmul float %[[VAL_1471]], %[[VAL_1475]]
// CHECK:         %[[VAL_1477:.*]] = fadd float %[[VAL_1476]], 0x3E6B800820000000
// CHECK:         %[[VAL_1478:.*]] = fmul float %[[VAL_1471]], %[[VAL_1477]]
// CHECK:         %[[VAL_1479:.*]] = fadd float %[[VAL_1478]], 0x3EEF286940000000
// CHECK:         %[[VAL_1480:.*]] = fmul float %[[VAL_1471]], %[[VAL_1479]]
// CHECK:         %[[VAL_1481:.*]] = fadd float %[[VAL_1480]], 0x3F44E1BDA0000000
// CHECK:         %[[VAL_1482:.*]] = fmul float %[[VAL_1471]], %[[VAL_1481]]
// CHECK:         %[[VAL_1483:.*]] = fadd float %[[VAL_1482]], 0x3F740B3B80000000
// CHECK:         %[[VAL_1484:.*]] = fmul float %[[VAL_1470]], %[[VAL_1483]]
// CHECK:         %[[VAL_1485:.*]] = fmul float %[[VAL_1471]], 0x3EB41A7B00000000
// CHECK:         %[[VAL_1486:.*]] = fadd float %[[VAL_1485]], 0x3F1F12BAC0000000
// CHECK:         %[[VAL_1487:.*]] = fmul float %[[VAL_1471]], %[[VAL_1486]]
// CHECK:         %[[VAL_1488:.*]] = fadd float %[[VAL_1487]], 0x3F629540A0000000
// CHECK:         %[[VAL_1489:.*]] = fmul float %[[VAL_1471]], %[[VAL_1488]]
// CHECK:         %[[VAL_1490:.*]] = fadd float %[[VAL_1489]], 0x3F740B3BA0000000
// CHECK:         %[[VAL_1491:.*]] = fdiv float %[[VAL_1484]], %[[VAL_1490]]
// CHECK:         %[[VAL_1492:.*]] = select i1 %[[VAL_1466]], float %[[VAL_1463]], float %[[VAL_1491]]
// CHECK:         %[[VAL_1493:.*]] = call float @llvm.copysign.f32(float 1.000000e+00, float %[[VAL_1463]])
// CHECK:         %[[VAL_1494:.*]] = fcmp ult float %[[VAL_1464]], 2.000000e+01
// CHECK:         %[[VAL_1495:.*]] = select i1 %[[VAL_1494]], float %[[VAL_1492]], float %[[VAL_1493]]
// CHECK:         %[[VAL_1496:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1361]] to float*
// CHECK:         %[[VAL_1497:.*]] = getelementptr inbounds float, float* %[[VAL_1496]], i32 %[[VAL_1375]]
// CHECK:         store float %[[VAL_1495]], float* %[[VAL_1497]], align 4
// CHECK:         %[[VAL_1498:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1358]] to float*
// CHECK:         %[[VAL_1499:.*]] = getelementptr inbounds float, float* %[[VAL_1498]], i32 %[[VAL_1379]]
// CHECK:         %[[VAL_1500:.*]] = load float, float* %[[VAL_1499]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1501:.*]] = call float @llvm.fabs.f32(float %[[VAL_1500]])
// CHECK:         %[[VAL_1502:.*]] = call float @llvm.fabs.f32(float %[[VAL_1500]])
// CHECK:         %[[VAL_1503:.*]] = fcmp olt float %[[VAL_1502]], 0x3F3A36E2E0000000
// CHECK:         %[[VAL_1504:.*]] = fcmp uge float %[[VAL_1500]], -9.000000e+00
// CHECK:         %[[VAL_1505:.*]] = select i1 %[[VAL_1504]], float %[[VAL_1500]], float -9.000000e+00
// CHECK:         %[[VAL_1506:.*]] = fcmp ule float %[[VAL_1505]], 9.000000e+00
// CHECK:         %[[VAL_1507:.*]] = select i1 %[[VAL_1506]], float %[[VAL_1505]], float 9.000000e+00
// CHECK:         %[[VAL_1508:.*]] = fmul float %[[VAL_1507]], %[[VAL_1507]]
// CHECK:         %[[VAL_1509:.*]] = fmul float %[[VAL_1508]], 0xBCB3E4B800000000
// CHECK:         %[[VAL_1510:.*]] = fadd float %[[VAL_1509]], 0x3D4C266FC0000000
// CHECK:         %[[VAL_1511:.*]] = fmul float %[[VAL_1508]], %[[VAL_1510]]
// CHECK:         %[[VAL_1512:.*]] = fadd float %[[VAL_1511]], 0xBDD7A6FFE0000000
// CHECK:         %[[VAL_1513:.*]] = fmul float %[[VAL_1508]], %[[VAL_1512]]
// CHECK:         %[[VAL_1514:.*]] = fadd float %[[VAL_1513]], 0x3E6B800820000000
// CHECK:         %[[VAL_1515:.*]] = fmul float %[[VAL_1508]], %[[VAL_1514]]
// CHECK:         %[[VAL_1516:.*]] = fadd float %[[VAL_1515]], 0x3EEF286940000000
// CHECK:         %[[VAL_1517:.*]] = fmul float %[[VAL_1508]], %[[VAL_1516]]
// CHECK:         %[[VAL_1518:.*]] = fadd float %[[VAL_1517]], 0x3F44E1BDA0000000
// CHECK:         %[[VAL_1519:.*]] = fmul float %[[VAL_1508]], %[[VAL_1518]]
// CHECK:         %[[VAL_1520:.*]] = fadd float %[[VAL_1519]], 0x3F740B3B80000000
// CHECK:         %[[VAL_1521:.*]] = fmul float %[[VAL_1507]], %[[VAL_1520]]
// CHECK:         %[[VAL_1522:.*]] = fmul float %[[VAL_1508]], 0x3EB41A7B00000000
// CHECK:         %[[VAL_1523:.*]] = fadd float %[[VAL_1522]], 0x3F1F12BAC0000000
// CHECK:         %[[VAL_1524:.*]] = fmul float %[[VAL_1508]], %[[VAL_1523]]
// CHECK:         %[[VAL_1525:.*]] = fadd float %[[VAL_1524]], 0x3F629540A0000000
// CHECK:         %[[VAL_1526:.*]] = fmul float %[[VAL_1508]], %[[VAL_1525]]
// CHECK:         %[[VAL_1527:.*]] = fadd float %[[VAL_1526]], 0x3F740B3BA0000000
// CHECK:         %[[VAL_1528:.*]] = fdiv float %[[VAL_1521]], %[[VAL_1527]]
// CHECK:         %[[VAL_1529:.*]] = select i1 %[[VAL_1503]], float %[[VAL_1500]], float %[[VAL_1528]]
// CHECK:         %[[VAL_1530:.*]] = call float @llvm.copysign.f32(float 1.000000e+00, float %[[VAL_1500]])
// CHECK:         %[[VAL_1531:.*]] = fcmp ult float %[[VAL_1501]], 2.000000e+01
// CHECK:         %[[VAL_1532:.*]] = select i1 %[[VAL_1531]], float %[[VAL_1529]], float %[[VAL_1530]]
// CHECK:         %[[VAL_1533:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1361]] to float*
// CHECK:         %[[VAL_1534:.*]] = getelementptr inbounds float, float* %[[VAL_1533]], i32 %[[VAL_1379]]
// CHECK:         store float %[[VAL_1532]], float* %[[VAL_1534]], align 4
// CHECK:         br label %[[VAL_1385]]
// CHECK:       entry:
// CHECK:         %[[VAL_1535:.*]] = getelementptr inbounds i8, i8* %[[VAL_1536:.*]], i64 0
// CHECK:         %[[VAL_1537:.*]] = bitcast i8* %[[VAL_1535]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1538:.*]] = getelementptr inbounds i8, i8* %[[VAL_1539:.*]], i64 0
// CHECK:         %[[VAL_1540:.*]] = bitcast i8* %[[VAL_1538]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1541:.*]] = getelementptr inbounds i8, i8* %[[VAL_1542:.*]], i64 0
// CHECK:         %[[VAL_1543:.*]] = bitcast i8* %[[VAL_1541]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1544:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1545:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1546:.*]] = mul nuw nsw i32 %[[VAL_1544]], 256
// CHECK:         %[[VAL_1547:.*]] = add nuw nsw i32 %[[VAL_1546]], %[[VAL_1545]]
// CHECK:         %[[VAL_1548:.*]] = icmp ult i32 %[[VAL_1547]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1548]])
// CHECK:         %[[VAL_1549:.*]] = mul nuw nsw i32 %[[VAL_1547]], 4
// CHECK:         %[[VAL_1550:.*]] = udiv i32 %[[VAL_1549]], 1
// CHECK:         %[[VAL_1551:.*]] = urem i32 %[[VAL_1550]], 200
// CHECK:         %[[VAL_1552:.*]] = udiv i32 %[[VAL_1549]], 200
// CHECK:         %[[VAL_1553:.*]] = add nuw nsw i32 %[[VAL_1549]], 1
// CHECK:         %[[VAL_1554:.*]] = udiv i32 %[[VAL_1553]], 1
// CHECK:         %[[VAL_1555:.*]] = urem i32 %[[VAL_1554]], 200
// CHECK:         %[[VAL_1556:.*]] = udiv i32 %[[VAL_1553]], 200
// CHECK:         %[[VAL_1557:.*]] = add nuw nsw i32 %[[VAL_1549]], 2
// CHECK:         %[[VAL_1558:.*]] = udiv i32 %[[VAL_1557]], 1
// CHECK:         %[[VAL_1559:.*]] = urem i32 %[[VAL_1558]], 200
// CHECK:         %[[VAL_1560:.*]] = udiv i32 %[[VAL_1557]], 200
// CHECK:         %[[VAL_1561:.*]] = add nuw nsw i32 %[[VAL_1549]], 3
// CHECK:         %[[VAL_1562:.*]] = udiv i32 %[[VAL_1561]], 1
// CHECK:         %[[VAL_1563:.*]] = urem i32 %[[VAL_1562]], 200
// CHECK:         %[[VAL_1564:.*]] = udiv i32 %[[VAL_1561]], 200
// CHECK:         %[[VAL_1565:.*]] = icmp ult i32 %[[VAL_1549]], 20000
// CHECK:         br i1 %[[VAL_1565]], label %[[VAL_1566:.*]], label %[[VAL_1567:.*]]
// CHECK:       r27.in_bounds-after:                              ; preds = %[[VAL_1566]], %[[VAL_1568:.*]]
// CHECK:         ret void
// CHECK:       r27.in_bounds-true:                               ; preds = %[[VAL_1568]]
// CHECK:         %[[VAL_1569:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1537]] to float*
// CHECK:         %[[VAL_1570:.*]] = getelementptr inbounds float, float* %[[VAL_1569]], i32 %[[VAL_1549]]
// CHECK:         %[[VAL_1571:.*]] = load float, float* %[[VAL_1570]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1572:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1540]] to float*
// CHECK:         %[[VAL_1573:.*]] = getelementptr inbounds float, float* %[[VAL_1572]], i32 %[[VAL_1549]]
// CHECK:         %[[VAL_1574:.*]] = load float, float* %[[VAL_1573]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1575:.*]] = fadd float %[[VAL_1571]], %[[VAL_1574]]
// CHECK:         %[[VAL_1576:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1543]] to float*
// CHECK:         %[[VAL_1577:.*]] = getelementptr inbounds float, float* %[[VAL_1576]], i32 %[[VAL_1549]]
// CHECK:         store float %[[VAL_1575]], float* %[[VAL_1577]], align 4
// CHECK:         %[[VAL_1578:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1537]] to float*
// CHECK:         %[[VAL_1579:.*]] = getelementptr inbounds float, float* %[[VAL_1578]], i32 %[[VAL_1553]]
// CHECK:         %[[VAL_1580:.*]] = load float, float* %[[VAL_1579]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1581:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1540]] to float*
// CHECK:         %[[VAL_1582:.*]] = getelementptr inbounds float, float* %[[VAL_1581]], i32 %[[VAL_1553]]
// CHECK:         %[[VAL_1583:.*]] = load float, float* %[[VAL_1582]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1584:.*]] = fadd float %[[VAL_1580]], %[[VAL_1583]]
// CHECK:         %[[VAL_1585:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1543]] to float*
// CHECK:         %[[VAL_1586:.*]] = getelementptr inbounds float, float* %[[VAL_1585]], i32 %[[VAL_1553]]
// CHECK:         store float %[[VAL_1584]], float* %[[VAL_1586]], align 4
// CHECK:         %[[VAL_1587:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1537]] to float*
// CHECK:         %[[VAL_1588:.*]] = getelementptr inbounds float, float* %[[VAL_1587]], i32 %[[VAL_1557]]
// CHECK:         %[[VAL_1589:.*]] = load float, float* %[[VAL_1588]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1590:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1540]] to float*
// CHECK:         %[[VAL_1591:.*]] = getelementptr inbounds float, float* %[[VAL_1590]], i32 %[[VAL_1557]]
// CHECK:         %[[VAL_1592:.*]] = load float, float* %[[VAL_1591]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1593:.*]] = fadd float %[[VAL_1589]], %[[VAL_1592]]
// CHECK:         %[[VAL_1594:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1543]] to float*
// CHECK:         %[[VAL_1595:.*]] = getelementptr inbounds float, float* %[[VAL_1594]], i32 %[[VAL_1557]]
// CHECK:         store float %[[VAL_1593]], float* %[[VAL_1595]], align 4
// CHECK:         %[[VAL_1596:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1537]] to float*
// CHECK:         %[[VAL_1597:.*]] = getelementptr inbounds float, float* %[[VAL_1596]], i32 %[[VAL_1561]]
// CHECK:         %[[VAL_1598:.*]] = load float, float* %[[VAL_1597]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1599:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1540]] to float*
// CHECK:         %[[VAL_1600:.*]] = getelementptr inbounds float, float* %[[VAL_1599]], i32 %[[VAL_1561]]
// CHECK:         %[[VAL_1601:.*]] = load float, float* %[[VAL_1600]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1602:.*]] = fadd float %[[VAL_1598]], %[[VAL_1601]]
// CHECK:         %[[VAL_1603:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1543]] to float*
// CHECK:         %[[VAL_1604:.*]] = getelementptr inbounds float, float* %[[VAL_1603]], i32 %[[VAL_1561]]
// CHECK:         store float %[[VAL_1602]], float* %[[VAL_1604]], align 4
// CHECK:         br label %[[VAL_1567]]
// CHECK:       entry:
// CHECK:         %[[VAL_1605:.*]] = getelementptr inbounds i8, i8* %[[VAL_1606:.*]], i64 0
// CHECK:         %[[VAL_1607:.*]] = bitcast i8* %[[VAL_1605]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1608:.*]] = getelementptr inbounds i8, i8* %[[VAL_1609:.*]], i64 0
// CHECK:         %[[VAL_1610:.*]] = bitcast i8* %[[VAL_1608]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1611:.*]] = getelementptr inbounds i8, i8* %[[VAL_1612:.*]], i64 0
// CHECK:         %[[VAL_1613:.*]] = bitcast i8* %[[VAL_1611]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1614:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1615:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !95
// CHECK:         %[[VAL_1616:.*]] = mul nuw nsw i32 %[[VAL_1614]], 1024
// CHECK:         %[[VAL_1617:.*]] = add nuw nsw i32 %[[VAL_1616]], %[[VAL_1615]]
// CHECK:         %[[VAL_1618:.*]] = icmp ult i32 %[[VAL_1617]], 20480
// CHECK:         call void @llvm.assume(i1 %[[VAL_1618]])
// CHECK:         %[[VAL_1619:.*]] = udiv i32 %[[VAL_1617]], 1
// CHECK:         %[[VAL_1620:.*]] = urem i32 %[[VAL_1619]], 200
// CHECK:         %[[VAL_1621:.*]] = udiv i32 %[[VAL_1617]], 200
// CHECK:         %[[VAL_1622:.*]] = icmp ult i32 %[[VAL_1617]], 20000
// CHECK:         br i1 %[[VAL_1622]], label %[[VAL_1623:.*]], label %[[VAL_1624:.*]]
// CHECK:       r28.in_bounds-after:                              ; preds = %[[VAL_1623]], %[[VAL_1625:.*]]
// CHECK:         ret void
// CHECK:       r28.in_bounds-true:                               ; preds = %[[VAL_1625]]
// CHECK:         %[[VAL_1626:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1607]] to float*
// CHECK:         %[[VAL_1627:.*]] = getelementptr inbounds float, float* %[[VAL_1626]], i32 %[[VAL_1617]]
// CHECK:         %[[VAL_1628:.*]] = load float, float* %[[VAL_1627]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1629:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1610]] to float*
// CHECK:         %[[VAL_1630:.*]] = getelementptr inbounds float, float* %[[VAL_1629]], i32 %[[VAL_1617]]
// CHECK:         %[[VAL_1631:.*]] = load float, float* %[[VAL_1630]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1632:.*]] = call float @__nv_atan2f(float %[[VAL_1628]], float %[[VAL_1631]])
// CHECK:         %[[VAL_1633:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1613]] to float*
// CHECK:         %[[VAL_1634:.*]] = getelementptr inbounds float, float* %[[VAL_1633]], i32 %[[VAL_1617]]
// CHECK:         store float %[[VAL_1632]], float* %[[VAL_1634]], align 4
// CHECK:         br label %[[VAL_1624]]
// CHECK:       entry:
// CHECK:         %[[VAL_1635:.*]] = getelementptr inbounds i8, i8* %[[VAL_1636:.*]], i64 0
// CHECK:         %[[VAL_1637:.*]] = bitcast i8* %[[VAL_1635]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1638:.*]] = getelementptr inbounds i8, i8* %[[VAL_1639:.*]], i64 0
// CHECK:         %[[VAL_1640:.*]] = bitcast i8* %[[VAL_1638]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1641:.*]] = getelementptr inbounds i8, i8* %[[VAL_1642:.*]], i64 0
// CHECK:         %[[VAL_1643:.*]] = bitcast i8* %[[VAL_1641]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_1644:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1645:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1646:.*]] = mul nuw nsw i32 %[[VAL_1644]], 256
// CHECK:         %[[VAL_1647:.*]] = add nuw nsw i32 %[[VAL_1646]], %[[VAL_1645]]
// CHECK:         %[[VAL_1648:.*]] = icmp ult i32 %[[VAL_1647]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1648]])
// CHECK:         %[[VAL_1649:.*]] = mul nuw nsw i32 %[[VAL_1647]], 4
// CHECK:         %[[VAL_1650:.*]] = udiv i32 %[[VAL_1649]], 1
// CHECK:         %[[VAL_1651:.*]] = urem i32 %[[VAL_1650]], 200
// CHECK:         %[[VAL_1652:.*]] = udiv i32 %[[VAL_1649]], 200
// CHECK:         %[[VAL_1653:.*]] = add nuw nsw i32 %[[VAL_1649]], 1
// CHECK:         %[[VAL_1654:.*]] = udiv i32 %[[VAL_1653]], 1
// CHECK:         %[[VAL_1655:.*]] = urem i32 %[[VAL_1654]], 200
// CHECK:         %[[VAL_1656:.*]] = udiv i32 %[[VAL_1653]], 200
// CHECK:         %[[VAL_1657:.*]] = add nuw nsw i32 %[[VAL_1649]], 2
// CHECK:         %[[VAL_1658:.*]] = udiv i32 %[[VAL_1657]], 1
// CHECK:         %[[VAL_1659:.*]] = urem i32 %[[VAL_1658]], 200
// CHECK:         %[[VAL_1660:.*]] = udiv i32 %[[VAL_1657]], 200
// CHECK:         %[[VAL_1661:.*]] = add nuw nsw i32 %[[VAL_1649]], 3
// CHECK:         %[[VAL_1662:.*]] = udiv i32 %[[VAL_1661]], 1
// CHECK:         %[[VAL_1663:.*]] = urem i32 %[[VAL_1662]], 200
// CHECK:         %[[VAL_1664:.*]] = udiv i32 %[[VAL_1661]], 200
// CHECK:         %[[VAL_1665:.*]] = icmp ult i32 %[[VAL_1649]], 20000
// CHECK:         br i1 %[[VAL_1665]], label %[[VAL_1666:.*]], label %[[VAL_1667:.*]]
// CHECK:       r29.in_bounds-after:                              ; preds = %[[VAL_1666]], %[[VAL_1668:.*]]
// CHECK:         ret void
// CHECK:       r29.in_bounds-true:                               ; preds = %[[VAL_1668]]
// CHECK:         %[[VAL_1669:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1637]] to float*
// CHECK:         %[[VAL_1670:.*]] = getelementptr inbounds float, float* %[[VAL_1669]], i32 %[[VAL_1649]]
// CHECK:         %[[VAL_1671:.*]] = load float, float* %[[VAL_1670]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1672:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1640]] to float*
// CHECK:         %[[VAL_1673:.*]] = getelementptr inbounds float, float* %[[VAL_1672]], i32 %[[VAL_1649]]
// CHECK:         %[[VAL_1674:.*]] = load float, float* %[[VAL_1673]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1675:.*]] = fcmp oeq float %[[VAL_1671]], %[[VAL_1674]]
// CHECK:         %[[VAL_1676:.*]] = zext i1 %[[VAL_1675]] to i8
// CHECK:         %[[VAL_1677:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_1643]] to i8*
// CHECK:         %[[VAL_1678:.*]] = getelementptr inbounds i8, i8* %[[VAL_1677]], i32 %[[VAL_1649]]
// CHECK:         store i8 %[[VAL_1676]], i8* %[[VAL_1678]], align 1
// CHECK:         %[[VAL_1679:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1637]] to float*
// CHECK:         %[[VAL_1680:.*]] = getelementptr inbounds float, float* %[[VAL_1679]], i32 %[[VAL_1653]]
// CHECK:         %[[VAL_1681:.*]] = load float, float* %[[VAL_1680]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1682:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1640]] to float*
// CHECK:         %[[VAL_1683:.*]] = getelementptr inbounds float, float* %[[VAL_1682]], i32 %[[VAL_1653]]
// CHECK:         %[[VAL_1684:.*]] = load float, float* %[[VAL_1683]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1685:.*]] = fcmp oeq float %[[VAL_1681]], %[[VAL_1684]]
// CHECK:         %[[VAL_1686:.*]] = zext i1 %[[VAL_1685]] to i8
// CHECK:         %[[VAL_1687:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_1643]] to i8*
// CHECK:         %[[VAL_1688:.*]] = getelementptr inbounds i8, i8* %[[VAL_1687]], i32 %[[VAL_1653]]
// CHECK:         store i8 %[[VAL_1686]], i8* %[[VAL_1688]], align 1
// CHECK:         %[[VAL_1689:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1637]] to float*
// CHECK:         %[[VAL_1690:.*]] = getelementptr inbounds float, float* %[[VAL_1689]], i32 %[[VAL_1657]]
// CHECK:         %[[VAL_1691:.*]] = load float, float* %[[VAL_1690]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1692:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1640]] to float*
// CHECK:         %[[VAL_1693:.*]] = getelementptr inbounds float, float* %[[VAL_1692]], i32 %[[VAL_1657]]
// CHECK:         %[[VAL_1694:.*]] = load float, float* %[[VAL_1693]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1695:.*]] = fcmp oeq float %[[VAL_1691]], %[[VAL_1694]]
// CHECK:         %[[VAL_1696:.*]] = zext i1 %[[VAL_1695]] to i8
// CHECK:         %[[VAL_1697:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_1643]] to i8*
// CHECK:         %[[VAL_1698:.*]] = getelementptr inbounds i8, i8* %[[VAL_1697]], i32 %[[VAL_1657]]
// CHECK:         store i8 %[[VAL_1696]], i8* %[[VAL_1698]], align 1
// CHECK:         %[[VAL_1699:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1637]] to float*
// CHECK:         %[[VAL_1700:.*]] = getelementptr inbounds float, float* %[[VAL_1699]], i32 %[[VAL_1661]]
// CHECK:         %[[VAL_1701:.*]] = load float, float* %[[VAL_1700]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1702:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1640]] to float*
// CHECK:         %[[VAL_1703:.*]] = getelementptr inbounds float, float* %[[VAL_1702]], i32 %[[VAL_1661]]
// CHECK:         %[[VAL_1704:.*]] = load float, float* %[[VAL_1703]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1705:.*]] = fcmp oeq float %[[VAL_1701]], %[[VAL_1704]]
// CHECK:         %[[VAL_1706:.*]] = zext i1 %[[VAL_1705]] to i8
// CHECK:         %[[VAL_1707:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_1643]] to i8*
// CHECK:         %[[VAL_1708:.*]] = getelementptr inbounds i8, i8* %[[VAL_1707]], i32 %[[VAL_1661]]
// CHECK:         store i8 %[[VAL_1706]], i8* %[[VAL_1708]], align 1
// CHECK:         br label %[[VAL_1667]]
// CHECK:       entry:
// CHECK:         %[[VAL_1709:.*]] = getelementptr inbounds i8, i8* %[[VAL_1710:.*]], i64 0
// CHECK:         %[[VAL_1711:.*]] = bitcast i8* %[[VAL_1709]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1712:.*]] = getelementptr inbounds i8, i8* %[[VAL_1713:.*]], i64 0
// CHECK:         %[[VAL_1714:.*]] = bitcast i8* %[[VAL_1712]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1715:.*]] = getelementptr inbounds i8, i8* %[[VAL_1716:.*]], i64 0
// CHECK:         %[[VAL_1717:.*]] = bitcast i8* %[[VAL_1715]] to [100 x [200 x %[[VAL_1718:.*]]]]*
// CHECK:         %[[VAL_1719:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1720:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1721:.*]] = mul nuw nsw i32 %[[VAL_1719]], 256
// CHECK:         %[[VAL_1722:.*]] = add nuw nsw i32 %[[VAL_1721]], %[[VAL_1720]]
// CHECK:         %[[VAL_1723:.*]] = icmp ult i32 %[[VAL_1722]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1723]])
// CHECK:         %[[VAL_1724:.*]] = mul nuw nsw i32 %[[VAL_1722]], 4
// CHECK:         %[[VAL_1725:.*]] = udiv i32 %[[VAL_1724]], 1
// CHECK:         %[[VAL_1726:.*]] = urem i32 %[[VAL_1725]], 200
// CHECK:         %[[VAL_1727:.*]] = udiv i32 %[[VAL_1724]], 200
// CHECK:         %[[VAL_1728:.*]] = add nuw nsw i32 %[[VAL_1724]], 1
// CHECK:         %[[VAL_1729:.*]] = udiv i32 %[[VAL_1728]], 1
// CHECK:         %[[VAL_1730:.*]] = urem i32 %[[VAL_1729]], 200
// CHECK:         %[[VAL_1731:.*]] = udiv i32 %[[VAL_1728]], 200
// CHECK:         %[[VAL_1732:.*]] = add nuw nsw i32 %[[VAL_1724]], 2
// CHECK:         %[[VAL_1733:.*]] = udiv i32 %[[VAL_1732]], 1
// CHECK:         %[[VAL_1734:.*]] = urem i32 %[[VAL_1733]], 200
// CHECK:         %[[VAL_1735:.*]] = udiv i32 %[[VAL_1732]], 200
// CHECK:         %[[VAL_1736:.*]] = add nuw nsw i32 %[[VAL_1724]], 3
// CHECK:         %[[VAL_1737:.*]] = udiv i32 %[[VAL_1736]], 1
// CHECK:         %[[VAL_1738:.*]] = urem i32 %[[VAL_1737]], 200
// CHECK:         %[[VAL_1739:.*]] = udiv i32 %[[VAL_1736]], 200
// CHECK:         %[[VAL_1740:.*]] = icmp ult i32 %[[VAL_1724]], 20000
// CHECK:         br i1 %[[VAL_1740]], label %[[VAL_1741:.*]], label %[[VAL_1742:.*]]
// CHECK:       r30.in_bounds-after:                              ; preds = %[[VAL_1741]], %[[VAL_1743:.*]]
// CHECK:         ret void
// CHECK:       r30.in_bounds-true:                               ; preds = %[[VAL_1743]]
// CHECK:         %[[VAL_1744:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1711]] to float*
// CHECK:         %[[VAL_1745:.*]] = getelementptr inbounds float, float* %[[VAL_1744]], i32 %[[VAL_1724]]
// CHECK:         %[[VAL_1746:.*]] = load float, float* %[[VAL_1745]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1747:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1714]] to float*
// CHECK:         %[[VAL_1748:.*]] = getelementptr inbounds float, float* %[[VAL_1747]], i32 %[[VAL_1724]]
// CHECK:         %[[VAL_1749:.*]] = load float, float* %[[VAL_1748]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1750:.*]] = insertvalue %[[VAL_1718]] zeroinitializer, float %[[VAL_1746]], 0
// CHECK:         %[[VAL_1751:.*]] = insertvalue %[[VAL_1718]] %[[VAL_1750]], float %[[VAL_1749]], 1
// CHECK:         %[[VAL_1752:.*]] = bitcast [100 x [200 x %[[VAL_1718]]]]* %[[VAL_1717]] to %[[VAL_1718]]*
// CHECK:         %[[VAL_1753:.*]] = getelementptr inbounds %[[VAL_1718]], %[[VAL_1718]]* %[[VAL_1752]], i32 %[[VAL_1724]]
// CHECK:         store %[[VAL_1718]] %[[VAL_1751]], %[[VAL_1718]]* %[[VAL_1753]], align 1
// CHECK:         %[[VAL_1754:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1711]] to float*
// CHECK:         %[[VAL_1755:.*]] = getelementptr inbounds float, float* %[[VAL_1754]], i32 %[[VAL_1728]]
// CHECK:         %[[VAL_1756:.*]] = load float, float* %[[VAL_1755]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1757:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1714]] to float*
// CHECK:         %[[VAL_1758:.*]] = getelementptr inbounds float, float* %[[VAL_1757]], i32 %[[VAL_1728]]
// CHECK:         %[[VAL_1759:.*]] = load float, float* %[[VAL_1758]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1760:.*]] = insertvalue %[[VAL_1718]] zeroinitializer, float %[[VAL_1756]], 0
// CHECK:         %[[VAL_1761:.*]] = insertvalue %[[VAL_1718]] %[[VAL_1760]], float %[[VAL_1759]], 1
// CHECK:         %[[VAL_1762:.*]] = bitcast [100 x [200 x %[[VAL_1718]]]]* %[[VAL_1717]] to %[[VAL_1718]]*
// CHECK:         %[[VAL_1763:.*]] = getelementptr inbounds %[[VAL_1718]], %[[VAL_1718]]* %[[VAL_1762]], i32 %[[VAL_1728]]
// CHECK:         store %[[VAL_1718]] %[[VAL_1761]], %[[VAL_1718]]* %[[VAL_1763]], align 1
// CHECK:         %[[VAL_1764:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1711]] to float*
// CHECK:         %[[VAL_1765:.*]] = getelementptr inbounds float, float* %[[VAL_1764]], i32 %[[VAL_1732]]
// CHECK:         %[[VAL_1766:.*]] = load float, float* %[[VAL_1765]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1767:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1714]] to float*
// CHECK:         %[[VAL_1768:.*]] = getelementptr inbounds float, float* %[[VAL_1767]], i32 %[[VAL_1732]]
// CHECK:         %[[VAL_1769:.*]] = load float, float* %[[VAL_1768]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1770:.*]] = insertvalue %[[VAL_1718]] zeroinitializer, float %[[VAL_1766]], 0
// CHECK:         %[[VAL_1771:.*]] = insertvalue %[[VAL_1718]] %[[VAL_1770]], float %[[VAL_1769]], 1
// CHECK:         %[[VAL_1772:.*]] = bitcast [100 x [200 x %[[VAL_1718]]]]* %[[VAL_1717]] to %[[VAL_1718]]*
// CHECK:         %[[VAL_1773:.*]] = getelementptr inbounds %[[VAL_1718]], %[[VAL_1718]]* %[[VAL_1772]], i32 %[[VAL_1732]]
// CHECK:         store %[[VAL_1718]] %[[VAL_1771]], %[[VAL_1718]]* %[[VAL_1773]], align 1
// CHECK:         %[[VAL_1774:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1711]] to float*
// CHECK:         %[[VAL_1775:.*]] = getelementptr inbounds float, float* %[[VAL_1774]], i32 %[[VAL_1736]]
// CHECK:         %[[VAL_1776:.*]] = load float, float* %[[VAL_1775]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1777:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1714]] to float*
// CHECK:         %[[VAL_1778:.*]] = getelementptr inbounds float, float* %[[VAL_1777]], i32 %[[VAL_1736]]
// CHECK:         %[[VAL_1779:.*]] = load float, float* %[[VAL_1778]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1780:.*]] = insertvalue %[[VAL_1718]] zeroinitializer, float %[[VAL_1776]], 0
// CHECK:         %[[VAL_1781:.*]] = insertvalue %[[VAL_1718]] %[[VAL_1780]], float %[[VAL_1779]], 1
// CHECK:         %[[VAL_1782:.*]] = bitcast [100 x [200 x %[[VAL_1718]]]]* %[[VAL_1717]] to %[[VAL_1718]]*
// CHECK:         %[[VAL_1783:.*]] = getelementptr inbounds %[[VAL_1718]], %[[VAL_1718]]* %[[VAL_1782]], i32 %[[VAL_1736]]
// CHECK:         store %[[VAL_1718]] %[[VAL_1781]], %[[VAL_1718]]* %[[VAL_1783]], align 1
// CHECK:         br label %[[VAL_1742]]
// CHECK:       entry:
// CHECK:         %[[VAL_1784:.*]] = getelementptr inbounds i8, i8* %[[VAL_1785:.*]], i64 0
// CHECK:         %[[VAL_1786:.*]] = bitcast i8* %[[VAL_1784]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1787:.*]] = getelementptr inbounds i8, i8* %[[VAL_1788:.*]], i64 0
// CHECK:         %[[VAL_1789:.*]] = bitcast i8* %[[VAL_1787]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1790:.*]] = getelementptr inbounds i8, i8* %[[VAL_1791:.*]], i64 0
// CHECK:         %[[VAL_1792:.*]] = bitcast i8* %[[VAL_1790]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1793:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1794:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1795:.*]] = mul nuw nsw i32 %[[VAL_1793]], 256
// CHECK:         %[[VAL_1796:.*]] = add nuw nsw i32 %[[VAL_1795]], %[[VAL_1794]]
// CHECK:         %[[VAL_1797:.*]] = icmp ult i32 %[[VAL_1796]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1797]])
// CHECK:         %[[VAL_1798:.*]] = mul nuw nsw i32 %[[VAL_1796]], 4
// CHECK:         %[[VAL_1799:.*]] = udiv i32 %[[VAL_1798]], 1
// CHECK:         %[[VAL_1800:.*]] = urem i32 %[[VAL_1799]], 200
// CHECK:         %[[VAL_1801:.*]] = udiv i32 %[[VAL_1798]], 200
// CHECK:         %[[VAL_1802:.*]] = add nuw nsw i32 %[[VAL_1798]], 1
// CHECK:         %[[VAL_1803:.*]] = udiv i32 %[[VAL_1802]], 1
// CHECK:         %[[VAL_1804:.*]] = urem i32 %[[VAL_1803]], 200
// CHECK:         %[[VAL_1805:.*]] = udiv i32 %[[VAL_1802]], 200
// CHECK:         %[[VAL_1806:.*]] = add nuw nsw i32 %[[VAL_1798]], 2
// CHECK:         %[[VAL_1807:.*]] = udiv i32 %[[VAL_1806]], 1
// CHECK:         %[[VAL_1808:.*]] = urem i32 %[[VAL_1807]], 200
// CHECK:         %[[VAL_1809:.*]] = udiv i32 %[[VAL_1806]], 200
// CHECK:         %[[VAL_1810:.*]] = add nuw nsw i32 %[[VAL_1798]], 3
// CHECK:         %[[VAL_1811:.*]] = udiv i32 %[[VAL_1810]], 1
// CHECK:         %[[VAL_1812:.*]] = urem i32 %[[VAL_1811]], 200
// CHECK:         %[[VAL_1813:.*]] = udiv i32 %[[VAL_1810]], 200
// CHECK:         %[[VAL_1814:.*]] = icmp ult i32 %[[VAL_1798]], 20000
// CHECK:         br i1 %[[VAL_1814]], label %[[VAL_1815:.*]], label %[[VAL_1816:.*]]
// CHECK:       r31.in_bounds-after:                              ; preds = %[[VAL_1815]], %[[VAL_1817:.*]]
// CHECK:         ret void
// CHECK:       r31.in_bounds-true:                               ; preds = %[[VAL_1817]]
// CHECK:         %[[VAL_1818:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1786]] to float*
// CHECK:         %[[VAL_1819:.*]] = getelementptr inbounds float, float* %[[VAL_1818]], i32 %[[VAL_1798]]
// CHECK:         %[[VAL_1820:.*]] = load float, float* %[[VAL_1819]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1821:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1789]] to float*
// CHECK:         %[[VAL_1822:.*]] = getelementptr inbounds float, float* %[[VAL_1821]], i32 %[[VAL_1798]]
// CHECK:         %[[VAL_1823:.*]] = load float, float* %[[VAL_1822]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1824:.*]] = fdiv float %[[VAL_1820]], %[[VAL_1823]]
// CHECK:         %[[VAL_1825:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1792]] to float*
// CHECK:         %[[VAL_1826:.*]] = getelementptr inbounds float, float* %[[VAL_1825]], i32 %[[VAL_1798]]
// CHECK:         store float %[[VAL_1824]], float* %[[VAL_1826]], align 4
// CHECK:         %[[VAL_1827:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1786]] to float*
// CHECK:         %[[VAL_1828:.*]] = getelementptr inbounds float, float* %[[VAL_1827]], i32 %[[VAL_1802]]
// CHECK:         %[[VAL_1829:.*]] = load float, float* %[[VAL_1828]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1830:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1789]] to float*
// CHECK:         %[[VAL_1831:.*]] = getelementptr inbounds float, float* %[[VAL_1830]], i32 %[[VAL_1802]]
// CHECK:         %[[VAL_1832:.*]] = load float, float* %[[VAL_1831]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1833:.*]] = fdiv float %[[VAL_1829]], %[[VAL_1832]]
// CHECK:         %[[VAL_1834:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1792]] to float*
// CHECK:         %[[VAL_1835:.*]] = getelementptr inbounds float, float* %[[VAL_1834]], i32 %[[VAL_1802]]
// CHECK:         store float %[[VAL_1833]], float* %[[VAL_1835]], align 4
// CHECK:         %[[VAL_1836:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1786]] to float*
// CHECK:         %[[VAL_1837:.*]] = getelementptr inbounds float, float* %[[VAL_1836]], i32 %[[VAL_1806]]
// CHECK:         %[[VAL_1838:.*]] = load float, float* %[[VAL_1837]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1839:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1789]] to float*
// CHECK:         %[[VAL_1840:.*]] = getelementptr inbounds float, float* %[[VAL_1839]], i32 %[[VAL_1806]]
// CHECK:         %[[VAL_1841:.*]] = load float, float* %[[VAL_1840]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1842:.*]] = fdiv float %[[VAL_1838]], %[[VAL_1841]]
// CHECK:         %[[VAL_1843:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1792]] to float*
// CHECK:         %[[VAL_1844:.*]] = getelementptr inbounds float, float* %[[VAL_1843]], i32 %[[VAL_1806]]
// CHECK:         store float %[[VAL_1842]], float* %[[VAL_1844]], align 4
// CHECK:         %[[VAL_1845:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1786]] to float*
// CHECK:         %[[VAL_1846:.*]] = getelementptr inbounds float, float* %[[VAL_1845]], i32 %[[VAL_1810]]
// CHECK:         %[[VAL_1847:.*]] = load float, float* %[[VAL_1846]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1848:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1789]] to float*
// CHECK:         %[[VAL_1849:.*]] = getelementptr inbounds float, float* %[[VAL_1848]], i32 %[[VAL_1810]]
// CHECK:         %[[VAL_1850:.*]] = load float, float* %[[VAL_1849]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1851:.*]] = fdiv float %[[VAL_1847]], %[[VAL_1850]]
// CHECK:         %[[VAL_1852:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1792]] to float*
// CHECK:         %[[VAL_1853:.*]] = getelementptr inbounds float, float* %[[VAL_1852]], i32 %[[VAL_1810]]
// CHECK:         store float %[[VAL_1851]], float* %[[VAL_1853]], align 4
// CHECK:         br label %[[VAL_1816]]
// CHECK:       entry:
// CHECK:         %[[VAL_1854:.*]] = getelementptr inbounds i8, i8* %[[VAL_1855:.*]], i64 0
// CHECK:         %[[VAL_1856:.*]] = bitcast i8* %[[VAL_1854]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1857:.*]] = getelementptr inbounds i8, i8* %[[VAL_1858:.*]], i64 0
// CHECK:         %[[VAL_1859:.*]] = bitcast i8* %[[VAL_1857]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1860:.*]] = getelementptr inbounds i8, i8* %[[VAL_1861:.*]], i64 0
// CHECK:         %[[VAL_1862:.*]] = bitcast i8* %[[VAL_1860]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1863:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1864:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1865:.*]] = mul nuw nsw i32 %[[VAL_1863]], 256
// CHECK:         %[[VAL_1866:.*]] = add nuw nsw i32 %[[VAL_1865]], %[[VAL_1864]]
// CHECK:         %[[VAL_1867:.*]] = icmp ult i32 %[[VAL_1866]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1867]])
// CHECK:         %[[VAL_1868:.*]] = mul nuw nsw i32 %[[VAL_1866]], 4
// CHECK:         %[[VAL_1869:.*]] = udiv i32 %[[VAL_1868]], 1
// CHECK:         %[[VAL_1870:.*]] = urem i32 %[[VAL_1869]], 200
// CHECK:         %[[VAL_1871:.*]] = udiv i32 %[[VAL_1868]], 200
// CHECK:         %[[VAL_1872:.*]] = add nuw nsw i32 %[[VAL_1868]], 1
// CHECK:         %[[VAL_1873:.*]] = udiv i32 %[[VAL_1872]], 1
// CHECK:         %[[VAL_1874:.*]] = urem i32 %[[VAL_1873]], 200
// CHECK:         %[[VAL_1875:.*]] = udiv i32 %[[VAL_1872]], 200
// CHECK:         %[[VAL_1876:.*]] = add nuw nsw i32 %[[VAL_1868]], 2
// CHECK:         %[[VAL_1877:.*]] = udiv i32 %[[VAL_1876]], 1
// CHECK:         %[[VAL_1878:.*]] = urem i32 %[[VAL_1877]], 200
// CHECK:         %[[VAL_1879:.*]] = udiv i32 %[[VAL_1876]], 200
// CHECK:         %[[VAL_1880:.*]] = add nuw nsw i32 %[[VAL_1868]], 3
// CHECK:         %[[VAL_1881:.*]] = udiv i32 %[[VAL_1880]], 1
// CHECK:         %[[VAL_1882:.*]] = urem i32 %[[VAL_1881]], 200
// CHECK:         %[[VAL_1883:.*]] = udiv i32 %[[VAL_1880]], 200
// CHECK:         %[[VAL_1884:.*]] = icmp ult i32 %[[VAL_1868]], 20000
// CHECK:         br i1 %[[VAL_1884]], label %[[VAL_1885:.*]], label %[[VAL_1886:.*]]
// CHECK:       r32.in_bounds-after:                              ; preds = %[[VAL_1885]], %[[VAL_1887:.*]]
// CHECK:         ret void
// CHECK:       r32.in_bounds-true:                               ; preds = %[[VAL_1887]]
// CHECK:         %[[VAL_1888:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1856]] to float*
// CHECK:         %[[VAL_1889:.*]] = getelementptr inbounds float, float* %[[VAL_1888]], i32 %[[VAL_1868]]
// CHECK:         %[[VAL_1890:.*]] = load float, float* %[[VAL_1889]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1891:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1859]] to float*
// CHECK:         %[[VAL_1892:.*]] = getelementptr inbounds float, float* %[[VAL_1891]], i32 %[[VAL_1868]]
// CHECK:         %[[VAL_1893:.*]] = load float, float* %[[VAL_1892]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1894:.*]] = call float @llvm.maxnum.f32(float %[[VAL_1890]], float %[[VAL_1893]])
// CHECK:         %[[VAL_1895:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1862]] to float*
// CHECK:         %[[VAL_1896:.*]] = getelementptr inbounds float, float* %[[VAL_1895]], i32 %[[VAL_1868]]
// CHECK:         store float %[[VAL_1894]], float* %[[VAL_1896]], align 4
// CHECK:         %[[VAL_1897:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1856]] to float*
// CHECK:         %[[VAL_1898:.*]] = getelementptr inbounds float, float* %[[VAL_1897]], i32 %[[VAL_1872]]
// CHECK:         %[[VAL_1899:.*]] = load float, float* %[[VAL_1898]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1900:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1859]] to float*
// CHECK:         %[[VAL_1901:.*]] = getelementptr inbounds float, float* %[[VAL_1900]], i32 %[[VAL_1872]]
// CHECK:         %[[VAL_1902:.*]] = load float, float* %[[VAL_1901]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1903:.*]] = call float @llvm.maxnum.f32(float %[[VAL_1899]], float %[[VAL_1902]])
// CHECK:         %[[VAL_1904:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1862]] to float*
// CHECK:         %[[VAL_1905:.*]] = getelementptr inbounds float, float* %[[VAL_1904]], i32 %[[VAL_1872]]
// CHECK:         store float %[[VAL_1903]], float* %[[VAL_1905]], align 4
// CHECK:         %[[VAL_1906:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1856]] to float*
// CHECK:         %[[VAL_1907:.*]] = getelementptr inbounds float, float* %[[VAL_1906]], i32 %[[VAL_1876]]
// CHECK:         %[[VAL_1908:.*]] = load float, float* %[[VAL_1907]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1909:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1859]] to float*
// CHECK:         %[[VAL_1910:.*]] = getelementptr inbounds float, float* %[[VAL_1909]], i32 %[[VAL_1876]]
// CHECK:         %[[VAL_1911:.*]] = load float, float* %[[VAL_1910]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1912:.*]] = call float @llvm.maxnum.f32(float %[[VAL_1908]], float %[[VAL_1911]])
// CHECK:         %[[VAL_1913:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1862]] to float*
// CHECK:         %[[VAL_1914:.*]] = getelementptr inbounds float, float* %[[VAL_1913]], i32 %[[VAL_1876]]
// CHECK:         store float %[[VAL_1912]], float* %[[VAL_1914]], align 4
// CHECK:         %[[VAL_1915:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1856]] to float*
// CHECK:         %[[VAL_1916:.*]] = getelementptr inbounds float, float* %[[VAL_1915]], i32 %[[VAL_1880]]
// CHECK:         %[[VAL_1917:.*]] = load float, float* %[[VAL_1916]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1918:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1859]] to float*
// CHECK:         %[[VAL_1919:.*]] = getelementptr inbounds float, float* %[[VAL_1918]], i32 %[[VAL_1880]]
// CHECK:         %[[VAL_1920:.*]] = load float, float* %[[VAL_1919]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1921:.*]] = call float @llvm.maxnum.f32(float %[[VAL_1917]], float %[[VAL_1920]])
// CHECK:         %[[VAL_1922:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1862]] to float*
// CHECK:         %[[VAL_1923:.*]] = getelementptr inbounds float, float* %[[VAL_1922]], i32 %[[VAL_1880]]
// CHECK:         store float %[[VAL_1921]], float* %[[VAL_1923]], align 4
// CHECK:         br label %[[VAL_1886]]
// CHECK:       entry:
// CHECK:         %[[VAL_1924:.*]] = getelementptr inbounds i8, i8* %[[VAL_1925:.*]], i64 0
// CHECK:         %[[VAL_1926:.*]] = bitcast i8* %[[VAL_1924]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1927:.*]] = getelementptr inbounds i8, i8* %[[VAL_1928:.*]], i64 0
// CHECK:         %[[VAL_1929:.*]] = bitcast i8* %[[VAL_1927]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1930:.*]] = getelementptr inbounds i8, i8* %[[VAL_1931:.*]], i64 0
// CHECK:         %[[VAL_1932:.*]] = bitcast i8* %[[VAL_1930]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1933:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_1934:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_1935:.*]] = mul nuw nsw i32 %[[VAL_1933]], 256
// CHECK:         %[[VAL_1936:.*]] = add nuw nsw i32 %[[VAL_1935]], %[[VAL_1934]]
// CHECK:         %[[VAL_1937:.*]] = icmp ult i32 %[[VAL_1936]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_1937]])
// CHECK:         %[[VAL_1938:.*]] = mul nuw nsw i32 %[[VAL_1936]], 4
// CHECK:         %[[VAL_1939:.*]] = udiv i32 %[[VAL_1938]], 1
// CHECK:         %[[VAL_1940:.*]] = urem i32 %[[VAL_1939]], 200
// CHECK:         %[[VAL_1941:.*]] = udiv i32 %[[VAL_1938]], 200
// CHECK:         %[[VAL_1942:.*]] = add nuw nsw i32 %[[VAL_1938]], 1
// CHECK:         %[[VAL_1943:.*]] = udiv i32 %[[VAL_1942]], 1
// CHECK:         %[[VAL_1944:.*]] = urem i32 %[[VAL_1943]], 200
// CHECK:         %[[VAL_1945:.*]] = udiv i32 %[[VAL_1942]], 200
// CHECK:         %[[VAL_1946:.*]] = add nuw nsw i32 %[[VAL_1938]], 2
// CHECK:         %[[VAL_1947:.*]] = udiv i32 %[[VAL_1946]], 1
// CHECK:         %[[VAL_1948:.*]] = urem i32 %[[VAL_1947]], 200
// CHECK:         %[[VAL_1949:.*]] = udiv i32 %[[VAL_1946]], 200
// CHECK:         %[[VAL_1950:.*]] = add nuw nsw i32 %[[VAL_1938]], 3
// CHECK:         %[[VAL_1951:.*]] = udiv i32 %[[VAL_1950]], 1
// CHECK:         %[[VAL_1952:.*]] = urem i32 %[[VAL_1951]], 200
// CHECK:         %[[VAL_1953:.*]] = udiv i32 %[[VAL_1950]], 200
// CHECK:         %[[VAL_1954:.*]] = icmp ult i32 %[[VAL_1938]], 20000
// CHECK:         br i1 %[[VAL_1954]], label %[[VAL_1955:.*]], label %[[VAL_1956:.*]]
// CHECK:       r33.in_bounds-after:                              ; preds = %[[VAL_1955]], %[[VAL_1957:.*]]
// CHECK:         ret void
// CHECK:       r33.in_bounds-true:                               ; preds = %[[VAL_1957]]
// CHECK:         %[[VAL_1958:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1926]] to float*
// CHECK:         %[[VAL_1959:.*]] = getelementptr inbounds float, float* %[[VAL_1958]], i32 %[[VAL_1938]]
// CHECK:         %[[VAL_1960:.*]] = load float, float* %[[VAL_1959]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1961:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1929]] to float*
// CHECK:         %[[VAL_1962:.*]] = getelementptr inbounds float, float* %[[VAL_1961]], i32 %[[VAL_1938]]
// CHECK:         %[[VAL_1963:.*]] = load float, float* %[[VAL_1962]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1964:.*]] = call float @llvm.minnum.f32(float %[[VAL_1960]], float %[[VAL_1963]])
// CHECK:         %[[VAL_1965:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1932]] to float*
// CHECK:         %[[VAL_1966:.*]] = getelementptr inbounds float, float* %[[VAL_1965]], i32 %[[VAL_1938]]
// CHECK:         store float %[[VAL_1964]], float* %[[VAL_1966]], align 4
// CHECK:         %[[VAL_1967:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1926]] to float*
// CHECK:         %[[VAL_1968:.*]] = getelementptr inbounds float, float* %[[VAL_1967]], i32 %[[VAL_1942]]
// CHECK:         %[[VAL_1969:.*]] = load float, float* %[[VAL_1968]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1970:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1929]] to float*
// CHECK:         %[[VAL_1971:.*]] = getelementptr inbounds float, float* %[[VAL_1970]], i32 %[[VAL_1942]]
// CHECK:         %[[VAL_1972:.*]] = load float, float* %[[VAL_1971]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1973:.*]] = call float @llvm.minnum.f32(float %[[VAL_1969]], float %[[VAL_1972]])
// CHECK:         %[[VAL_1974:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1932]] to float*
// CHECK:         %[[VAL_1975:.*]] = getelementptr inbounds float, float* %[[VAL_1974]], i32 %[[VAL_1942]]
// CHECK:         store float %[[VAL_1973]], float* %[[VAL_1975]], align 4
// CHECK:         %[[VAL_1976:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1926]] to float*
// CHECK:         %[[VAL_1977:.*]] = getelementptr inbounds float, float* %[[VAL_1976]], i32 %[[VAL_1946]]
// CHECK:         %[[VAL_1978:.*]] = load float, float* %[[VAL_1977]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1979:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1929]] to float*
// CHECK:         %[[VAL_1980:.*]] = getelementptr inbounds float, float* %[[VAL_1979]], i32 %[[VAL_1946]]
// CHECK:         %[[VAL_1981:.*]] = load float, float* %[[VAL_1980]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1982:.*]] = call float @llvm.minnum.f32(float %[[VAL_1978]], float %[[VAL_1981]])
// CHECK:         %[[VAL_1983:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1932]] to float*
// CHECK:         %[[VAL_1984:.*]] = getelementptr inbounds float, float* %[[VAL_1983]], i32 %[[VAL_1946]]
// CHECK:         store float %[[VAL_1982]], float* %[[VAL_1984]], align 4
// CHECK:         %[[VAL_1985:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1926]] to float*
// CHECK:         %[[VAL_1986:.*]] = getelementptr inbounds float, float* %[[VAL_1985]], i32 %[[VAL_1950]]
// CHECK:         %[[VAL_1987:.*]] = load float, float* %[[VAL_1986]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1988:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1929]] to float*
// CHECK:         %[[VAL_1989:.*]] = getelementptr inbounds float, float* %[[VAL_1988]], i32 %[[VAL_1950]]
// CHECK:         %[[VAL_1990:.*]] = load float, float* %[[VAL_1989]], align 4, !invariant.load !94
// CHECK:         %[[VAL_1991:.*]] = call float @llvm.minnum.f32(float %[[VAL_1987]], float %[[VAL_1990]])
// CHECK:         %[[VAL_1992:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1932]] to float*
// CHECK:         %[[VAL_1993:.*]] = getelementptr inbounds float, float* %[[VAL_1992]], i32 %[[VAL_1950]]
// CHECK:         store float %[[VAL_1991]], float* %[[VAL_1993]], align 4
// CHECK:         br label %[[VAL_1956]]
// CHECK:       entry:
// CHECK:         %[[VAL_1994:.*]] = getelementptr inbounds i8, i8* %[[VAL_1995:.*]], i64 0
// CHECK:         %[[VAL_1996:.*]] = bitcast i8* %[[VAL_1994]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_1997:.*]] = getelementptr inbounds i8, i8* %[[VAL_1998:.*]], i64 0
// CHECK:         %[[VAL_1999:.*]] = bitcast i8* %[[VAL_1997]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2000:.*]] = getelementptr inbounds i8, i8* %[[VAL_2001:.*]], i64 0
// CHECK:         %[[VAL_2002:.*]] = bitcast i8* %[[VAL_2000]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2003:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2004:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2005:.*]] = mul nuw nsw i32 %[[VAL_2003]], 256
// CHECK:         %[[VAL_2006:.*]] = add nuw nsw i32 %[[VAL_2005]], %[[VAL_2004]]
// CHECK:         %[[VAL_2007:.*]] = icmp ult i32 %[[VAL_2006]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2007]])
// CHECK:         %[[VAL_2008:.*]] = mul nuw nsw i32 %[[VAL_2006]], 4
// CHECK:         %[[VAL_2009:.*]] = udiv i32 %[[VAL_2008]], 1
// CHECK:         %[[VAL_2010:.*]] = urem i32 %[[VAL_2009]], 200
// CHECK:         %[[VAL_2011:.*]] = udiv i32 %[[VAL_2008]], 200
// CHECK:         %[[VAL_2012:.*]] = add nuw nsw i32 %[[VAL_2008]], 1
// CHECK:         %[[VAL_2013:.*]] = udiv i32 %[[VAL_2012]], 1
// CHECK:         %[[VAL_2014:.*]] = urem i32 %[[VAL_2013]], 200
// CHECK:         %[[VAL_2015:.*]] = udiv i32 %[[VAL_2012]], 200
// CHECK:         %[[VAL_2016:.*]] = add nuw nsw i32 %[[VAL_2008]], 2
// CHECK:         %[[VAL_2017:.*]] = udiv i32 %[[VAL_2016]], 1
// CHECK:         %[[VAL_2018:.*]] = urem i32 %[[VAL_2017]], 200
// CHECK:         %[[VAL_2019:.*]] = udiv i32 %[[VAL_2016]], 200
// CHECK:         %[[VAL_2020:.*]] = add nuw nsw i32 %[[VAL_2008]], 3
// CHECK:         %[[VAL_2021:.*]] = udiv i32 %[[VAL_2020]], 1
// CHECK:         %[[VAL_2022:.*]] = urem i32 %[[VAL_2021]], 200
// CHECK:         %[[VAL_2023:.*]] = udiv i32 %[[VAL_2020]], 200
// CHECK:         %[[VAL_2024:.*]] = icmp ult i32 %[[VAL_2008]], 20000
// CHECK:         br i1 %[[VAL_2024]], label %[[VAL_2025:.*]], label %[[VAL_2026:.*]]
// CHECK:       r34.in_bounds-after:                              ; preds = %[[VAL_2025]], %[[VAL_2027:.*]]
// CHECK:         ret void
// CHECK:       r34.in_bounds-true:                               ; preds = %[[VAL_2027]]
// CHECK:         %[[VAL_2028:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1996]] to float*
// CHECK:         %[[VAL_2029:.*]] = getelementptr inbounds float, float* %[[VAL_2028]], i32 %[[VAL_2008]]
// CHECK:         %[[VAL_2030:.*]] = load float, float* %[[VAL_2029]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2031:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1999]] to float*
// CHECK:         %[[VAL_2032:.*]] = getelementptr inbounds float, float* %[[VAL_2031]], i32 %[[VAL_2008]]
// CHECK:         %[[VAL_2033:.*]] = load float, float* %[[VAL_2032]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2034:.*]] = fmul float %[[VAL_2030]], %[[VAL_2033]]
// CHECK:         %[[VAL_2035:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2002]] to float*
// CHECK:         %[[VAL_2036:.*]] = getelementptr inbounds float, float* %[[VAL_2035]], i32 %[[VAL_2008]]
// CHECK:         store float %[[VAL_2034]], float* %[[VAL_2036]], align 4
// CHECK:         %[[VAL_2037:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1996]] to float*
// CHECK:         %[[VAL_2038:.*]] = getelementptr inbounds float, float* %[[VAL_2037]], i32 %[[VAL_2012]]
// CHECK:         %[[VAL_2039:.*]] = load float, float* %[[VAL_2038]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2040:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1999]] to float*
// CHECK:         %[[VAL_2041:.*]] = getelementptr inbounds float, float* %[[VAL_2040]], i32 %[[VAL_2012]]
// CHECK:         %[[VAL_2042:.*]] = load float, float* %[[VAL_2041]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2043:.*]] = fmul float %[[VAL_2039]], %[[VAL_2042]]
// CHECK:         %[[VAL_2044:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2002]] to float*
// CHECK:         %[[VAL_2045:.*]] = getelementptr inbounds float, float* %[[VAL_2044]], i32 %[[VAL_2012]]
// CHECK:         store float %[[VAL_2043]], float* %[[VAL_2045]], align 4
// CHECK:         %[[VAL_2046:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1996]] to float*
// CHECK:         %[[VAL_2047:.*]] = getelementptr inbounds float, float* %[[VAL_2046]], i32 %[[VAL_2016]]
// CHECK:         %[[VAL_2048:.*]] = load float, float* %[[VAL_2047]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2049:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1999]] to float*
// CHECK:         %[[VAL_2050:.*]] = getelementptr inbounds float, float* %[[VAL_2049]], i32 %[[VAL_2016]]
// CHECK:         %[[VAL_2051:.*]] = load float, float* %[[VAL_2050]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2052:.*]] = fmul float %[[VAL_2048]], %[[VAL_2051]]
// CHECK:         %[[VAL_2053:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2002]] to float*
// CHECK:         %[[VAL_2054:.*]] = getelementptr inbounds float, float* %[[VAL_2053]], i32 %[[VAL_2016]]
// CHECK:         store float %[[VAL_2052]], float* %[[VAL_2054]], align 4
// CHECK:         %[[VAL_2055:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1996]] to float*
// CHECK:         %[[VAL_2056:.*]] = getelementptr inbounds float, float* %[[VAL_2055]], i32 %[[VAL_2020]]
// CHECK:         %[[VAL_2057:.*]] = load float, float* %[[VAL_2056]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2058:.*]] = bitcast [100 x [200 x float]]* %[[VAL_1999]] to float*
// CHECK:         %[[VAL_2059:.*]] = getelementptr inbounds float, float* %[[VAL_2058]], i32 %[[VAL_2020]]
// CHECK:         %[[VAL_2060:.*]] = load float, float* %[[VAL_2059]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2061:.*]] = fmul float %[[VAL_2057]], %[[VAL_2060]]
// CHECK:         %[[VAL_2062:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2002]] to float*
// CHECK:         %[[VAL_2063:.*]] = getelementptr inbounds float, float* %[[VAL_2062]], i32 %[[VAL_2020]]
// CHECK:         store float %[[VAL_2061]], float* %[[VAL_2063]], align 4
// CHECK:         br label %[[VAL_2026]]
// CHECK:       entry:
// CHECK:         %[[VAL_2064:.*]] = getelementptr inbounds i8, i8* %[[VAL_2065:.*]], i64 0
// CHECK:         %[[VAL_2066:.*]] = bitcast i8* %[[VAL_2064]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2067:.*]] = getelementptr inbounds i8, i8* %[[VAL_2068:.*]], i64 0
// CHECK:         %[[VAL_2069:.*]] = bitcast i8* %[[VAL_2067]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2070:.*]] = getelementptr inbounds i8, i8* %[[VAL_2071:.*]], i64 0
// CHECK:         %[[VAL_2072:.*]] = bitcast i8* %[[VAL_2070]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2073:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2074:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !95
// CHECK:         %[[VAL_2075:.*]] = mul nuw nsw i32 %[[VAL_2073]], 1024
// CHECK:         %[[VAL_2076:.*]] = add nuw nsw i32 %[[VAL_2075]], %[[VAL_2074]]
// CHECK:         %[[VAL_2077:.*]] = icmp ult i32 %[[VAL_2076]], 20480
// CHECK:         call void @llvm.assume(i1 %[[VAL_2077]])
// CHECK:         %[[VAL_2078:.*]] = udiv i32 %[[VAL_2076]], 1
// CHECK:         %[[VAL_2079:.*]] = urem i32 %[[VAL_2078]], 200
// CHECK:         %[[VAL_2080:.*]] = udiv i32 %[[VAL_2076]], 200
// CHECK:         %[[VAL_2081:.*]] = icmp ult i32 %[[VAL_2076]], 20000
// CHECK:         br i1 %[[VAL_2081]], label %[[VAL_2082:.*]], label %[[VAL_2083:.*]]
// CHECK:       r35.in_bounds-after:                              ; preds = %[[VAL_2082]], %[[VAL_2084:.*]]
// CHECK:         ret void
// CHECK:       r35.in_bounds-true:                               ; preds = %[[VAL_2084]]
// CHECK:         %[[VAL_2085:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2066]] to float*
// CHECK:         %[[VAL_2086:.*]] = getelementptr inbounds float, float* %[[VAL_2085]], i32 %[[VAL_2076]]
// CHECK:         %[[VAL_2087:.*]] = load float, float* %[[VAL_2086]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2088:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2069]] to float*
// CHECK:         %[[VAL_2089:.*]] = getelementptr inbounds float, float* %[[VAL_2088]], i32 %[[VAL_2076]]
// CHECK:         %[[VAL_2090:.*]] = load float, float* %[[VAL_2089]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2091:.*]] = call float @__nv_powf(float %[[VAL_2087]], float %[[VAL_2090]])
// CHECK:         %[[VAL_2092:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2072]] to float*
// CHECK:         %[[VAL_2093:.*]] = getelementptr inbounds float, float* %[[VAL_2092]], i32 %[[VAL_2076]]
// CHECK:         store float %[[VAL_2091]], float* %[[VAL_2093]], align 4
// CHECK:         br label %[[VAL_2083]]
// CHECK:       entry:
// CHECK:         %[[VAL_2094:.*]] = getelementptr inbounds i8, i8* %[[VAL_2095:.*]], i64 0
// CHECK:         %[[VAL_2096:.*]] = bitcast i8* %[[VAL_2094]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2097:.*]] = getelementptr inbounds i8, i8* %[[VAL_2098:.*]], i64 0
// CHECK:         %[[VAL_2099:.*]] = bitcast i8* %[[VAL_2097]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2100:.*]] = getelementptr inbounds i8, i8* %[[VAL_2101:.*]], i64 0
// CHECK:         %[[VAL_2102:.*]] = bitcast i8* %[[VAL_2100]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2103:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2104:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2105:.*]] = mul nuw nsw i32 %[[VAL_2103]], 256
// CHECK:         %[[VAL_2106:.*]] = add nuw nsw i32 %[[VAL_2105]], %[[VAL_2104]]
// CHECK:         %[[VAL_2107:.*]] = icmp ult i32 %[[VAL_2106]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2107]])
// CHECK:         %[[VAL_2108:.*]] = mul nuw nsw i32 %[[VAL_2106]], 4
// CHECK:         %[[VAL_2109:.*]] = udiv i32 %[[VAL_2108]], 1
// CHECK:         %[[VAL_2110:.*]] = urem i32 %[[VAL_2109]], 200
// CHECK:         %[[VAL_2111:.*]] = udiv i32 %[[VAL_2108]], 200
// CHECK:         %[[VAL_2112:.*]] = add nuw nsw i32 %[[VAL_2108]], 1
// CHECK:         %[[VAL_2113:.*]] = udiv i32 %[[VAL_2112]], 1
// CHECK:         %[[VAL_2114:.*]] = urem i32 %[[VAL_2113]], 200
// CHECK:         %[[VAL_2115:.*]] = udiv i32 %[[VAL_2112]], 200
// CHECK:         %[[VAL_2116:.*]] = add nuw nsw i32 %[[VAL_2108]], 2
// CHECK:         %[[VAL_2117:.*]] = udiv i32 %[[VAL_2116]], 1
// CHECK:         %[[VAL_2118:.*]] = urem i32 %[[VAL_2117]], 200
// CHECK:         %[[VAL_2119:.*]] = udiv i32 %[[VAL_2116]], 200
// CHECK:         %[[VAL_2120:.*]] = add nuw nsw i32 %[[VAL_2108]], 3
// CHECK:         %[[VAL_2121:.*]] = udiv i32 %[[VAL_2120]], 1
// CHECK:         %[[VAL_2122:.*]] = urem i32 %[[VAL_2121]], 200
// CHECK:         %[[VAL_2123:.*]] = udiv i32 %[[VAL_2120]], 200
// CHECK:         %[[VAL_2124:.*]] = icmp ult i32 %[[VAL_2108]], 20000
// CHECK:         br i1 %[[VAL_2124]], label %[[VAL_2125:.*]], label %[[VAL_2126:.*]]
// CHECK:       r36.in_bounds-after:                              ; preds = %[[VAL_2125]], %[[VAL_2127:.*]]
// CHECK:         ret void
// CHECK:       r36.in_bounds-true:                               ; preds = %[[VAL_2127]]
// CHECK:         %[[VAL_2128:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2096]] to float*
// CHECK:         %[[VAL_2129:.*]] = getelementptr inbounds float, float* %[[VAL_2128]], i32 %[[VAL_2108]]
// CHECK:         %[[VAL_2130:.*]] = load float, float* %[[VAL_2129]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2131:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2099]] to float*
// CHECK:         %[[VAL_2132:.*]] = getelementptr inbounds float, float* %[[VAL_2131]], i32 %[[VAL_2108]]
// CHECK:         %[[VAL_2133:.*]] = load float, float* %[[VAL_2132]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2134:.*]] = call float @__nv_fmodf(float %[[VAL_2130]], float %[[VAL_2133]])
// CHECK:         %[[VAL_2135:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2102]] to float*
// CHECK:         %[[VAL_2136:.*]] = getelementptr inbounds float, float* %[[VAL_2135]], i32 %[[VAL_2108]]
// CHECK:         store float %[[VAL_2134]], float* %[[VAL_2136]], align 4
// CHECK:         %[[VAL_2137:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2096]] to float*
// CHECK:         %[[VAL_2138:.*]] = getelementptr inbounds float, float* %[[VAL_2137]], i32 %[[VAL_2112]]
// CHECK:         %[[VAL_2139:.*]] = load float, float* %[[VAL_2138]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2140:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2099]] to float*
// CHECK:         %[[VAL_2141:.*]] = getelementptr inbounds float, float* %[[VAL_2140]], i32 %[[VAL_2112]]
// CHECK:         %[[VAL_2142:.*]] = load float, float* %[[VAL_2141]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2143:.*]] = call float @__nv_fmodf(float %[[VAL_2139]], float %[[VAL_2142]])
// CHECK:         %[[VAL_2144:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2102]] to float*
// CHECK:         %[[VAL_2145:.*]] = getelementptr inbounds float, float* %[[VAL_2144]], i32 %[[VAL_2112]]
// CHECK:         store float %[[VAL_2143]], float* %[[VAL_2145]], align 4
// CHECK:         %[[VAL_2146:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2096]] to float*
// CHECK:         %[[VAL_2147:.*]] = getelementptr inbounds float, float* %[[VAL_2146]], i32 %[[VAL_2116]]
// CHECK:         %[[VAL_2148:.*]] = load float, float* %[[VAL_2147]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2149:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2099]] to float*
// CHECK:         %[[VAL_2150:.*]] = getelementptr inbounds float, float* %[[VAL_2149]], i32 %[[VAL_2116]]
// CHECK:         %[[VAL_2151:.*]] = load float, float* %[[VAL_2150]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2152:.*]] = call float @__nv_fmodf(float %[[VAL_2148]], float %[[VAL_2151]])
// CHECK:         %[[VAL_2153:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2102]] to float*
// CHECK:         %[[VAL_2154:.*]] = getelementptr inbounds float, float* %[[VAL_2153]], i32 %[[VAL_2116]]
// CHECK:         store float %[[VAL_2152]], float* %[[VAL_2154]], align 4
// CHECK:         %[[VAL_2155:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2096]] to float*
// CHECK:         %[[VAL_2156:.*]] = getelementptr inbounds float, float* %[[VAL_2155]], i32 %[[VAL_2120]]
// CHECK:         %[[VAL_2157:.*]] = load float, float* %[[VAL_2156]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2158:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2099]] to float*
// CHECK:         %[[VAL_2159:.*]] = getelementptr inbounds float, float* %[[VAL_2158]], i32 %[[VAL_2120]]
// CHECK:         %[[VAL_2160:.*]] = load float, float* %[[VAL_2159]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2161:.*]] = call float @__nv_fmodf(float %[[VAL_2157]], float %[[VAL_2160]])
// CHECK:         %[[VAL_2162:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2102]] to float*
// CHECK:         %[[VAL_2163:.*]] = getelementptr inbounds float, float* %[[VAL_2162]], i32 %[[VAL_2120]]
// CHECK:         store float %[[VAL_2161]], float* %[[VAL_2163]], align 4
// CHECK:         br label %[[VAL_2126]]
// CHECK:       entry:
// CHECK:         %[[VAL_2164:.*]] = getelementptr inbounds i8, i8* %[[VAL_2165:.*]], i64 0
// CHECK:         %[[VAL_2166:.*]] = bitcast i8* %[[VAL_2164]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2167:.*]] = getelementptr inbounds i8, i8* %[[VAL_2168:.*]], i64 0
// CHECK:         %[[VAL_2169:.*]] = bitcast i8* %[[VAL_2167]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2170:.*]] = getelementptr inbounds i8, i8* %[[VAL_2171:.*]], i64 0
// CHECK:         %[[VAL_2172:.*]] = bitcast i8* %[[VAL_2170]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2173:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2174:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2175:.*]] = mul nuw nsw i32 %[[VAL_2173]], 256
// CHECK:         %[[VAL_2176:.*]] = add nuw nsw i32 %[[VAL_2175]], %[[VAL_2174]]
// CHECK:         %[[VAL_2177:.*]] = icmp ult i32 %[[VAL_2176]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2177]])
// CHECK:         %[[VAL_2178:.*]] = mul nuw nsw i32 %[[VAL_2176]], 4
// CHECK:         %[[VAL_2179:.*]] = udiv i32 %[[VAL_2178]], 1
// CHECK:         %[[VAL_2180:.*]] = urem i32 %[[VAL_2179]], 200
// CHECK:         %[[VAL_2181:.*]] = udiv i32 %[[VAL_2178]], 200
// CHECK:         %[[VAL_2182:.*]] = add nuw nsw i32 %[[VAL_2178]], 1
// CHECK:         %[[VAL_2183:.*]] = udiv i32 %[[VAL_2182]], 1
// CHECK:         %[[VAL_2184:.*]] = urem i32 %[[VAL_2183]], 200
// CHECK:         %[[VAL_2185:.*]] = udiv i32 %[[VAL_2182]], 200
// CHECK:         %[[VAL_2186:.*]] = add nuw nsw i32 %[[VAL_2178]], 2
// CHECK:         %[[VAL_2187:.*]] = udiv i32 %[[VAL_2186]], 1
// CHECK:         %[[VAL_2188:.*]] = urem i32 %[[VAL_2187]], 200
// CHECK:         %[[VAL_2189:.*]] = udiv i32 %[[VAL_2186]], 200
// CHECK:         %[[VAL_2190:.*]] = add nuw nsw i32 %[[VAL_2178]], 3
// CHECK:         %[[VAL_2191:.*]] = udiv i32 %[[VAL_2190]], 1
// CHECK:         %[[VAL_2192:.*]] = urem i32 %[[VAL_2191]], 200
// CHECK:         %[[VAL_2193:.*]] = udiv i32 %[[VAL_2190]], 200
// CHECK:         %[[VAL_2194:.*]] = icmp ult i32 %[[VAL_2178]], 20000
// CHECK:         br i1 %[[VAL_2194]], label %[[VAL_2195:.*]], label %[[VAL_2196:.*]]
// CHECK:       r37.in_bounds-after:                              ; preds = %[[VAL_2195]], %[[VAL_2197:.*]]
// CHECK:         ret void
// CHECK:       r37.in_bounds-true:                               ; preds = %[[VAL_2197]]
// CHECK:         %[[VAL_2198:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2166]] to float*
// CHECK:         %[[VAL_2199:.*]] = getelementptr inbounds float, float* %[[VAL_2198]], i32 %[[VAL_2178]]
// CHECK:         %[[VAL_2200:.*]] = load float, float* %[[VAL_2199]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2201:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2169]] to float*
// CHECK:         %[[VAL_2202:.*]] = getelementptr inbounds float, float* %[[VAL_2201]], i32 %[[VAL_2178]]
// CHECK:         %[[VAL_2203:.*]] = load float, float* %[[VAL_2202]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2204:.*]] = fsub float %[[VAL_2200]], %[[VAL_2203]]
// CHECK:         %[[VAL_2205:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2172]] to float*
// CHECK:         %[[VAL_2206:.*]] = getelementptr inbounds float, float* %[[VAL_2205]], i32 %[[VAL_2178]]
// CHECK:         store float %[[VAL_2204]], float* %[[VAL_2206]], align 4
// CHECK:         %[[VAL_2207:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2166]] to float*
// CHECK:         %[[VAL_2208:.*]] = getelementptr inbounds float, float* %[[VAL_2207]], i32 %[[VAL_2182]]
// CHECK:         %[[VAL_2209:.*]] = load float, float* %[[VAL_2208]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2210:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2169]] to float*
// CHECK:         %[[VAL_2211:.*]] = getelementptr inbounds float, float* %[[VAL_2210]], i32 %[[VAL_2182]]
// CHECK:         %[[VAL_2212:.*]] = load float, float* %[[VAL_2211]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2213:.*]] = fsub float %[[VAL_2209]], %[[VAL_2212]]
// CHECK:         %[[VAL_2214:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2172]] to float*
// CHECK:         %[[VAL_2215:.*]] = getelementptr inbounds float, float* %[[VAL_2214]], i32 %[[VAL_2182]]
// CHECK:         store float %[[VAL_2213]], float* %[[VAL_2215]], align 4
// CHECK:         %[[VAL_2216:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2166]] to float*
// CHECK:         %[[VAL_2217:.*]] = getelementptr inbounds float, float* %[[VAL_2216]], i32 %[[VAL_2186]]
// CHECK:         %[[VAL_2218:.*]] = load float, float* %[[VAL_2217]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2219:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2169]] to float*
// CHECK:         %[[VAL_2220:.*]] = getelementptr inbounds float, float* %[[VAL_2219]], i32 %[[VAL_2186]]
// CHECK:         %[[VAL_2221:.*]] = load float, float* %[[VAL_2220]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2222:.*]] = fsub float %[[VAL_2218]], %[[VAL_2221]]
// CHECK:         %[[VAL_2223:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2172]] to float*
// CHECK:         %[[VAL_2224:.*]] = getelementptr inbounds float, float* %[[VAL_2223]], i32 %[[VAL_2186]]
// CHECK:         store float %[[VAL_2222]], float* %[[VAL_2224]], align 4
// CHECK:         %[[VAL_2225:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2166]] to float*
// CHECK:         %[[VAL_2226:.*]] = getelementptr inbounds float, float* %[[VAL_2225]], i32 %[[VAL_2190]]
// CHECK:         %[[VAL_2227:.*]] = load float, float* %[[VAL_2226]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2228:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2169]] to float*
// CHECK:         %[[VAL_2229:.*]] = getelementptr inbounds float, float* %[[VAL_2228]], i32 %[[VAL_2190]]
// CHECK:         %[[VAL_2230:.*]] = load float, float* %[[VAL_2229]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2231:.*]] = fsub float %[[VAL_2227]], %[[VAL_2230]]
// CHECK:         %[[VAL_2232:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2172]] to float*
// CHECK:         %[[VAL_2233:.*]] = getelementptr inbounds float, float* %[[VAL_2232]], i32 %[[VAL_2190]]
// CHECK:         store float %[[VAL_2231]], float* %[[VAL_2233]], align 4
// CHECK:         br label %[[VAL_2196]]
// CHECK:       entry:
// CHECK:         %[[VAL_2234:.*]] = getelementptr inbounds i8, i8* %[[VAL_2235:.*]], i64 0
// CHECK:         %[[VAL_2236:.*]] = bitcast i8* %[[VAL_2234]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2237:.*]] = getelementptr inbounds i8, i8* %[[VAL_2238:.*]], i64 0
// CHECK:         %[[VAL_2239:.*]] = bitcast i8* %[[VAL_2237]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2240:.*]] = getelementptr inbounds i8, i8* %[[VAL_2241:.*]], i64 0
// CHECK:         %[[VAL_2242:.*]] = bitcast i8* %[[VAL_2240]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2243:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2244:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2245:.*]] = mul nuw nsw i32 %[[VAL_2243]], 256
// CHECK:         %[[VAL_2246:.*]] = add nuw nsw i32 %[[VAL_2245]], %[[VAL_2244]]
// CHECK:         %[[VAL_2247:.*]] = icmp ult i32 %[[VAL_2246]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2247]])
// CHECK:         %[[VAL_2248:.*]] = mul nuw nsw i32 %[[VAL_2246]], 4
// CHECK:         %[[VAL_2249:.*]] = udiv i32 %[[VAL_2248]], 1
// CHECK:         %[[VAL_2250:.*]] = urem i32 %[[VAL_2249]], 200
// CHECK:         %[[VAL_2251:.*]] = udiv i32 %[[VAL_2248]], 200
// CHECK:         %[[VAL_2252:.*]] = add nuw nsw i32 %[[VAL_2248]], 1
// CHECK:         %[[VAL_2253:.*]] = udiv i32 %[[VAL_2252]], 1
// CHECK:         %[[VAL_2254:.*]] = urem i32 %[[VAL_2253]], 200
// CHECK:         %[[VAL_2255:.*]] = udiv i32 %[[VAL_2252]], 200
// CHECK:         %[[VAL_2256:.*]] = add nuw nsw i32 %[[VAL_2248]], 2
// CHECK:         %[[VAL_2257:.*]] = udiv i32 %[[VAL_2256]], 1
// CHECK:         %[[VAL_2258:.*]] = urem i32 %[[VAL_2257]], 200
// CHECK:         %[[VAL_2259:.*]] = udiv i32 %[[VAL_2256]], 200
// CHECK:         %[[VAL_2260:.*]] = add nuw nsw i32 %[[VAL_2248]], 3
// CHECK:         %[[VAL_2261:.*]] = udiv i32 %[[VAL_2260]], 1
// CHECK:         %[[VAL_2262:.*]] = urem i32 %[[VAL_2261]], 200
// CHECK:         %[[VAL_2263:.*]] = udiv i32 %[[VAL_2260]], 200
// CHECK:         %[[VAL_2264:.*]] = icmp ult i32 %[[VAL_2248]], 20000
// CHECK:         br i1 %[[VAL_2264]], label %[[VAL_2265:.*]], label %[[VAL_2266:.*]]
// CHECK:       r38.in_bounds-after:                              ; preds = %[[VAL_2265]], %[[VAL_2267:.*]]
// CHECK:         ret void
// CHECK:       r38.in_bounds-true:                               ; preds = %[[VAL_2267]]
// CHECK:         %[[VAL_2268:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2236]] to i8*
// CHECK:         %[[VAL_2269:.*]] = getelementptr inbounds i8, i8* %[[VAL_2268]], i32 %[[VAL_2248]]
// CHECK:         %[[VAL_2270:.*]] = load i8, i8* %[[VAL_2269]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2271:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2239]] to i8*
// CHECK:         %[[VAL_2272:.*]] = getelementptr inbounds i8, i8* %[[VAL_2271]], i32 %[[VAL_2248]]
// CHECK:         %[[VAL_2273:.*]] = load i8, i8* %[[VAL_2272]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2274:.*]] = and i8 %[[VAL_2270]], %[[VAL_2273]]
// CHECK:         %[[VAL_2275:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2242]] to i8*
// CHECK:         %[[VAL_2276:.*]] = getelementptr inbounds i8, i8* %[[VAL_2275]], i32 %[[VAL_2248]]
// CHECK:         store i8 %[[VAL_2274]], i8* %[[VAL_2276]], align 1
// CHECK:         %[[VAL_2277:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2236]] to i8*
// CHECK:         %[[VAL_2278:.*]] = getelementptr inbounds i8, i8* %[[VAL_2277]], i32 %[[VAL_2252]]
// CHECK:         %[[VAL_2279:.*]] = load i8, i8* %[[VAL_2278]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2280:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2239]] to i8*
// CHECK:         %[[VAL_2281:.*]] = getelementptr inbounds i8, i8* %[[VAL_2280]], i32 %[[VAL_2252]]
// CHECK:         %[[VAL_2282:.*]] = load i8, i8* %[[VAL_2281]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2283:.*]] = and i8 %[[VAL_2279]], %[[VAL_2282]]
// CHECK:         %[[VAL_2284:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2242]] to i8*
// CHECK:         %[[VAL_2285:.*]] = getelementptr inbounds i8, i8* %[[VAL_2284]], i32 %[[VAL_2252]]
// CHECK:         store i8 %[[VAL_2283]], i8* %[[VAL_2285]], align 1
// CHECK:         %[[VAL_2286:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2236]] to i8*
// CHECK:         %[[VAL_2287:.*]] = getelementptr inbounds i8, i8* %[[VAL_2286]], i32 %[[VAL_2256]]
// CHECK:         %[[VAL_2288:.*]] = load i8, i8* %[[VAL_2287]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2289:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2239]] to i8*
// CHECK:         %[[VAL_2290:.*]] = getelementptr inbounds i8, i8* %[[VAL_2289]], i32 %[[VAL_2256]]
// CHECK:         %[[VAL_2291:.*]] = load i8, i8* %[[VAL_2290]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2292:.*]] = and i8 %[[VAL_2288]], %[[VAL_2291]]
// CHECK:         %[[VAL_2293:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2242]] to i8*
// CHECK:         %[[VAL_2294:.*]] = getelementptr inbounds i8, i8* %[[VAL_2293]], i32 %[[VAL_2256]]
// CHECK:         store i8 %[[VAL_2292]], i8* %[[VAL_2294]], align 1
// CHECK:         %[[VAL_2295:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2236]] to i8*
// CHECK:         %[[VAL_2296:.*]] = getelementptr inbounds i8, i8* %[[VAL_2295]], i32 %[[VAL_2260]]
// CHECK:         %[[VAL_2297:.*]] = load i8, i8* %[[VAL_2296]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2298:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2239]] to i8*
// CHECK:         %[[VAL_2299:.*]] = getelementptr inbounds i8, i8* %[[VAL_2298]], i32 %[[VAL_2260]]
// CHECK:         %[[VAL_2300:.*]] = load i8, i8* %[[VAL_2299]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2301:.*]] = and i8 %[[VAL_2297]], %[[VAL_2300]]
// CHECK:         %[[VAL_2302:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2242]] to i8*
// CHECK:         %[[VAL_2303:.*]] = getelementptr inbounds i8, i8* %[[VAL_2302]], i32 %[[VAL_2260]]
// CHECK:         store i8 %[[VAL_2301]], i8* %[[VAL_2303]], align 1
// CHECK:         br label %[[VAL_2266]]
// CHECK:       entry:
// CHECK:         %[[VAL_2304:.*]] = getelementptr inbounds i8, i8* %[[VAL_2305:.*]], i64 0
// CHECK:         %[[VAL_2306:.*]] = bitcast i8* %[[VAL_2304]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2307:.*]] = getelementptr inbounds i8, i8* %[[VAL_2308:.*]], i64 0
// CHECK:         %[[VAL_2309:.*]] = bitcast i8* %[[VAL_2307]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2310:.*]] = getelementptr inbounds i8, i8* %[[VAL_2311:.*]], i64 0
// CHECK:         %[[VAL_2312:.*]] = bitcast i8* %[[VAL_2310]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2313:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2314:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2315:.*]] = mul nuw nsw i32 %[[VAL_2313]], 256
// CHECK:         %[[VAL_2316:.*]] = add nuw nsw i32 %[[VAL_2315]], %[[VAL_2314]]
// CHECK:         %[[VAL_2317:.*]] = icmp ult i32 %[[VAL_2316]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2317]])
// CHECK:         %[[VAL_2318:.*]] = mul nuw nsw i32 %[[VAL_2316]], 4
// CHECK:         %[[VAL_2319:.*]] = udiv i32 %[[VAL_2318]], 1
// CHECK:         %[[VAL_2320:.*]] = urem i32 %[[VAL_2319]], 200
// CHECK:         %[[VAL_2321:.*]] = udiv i32 %[[VAL_2318]], 200
// CHECK:         %[[VAL_2322:.*]] = add nuw nsw i32 %[[VAL_2318]], 1
// CHECK:         %[[VAL_2323:.*]] = udiv i32 %[[VAL_2322]], 1
// CHECK:         %[[VAL_2324:.*]] = urem i32 %[[VAL_2323]], 200
// CHECK:         %[[VAL_2325:.*]] = udiv i32 %[[VAL_2322]], 200
// CHECK:         %[[VAL_2326:.*]] = add nuw nsw i32 %[[VAL_2318]], 2
// CHECK:         %[[VAL_2327:.*]] = udiv i32 %[[VAL_2326]], 1
// CHECK:         %[[VAL_2328:.*]] = urem i32 %[[VAL_2327]], 200
// CHECK:         %[[VAL_2329:.*]] = udiv i32 %[[VAL_2326]], 200
// CHECK:         %[[VAL_2330:.*]] = add nuw nsw i32 %[[VAL_2318]], 3
// CHECK:         %[[VAL_2331:.*]] = udiv i32 %[[VAL_2330]], 1
// CHECK:         %[[VAL_2332:.*]] = urem i32 %[[VAL_2331]], 200
// CHECK:         %[[VAL_2333:.*]] = udiv i32 %[[VAL_2330]], 200
// CHECK:         %[[VAL_2334:.*]] = icmp ult i32 %[[VAL_2318]], 20000
// CHECK:         br i1 %[[VAL_2334]], label %[[VAL_2335:.*]], label %[[VAL_2336:.*]]
// CHECK:       r39.in_bounds-after:                              ; preds = %[[VAL_2335]], %[[VAL_2337:.*]]
// CHECK:         ret void
// CHECK:       r39.in_bounds-true:                               ; preds = %[[VAL_2337]]
// CHECK:         %[[VAL_2338:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2306]] to i8*
// CHECK:         %[[VAL_2339:.*]] = getelementptr inbounds i8, i8* %[[VAL_2338]], i32 %[[VAL_2318]]
// CHECK:         %[[VAL_2340:.*]] = load i8, i8* %[[VAL_2339]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2341:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2309]] to i8*
// CHECK:         %[[VAL_2342:.*]] = getelementptr inbounds i8, i8* %[[VAL_2341]], i32 %[[VAL_2318]]
// CHECK:         %[[VAL_2343:.*]] = load i8, i8* %[[VAL_2342]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2344:.*]] = or i8 %[[VAL_2340]], %[[VAL_2343]]
// CHECK:         %[[VAL_2345:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2312]] to i8*
// CHECK:         %[[VAL_2346:.*]] = getelementptr inbounds i8, i8* %[[VAL_2345]], i32 %[[VAL_2318]]
// CHECK:         store i8 %[[VAL_2344]], i8* %[[VAL_2346]], align 1
// CHECK:         %[[VAL_2347:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2306]] to i8*
// CHECK:         %[[VAL_2348:.*]] = getelementptr inbounds i8, i8* %[[VAL_2347]], i32 %[[VAL_2322]]
// CHECK:         %[[VAL_2349:.*]] = load i8, i8* %[[VAL_2348]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2350:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2309]] to i8*
// CHECK:         %[[VAL_2351:.*]] = getelementptr inbounds i8, i8* %[[VAL_2350]], i32 %[[VAL_2322]]
// CHECK:         %[[VAL_2352:.*]] = load i8, i8* %[[VAL_2351]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2353:.*]] = or i8 %[[VAL_2349]], %[[VAL_2352]]
// CHECK:         %[[VAL_2354:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2312]] to i8*
// CHECK:         %[[VAL_2355:.*]] = getelementptr inbounds i8, i8* %[[VAL_2354]], i32 %[[VAL_2322]]
// CHECK:         store i8 %[[VAL_2353]], i8* %[[VAL_2355]], align 1
// CHECK:         %[[VAL_2356:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2306]] to i8*
// CHECK:         %[[VAL_2357:.*]] = getelementptr inbounds i8, i8* %[[VAL_2356]], i32 %[[VAL_2326]]
// CHECK:         %[[VAL_2358:.*]] = load i8, i8* %[[VAL_2357]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2359:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2309]] to i8*
// CHECK:         %[[VAL_2360:.*]] = getelementptr inbounds i8, i8* %[[VAL_2359]], i32 %[[VAL_2326]]
// CHECK:         %[[VAL_2361:.*]] = load i8, i8* %[[VAL_2360]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2362:.*]] = or i8 %[[VAL_2358]], %[[VAL_2361]]
// CHECK:         %[[VAL_2363:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2312]] to i8*
// CHECK:         %[[VAL_2364:.*]] = getelementptr inbounds i8, i8* %[[VAL_2363]], i32 %[[VAL_2326]]
// CHECK:         store i8 %[[VAL_2362]], i8* %[[VAL_2364]], align 1
// CHECK:         %[[VAL_2365:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2306]] to i8*
// CHECK:         %[[VAL_2366:.*]] = getelementptr inbounds i8, i8* %[[VAL_2365]], i32 %[[VAL_2330]]
// CHECK:         %[[VAL_2367:.*]] = load i8, i8* %[[VAL_2366]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2368:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2309]] to i8*
// CHECK:         %[[VAL_2369:.*]] = getelementptr inbounds i8, i8* %[[VAL_2368]], i32 %[[VAL_2330]]
// CHECK:         %[[VAL_2370:.*]] = load i8, i8* %[[VAL_2369]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2371:.*]] = or i8 %[[VAL_2367]], %[[VAL_2370]]
// CHECK:         %[[VAL_2372:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2312]] to i8*
// CHECK:         %[[VAL_2373:.*]] = getelementptr inbounds i8, i8* %[[VAL_2372]], i32 %[[VAL_2330]]
// CHECK:         store i8 %[[VAL_2371]], i8* %[[VAL_2373]], align 1
// CHECK:         br label %[[VAL_2336]]
// CHECK:       entry:
// CHECK:         %[[VAL_2374:.*]] = getelementptr inbounds i8, i8* %[[VAL_2375:.*]], i64 0
// CHECK:         %[[VAL_2376:.*]] = bitcast i8* %[[VAL_2374]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2377:.*]] = getelementptr inbounds i8, i8* %[[VAL_2378:.*]], i64 0
// CHECK:         %[[VAL_2379:.*]] = bitcast i8* %[[VAL_2377]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2380:.*]] = getelementptr inbounds i8, i8* %[[VAL_2381:.*]], i64 0
// CHECK:         %[[VAL_2382:.*]] = bitcast i8* %[[VAL_2380]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2383:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2384:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2385:.*]] = mul nuw nsw i32 %[[VAL_2383]], 256
// CHECK:         %[[VAL_2386:.*]] = add nuw nsw i32 %[[VAL_2385]], %[[VAL_2384]]
// CHECK:         %[[VAL_2387:.*]] = icmp ult i32 %[[VAL_2386]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2387]])
// CHECK:         %[[VAL_2388:.*]] = mul nuw nsw i32 %[[VAL_2386]], 4
// CHECK:         %[[VAL_2389:.*]] = udiv i32 %[[VAL_2388]], 1
// CHECK:         %[[VAL_2390:.*]] = urem i32 %[[VAL_2389]], 200
// CHECK:         %[[VAL_2391:.*]] = udiv i32 %[[VAL_2388]], 200
// CHECK:         %[[VAL_2392:.*]] = add nuw nsw i32 %[[VAL_2388]], 1
// CHECK:         %[[VAL_2393:.*]] = udiv i32 %[[VAL_2392]], 1
// CHECK:         %[[VAL_2394:.*]] = urem i32 %[[VAL_2393]], 200
// CHECK:         %[[VAL_2395:.*]] = udiv i32 %[[VAL_2392]], 200
// CHECK:         %[[VAL_2396:.*]] = add nuw nsw i32 %[[VAL_2388]], 2
// CHECK:         %[[VAL_2397:.*]] = udiv i32 %[[VAL_2396]], 1
// CHECK:         %[[VAL_2398:.*]] = urem i32 %[[VAL_2397]], 200
// CHECK:         %[[VAL_2399:.*]] = udiv i32 %[[VAL_2396]], 200
// CHECK:         %[[VAL_2400:.*]] = add nuw nsw i32 %[[VAL_2388]], 3
// CHECK:         %[[VAL_2401:.*]] = udiv i32 %[[VAL_2400]], 1
// CHECK:         %[[VAL_2402:.*]] = urem i32 %[[VAL_2401]], 200
// CHECK:         %[[VAL_2403:.*]] = udiv i32 %[[VAL_2400]], 200
// CHECK:         %[[VAL_2404:.*]] = icmp ult i32 %[[VAL_2388]], 20000
// CHECK:         br i1 %[[VAL_2404]], label %[[VAL_2405:.*]], label %[[VAL_2406:.*]]
// CHECK:       r40.in_bounds-after:                              ; preds = %[[VAL_2405]], %[[VAL_2407:.*]]
// CHECK:         ret void
// CHECK:       r40.in_bounds-true:                               ; preds = %[[VAL_2407]]
// CHECK:         %[[VAL_2408:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2376]] to i8*
// CHECK:         %[[VAL_2409:.*]] = getelementptr inbounds i8, i8* %[[VAL_2408]], i32 %[[VAL_2388]]
// CHECK:         %[[VAL_2410:.*]] = load i8, i8* %[[VAL_2409]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2411:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2379]] to i8*
// CHECK:         %[[VAL_2412:.*]] = getelementptr inbounds i8, i8* %[[VAL_2411]], i32 %[[VAL_2388]]
// CHECK:         %[[VAL_2413:.*]] = load i8, i8* %[[VAL_2412]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2414:.*]] = xor i8 %[[VAL_2410]], %[[VAL_2413]]
// CHECK:         %[[VAL_2415:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2382]] to i8*
// CHECK:         %[[VAL_2416:.*]] = getelementptr inbounds i8, i8* %[[VAL_2415]], i32 %[[VAL_2388]]
// CHECK:         store i8 %[[VAL_2414]], i8* %[[VAL_2416]], align 1
// CHECK:         %[[VAL_2417:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2376]] to i8*
// CHECK:         %[[VAL_2418:.*]] = getelementptr inbounds i8, i8* %[[VAL_2417]], i32 %[[VAL_2392]]
// CHECK:         %[[VAL_2419:.*]] = load i8, i8* %[[VAL_2418]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2420:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2379]] to i8*
// CHECK:         %[[VAL_2421:.*]] = getelementptr inbounds i8, i8* %[[VAL_2420]], i32 %[[VAL_2392]]
// CHECK:         %[[VAL_2422:.*]] = load i8, i8* %[[VAL_2421]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2423:.*]] = xor i8 %[[VAL_2419]], %[[VAL_2422]]
// CHECK:         %[[VAL_2424:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2382]] to i8*
// CHECK:         %[[VAL_2425:.*]] = getelementptr inbounds i8, i8* %[[VAL_2424]], i32 %[[VAL_2392]]
// CHECK:         store i8 %[[VAL_2423]], i8* %[[VAL_2425]], align 1
// CHECK:         %[[VAL_2426:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2376]] to i8*
// CHECK:         %[[VAL_2427:.*]] = getelementptr inbounds i8, i8* %[[VAL_2426]], i32 %[[VAL_2396]]
// CHECK:         %[[VAL_2428:.*]] = load i8, i8* %[[VAL_2427]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2429:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2379]] to i8*
// CHECK:         %[[VAL_2430:.*]] = getelementptr inbounds i8, i8* %[[VAL_2429]], i32 %[[VAL_2396]]
// CHECK:         %[[VAL_2431:.*]] = load i8, i8* %[[VAL_2430]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2432:.*]] = xor i8 %[[VAL_2428]], %[[VAL_2431]]
// CHECK:         %[[VAL_2433:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2382]] to i8*
// CHECK:         %[[VAL_2434:.*]] = getelementptr inbounds i8, i8* %[[VAL_2433]], i32 %[[VAL_2396]]
// CHECK:         store i8 %[[VAL_2432]], i8* %[[VAL_2434]], align 1
// CHECK:         %[[VAL_2435:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2376]] to i8*
// CHECK:         %[[VAL_2436:.*]] = getelementptr inbounds i8, i8* %[[VAL_2435]], i32 %[[VAL_2400]]
// CHECK:         %[[VAL_2437:.*]] = load i8, i8* %[[VAL_2436]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2438:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2379]] to i8*
// CHECK:         %[[VAL_2439:.*]] = getelementptr inbounds i8, i8* %[[VAL_2438]], i32 %[[VAL_2400]]
// CHECK:         %[[VAL_2440:.*]] = load i8, i8* %[[VAL_2439]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2441:.*]] = xor i8 %[[VAL_2437]], %[[VAL_2440]]
// CHECK:         %[[VAL_2442:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2382]] to i8*
// CHECK:         %[[VAL_2443:.*]] = getelementptr inbounds i8, i8* %[[VAL_2442]], i32 %[[VAL_2400]]
// CHECK:         store i8 %[[VAL_2441]], i8* %[[VAL_2443]], align 1
// CHECK:         br label %[[VAL_2406]]
// CHECK:       entry:
// CHECK:         %[[VAL_2444:.*]] = getelementptr inbounds i8, i8* %[[VAL_2445:.*]], i64 0
// CHECK:         %[[VAL_2446:.*]] = bitcast i8* %[[VAL_2444]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2447:.*]] = getelementptr inbounds i8, i8* %[[VAL_2448:.*]], i64 0
// CHECK:         %[[VAL_2449:.*]] = bitcast i8* %[[VAL_2447]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2450:.*]] = getelementptr inbounds i8, i8* %[[VAL_2451:.*]], i64 0
// CHECK:         %[[VAL_2452:.*]] = bitcast i8* %[[VAL_2450]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2453:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2454:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2455:.*]] = mul nuw nsw i32 %[[VAL_2453]], 256
// CHECK:         %[[VAL_2456:.*]] = add nuw nsw i32 %[[VAL_2455]], %[[VAL_2454]]
// CHECK:         %[[VAL_2457:.*]] = icmp ult i32 %[[VAL_2456]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2457]])
// CHECK:         %[[VAL_2458:.*]] = mul nuw nsw i32 %[[VAL_2456]], 4
// CHECK:         %[[VAL_2459:.*]] = udiv i32 %[[VAL_2458]], 1
// CHECK:         %[[VAL_2460:.*]] = urem i32 %[[VAL_2459]], 200
// CHECK:         %[[VAL_2461:.*]] = udiv i32 %[[VAL_2458]], 200
// CHECK:         %[[VAL_2462:.*]] = add nuw nsw i32 %[[VAL_2458]], 1
// CHECK:         %[[VAL_2463:.*]] = udiv i32 %[[VAL_2462]], 1
// CHECK:         %[[VAL_2464:.*]] = urem i32 %[[VAL_2463]], 200
// CHECK:         %[[VAL_2465:.*]] = udiv i32 %[[VAL_2462]], 200
// CHECK:         %[[VAL_2466:.*]] = add nuw nsw i32 %[[VAL_2458]], 2
// CHECK:         %[[VAL_2467:.*]] = udiv i32 %[[VAL_2466]], 1
// CHECK:         %[[VAL_2468:.*]] = urem i32 %[[VAL_2467]], 200
// CHECK:         %[[VAL_2469:.*]] = udiv i32 %[[VAL_2466]], 200
// CHECK:         %[[VAL_2470:.*]] = add nuw nsw i32 %[[VAL_2458]], 3
// CHECK:         %[[VAL_2471:.*]] = udiv i32 %[[VAL_2470]], 1
// CHECK:         %[[VAL_2472:.*]] = urem i32 %[[VAL_2471]], 200
// CHECK:         %[[VAL_2473:.*]] = udiv i32 %[[VAL_2470]], 200
// CHECK:         %[[VAL_2474:.*]] = icmp ult i32 %[[VAL_2458]], 20000
// CHECK:         br i1 %[[VAL_2474]], label %[[VAL_2475:.*]], label %[[VAL_2476:.*]]
// CHECK:       r41.in_bounds-after:                              ; preds = %[[VAL_2475]], %[[VAL_2477:.*]]
// CHECK:         ret void
// CHECK:       r41.in_bounds-true:                               ; preds = %[[VAL_2477]]
// CHECK:         %[[VAL_2478:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2446]] to i8*
// CHECK:         %[[VAL_2479:.*]] = getelementptr inbounds i8, i8* %[[VAL_2478]], i32 %[[VAL_2458]]
// CHECK:         %[[VAL_2480:.*]] = load i8, i8* %[[VAL_2479]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2481:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2449]] to i8*
// CHECK:         %[[VAL_2482:.*]] = getelementptr inbounds i8, i8* %[[VAL_2481]], i32 %[[VAL_2458]]
// CHECK:         %[[VAL_2483:.*]] = load i8, i8* %[[VAL_2482]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2484:.*]] = or i8 %[[VAL_2480]], %[[VAL_2483]]
// CHECK:         %[[VAL_2485:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2452]] to i8*
// CHECK:         %[[VAL_2486:.*]] = getelementptr inbounds i8, i8* %[[VAL_2485]], i32 %[[VAL_2458]]
// CHECK:         store i8 %[[VAL_2484]], i8* %[[VAL_2486]], align 1
// CHECK:         %[[VAL_2487:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2446]] to i8*
// CHECK:         %[[VAL_2488:.*]] = getelementptr inbounds i8, i8* %[[VAL_2487]], i32 %[[VAL_2462]]
// CHECK:         %[[VAL_2489:.*]] = load i8, i8* %[[VAL_2488]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2490:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2449]] to i8*
// CHECK:         %[[VAL_2491:.*]] = getelementptr inbounds i8, i8* %[[VAL_2490]], i32 %[[VAL_2462]]
// CHECK:         %[[VAL_2492:.*]] = load i8, i8* %[[VAL_2491]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2493:.*]] = or i8 %[[VAL_2489]], %[[VAL_2492]]
// CHECK:         %[[VAL_2494:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2452]] to i8*
// CHECK:         %[[VAL_2495:.*]] = getelementptr inbounds i8, i8* %[[VAL_2494]], i32 %[[VAL_2462]]
// CHECK:         store i8 %[[VAL_2493]], i8* %[[VAL_2495]], align 1
// CHECK:         %[[VAL_2496:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2446]] to i8*
// CHECK:         %[[VAL_2497:.*]] = getelementptr inbounds i8, i8* %[[VAL_2496]], i32 %[[VAL_2466]]
// CHECK:         %[[VAL_2498:.*]] = load i8, i8* %[[VAL_2497]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2499:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2449]] to i8*
// CHECK:         %[[VAL_2500:.*]] = getelementptr inbounds i8, i8* %[[VAL_2499]], i32 %[[VAL_2466]]
// CHECK:         %[[VAL_2501:.*]] = load i8, i8* %[[VAL_2500]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2502:.*]] = or i8 %[[VAL_2498]], %[[VAL_2501]]
// CHECK:         %[[VAL_2503:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2452]] to i8*
// CHECK:         %[[VAL_2504:.*]] = getelementptr inbounds i8, i8* %[[VAL_2503]], i32 %[[VAL_2466]]
// CHECK:         store i8 %[[VAL_2502]], i8* %[[VAL_2504]], align 1
// CHECK:         %[[VAL_2505:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2446]] to i8*
// CHECK:         %[[VAL_2506:.*]] = getelementptr inbounds i8, i8* %[[VAL_2505]], i32 %[[VAL_2470]]
// CHECK:         %[[VAL_2507:.*]] = load i8, i8* %[[VAL_2506]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2508:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2449]] to i8*
// CHECK:         %[[VAL_2509:.*]] = getelementptr inbounds i8, i8* %[[VAL_2508]], i32 %[[VAL_2470]]
// CHECK:         %[[VAL_2510:.*]] = load i8, i8* %[[VAL_2509]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2511:.*]] = or i8 %[[VAL_2507]], %[[VAL_2510]]
// CHECK:         %[[VAL_2512:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2452]] to i8*
// CHECK:         %[[VAL_2513:.*]] = getelementptr inbounds i8, i8* %[[VAL_2512]], i32 %[[VAL_2470]]
// CHECK:         store i8 %[[VAL_2511]], i8* %[[VAL_2513]], align 1
// CHECK:         br label %[[VAL_2476]]
// CHECK:       entry:
// CHECK:         %[[VAL_2514:.*]] = getelementptr inbounds i8, i8* %[[VAL_2515:.*]], i64 0
// CHECK:         %[[VAL_2516:.*]] = bitcast i8* %[[VAL_2514]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_2517:.*]] = getelementptr inbounds i8, i8* %[[VAL_2518:.*]], i64 0
// CHECK:         %[[VAL_2519:.*]] = bitcast i8* %[[VAL_2517]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_2520:.*]] = getelementptr inbounds i8, i8* %[[VAL_2521:.*]], i64 0
// CHECK:         %[[VAL_2522:.*]] = bitcast i8* %[[VAL_2520]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_2523:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2524:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2525:.*]] = mul nuw nsw i32 %[[VAL_2523]], 256
// CHECK:         %[[VAL_2526:.*]] = add nuw nsw i32 %[[VAL_2525]], %[[VAL_2524]]
// CHECK:         %[[VAL_2527:.*]] = icmp ult i32 %[[VAL_2526]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2527]])
// CHECK:         %[[VAL_2528:.*]] = mul nuw nsw i32 %[[VAL_2526]], 4
// CHECK:         %[[VAL_2529:.*]] = udiv i32 %[[VAL_2528]], 1
// CHECK:         %[[VAL_2530:.*]] = urem i32 %[[VAL_2529]], 200
// CHECK:         %[[VAL_2531:.*]] = udiv i32 %[[VAL_2528]], 200
// CHECK:         %[[VAL_2532:.*]] = add nuw nsw i32 %[[VAL_2528]], 1
// CHECK:         %[[VAL_2533:.*]] = udiv i32 %[[VAL_2532]], 1
// CHECK:         %[[VAL_2534:.*]] = urem i32 %[[VAL_2533]], 200
// CHECK:         %[[VAL_2535:.*]] = udiv i32 %[[VAL_2532]], 200
// CHECK:         %[[VAL_2536:.*]] = add nuw nsw i32 %[[VAL_2528]], 2
// CHECK:         %[[VAL_2537:.*]] = udiv i32 %[[VAL_2536]], 1
// CHECK:         %[[VAL_2538:.*]] = urem i32 %[[VAL_2537]], 200
// CHECK:         %[[VAL_2539:.*]] = udiv i32 %[[VAL_2536]], 200
// CHECK:         %[[VAL_2540:.*]] = add nuw nsw i32 %[[VAL_2528]], 3
// CHECK:         %[[VAL_2541:.*]] = udiv i32 %[[VAL_2540]], 1
// CHECK:         %[[VAL_2542:.*]] = urem i32 %[[VAL_2541]], 200
// CHECK:         %[[VAL_2543:.*]] = udiv i32 %[[VAL_2540]], 200
// CHECK:         %[[VAL_2544:.*]] = icmp ult i32 %[[VAL_2528]], 20000
// CHECK:         br i1 %[[VAL_2544]], label %[[VAL_2545:.*]], label %[[VAL_2546:.*]]
// CHECK:       r42.in_bounds-after:                              ; preds = %[[VAL_2545]], %[[VAL_2547:.*]]
// CHECK:         ret void
// CHECK:       r42.in_bounds-true:                               ; preds = %[[VAL_2547]]
// CHECK:         %[[VAL_2548:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2516]] to i32*
// CHECK:         %[[VAL_2549:.*]] = getelementptr inbounds i32, i32* %[[VAL_2548]], i32 %[[VAL_2528]]
// CHECK:         %[[VAL_2550:.*]] = load i32, i32* %[[VAL_2549]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2551:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2519]] to i32*
// CHECK:         %[[VAL_2552:.*]] = getelementptr inbounds i32, i32* %[[VAL_2551]], i32 %[[VAL_2528]]
// CHECK:         %[[VAL_2553:.*]] = load i32, i32* %[[VAL_2552]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2554:.*]] = shl i32 %[[VAL_2550]], %[[VAL_2553]]
// CHECK:         %[[VAL_2555:.*]] = icmp ult i32 %[[VAL_2553]], 32
// CHECK:         %[[VAL_2556:.*]] = select i1 %[[VAL_2555]], i32 %[[VAL_2554]], i32 0
// CHECK:         %[[VAL_2557:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2522]] to i32*
// CHECK:         %[[VAL_2558:.*]] = getelementptr inbounds i32, i32* %[[VAL_2557]], i32 %[[VAL_2528]]
// CHECK:         store i32 %[[VAL_2556]], i32* %[[VAL_2558]], align 4
// CHECK:         %[[VAL_2559:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2516]] to i32*
// CHECK:         %[[VAL_2560:.*]] = getelementptr inbounds i32, i32* %[[VAL_2559]], i32 %[[VAL_2532]]
// CHECK:         %[[VAL_2561:.*]] = load i32, i32* %[[VAL_2560]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2562:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2519]] to i32*
// CHECK:         %[[VAL_2563:.*]] = getelementptr inbounds i32, i32* %[[VAL_2562]], i32 %[[VAL_2532]]
// CHECK:         %[[VAL_2564:.*]] = load i32, i32* %[[VAL_2563]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2565:.*]] = shl i32 %[[VAL_2561]], %[[VAL_2564]]
// CHECK:         %[[VAL_2566:.*]] = icmp ult i32 %[[VAL_2564]], 32
// CHECK:         %[[VAL_2567:.*]] = select i1 %[[VAL_2566]], i32 %[[VAL_2565]], i32 0
// CHECK:         %[[VAL_2568:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2522]] to i32*
// CHECK:         %[[VAL_2569:.*]] = getelementptr inbounds i32, i32* %[[VAL_2568]], i32 %[[VAL_2532]]
// CHECK:         store i32 %[[VAL_2567]], i32* %[[VAL_2569]], align 4
// CHECK:         %[[VAL_2570:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2516]] to i32*
// CHECK:         %[[VAL_2571:.*]] = getelementptr inbounds i32, i32* %[[VAL_2570]], i32 %[[VAL_2536]]
// CHECK:         %[[VAL_2572:.*]] = load i32, i32* %[[VAL_2571]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2573:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2519]] to i32*
// CHECK:         %[[VAL_2574:.*]] = getelementptr inbounds i32, i32* %[[VAL_2573]], i32 %[[VAL_2536]]
// CHECK:         %[[VAL_2575:.*]] = load i32, i32* %[[VAL_2574]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2576:.*]] = shl i32 %[[VAL_2572]], %[[VAL_2575]]
// CHECK:         %[[VAL_2577:.*]] = icmp ult i32 %[[VAL_2575]], 32
// CHECK:         %[[VAL_2578:.*]] = select i1 %[[VAL_2577]], i32 %[[VAL_2576]], i32 0
// CHECK:         %[[VAL_2579:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2522]] to i32*
// CHECK:         %[[VAL_2580:.*]] = getelementptr inbounds i32, i32* %[[VAL_2579]], i32 %[[VAL_2536]]
// CHECK:         store i32 %[[VAL_2578]], i32* %[[VAL_2580]], align 4
// CHECK:         %[[VAL_2581:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2516]] to i32*
// CHECK:         %[[VAL_2582:.*]] = getelementptr inbounds i32, i32* %[[VAL_2581]], i32 %[[VAL_2540]]
// CHECK:         %[[VAL_2583:.*]] = load i32, i32* %[[VAL_2582]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2584:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2519]] to i32*
// CHECK:         %[[VAL_2585:.*]] = getelementptr inbounds i32, i32* %[[VAL_2584]], i32 %[[VAL_2540]]
// CHECK:         %[[VAL_2586:.*]] = load i32, i32* %[[VAL_2585]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2587:.*]] = shl i32 %[[VAL_2583]], %[[VAL_2586]]
// CHECK:         %[[VAL_2588:.*]] = icmp ult i32 %[[VAL_2586]], 32
// CHECK:         %[[VAL_2589:.*]] = select i1 %[[VAL_2588]], i32 %[[VAL_2587]], i32 0
// CHECK:         %[[VAL_2590:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2522]] to i32*
// CHECK:         %[[VAL_2591:.*]] = getelementptr inbounds i32, i32* %[[VAL_2590]], i32 %[[VAL_2540]]
// CHECK:         store i32 %[[VAL_2589]], i32* %[[VAL_2591]], align 4
// CHECK:         br label %[[VAL_2546]]
// CHECK:       entry:
// CHECK:         %[[VAL_2592:.*]] = getelementptr inbounds i8, i8* %[[VAL_2593:.*]], i64 0
// CHECK:         %[[VAL_2594:.*]] = bitcast i8* %[[VAL_2592]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_2595:.*]] = getelementptr inbounds i8, i8* %[[VAL_2596:.*]], i64 0
// CHECK:         %[[VAL_2597:.*]] = bitcast i8* %[[VAL_2595]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_2598:.*]] = getelementptr inbounds i8, i8* %[[VAL_2599:.*]], i64 0
// CHECK:         %[[VAL_2600:.*]] = bitcast i8* %[[VAL_2598]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_2601:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2602:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2603:.*]] = mul nuw nsw i32 %[[VAL_2601]], 256
// CHECK:         %[[VAL_2604:.*]] = add nuw nsw i32 %[[VAL_2603]], %[[VAL_2602]]
// CHECK:         %[[VAL_2605:.*]] = icmp ult i32 %[[VAL_2604]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2605]])
// CHECK:         %[[VAL_2606:.*]] = mul nuw nsw i32 %[[VAL_2604]], 4
// CHECK:         %[[VAL_2607:.*]] = udiv i32 %[[VAL_2606]], 1
// CHECK:         %[[VAL_2608:.*]] = urem i32 %[[VAL_2607]], 200
// CHECK:         %[[VAL_2609:.*]] = udiv i32 %[[VAL_2606]], 200
// CHECK:         %[[VAL_2610:.*]] = add nuw nsw i32 %[[VAL_2606]], 1
// CHECK:         %[[VAL_2611:.*]] = udiv i32 %[[VAL_2610]], 1
// CHECK:         %[[VAL_2612:.*]] = urem i32 %[[VAL_2611]], 200
// CHECK:         %[[VAL_2613:.*]] = udiv i32 %[[VAL_2610]], 200
// CHECK:         %[[VAL_2614:.*]] = add nuw nsw i32 %[[VAL_2606]], 2
// CHECK:         %[[VAL_2615:.*]] = udiv i32 %[[VAL_2614]], 1
// CHECK:         %[[VAL_2616:.*]] = urem i32 %[[VAL_2615]], 200
// CHECK:         %[[VAL_2617:.*]] = udiv i32 %[[VAL_2614]], 200
// CHECK:         %[[VAL_2618:.*]] = add nuw nsw i32 %[[VAL_2606]], 3
// CHECK:         %[[VAL_2619:.*]] = udiv i32 %[[VAL_2618]], 1
// CHECK:         %[[VAL_2620:.*]] = urem i32 %[[VAL_2619]], 200
// CHECK:         %[[VAL_2621:.*]] = udiv i32 %[[VAL_2618]], 200
// CHECK:         %[[VAL_2622:.*]] = icmp ult i32 %[[VAL_2606]], 20000
// CHECK:         br i1 %[[VAL_2622]], label %[[VAL_2623:.*]], label %[[VAL_2624:.*]]
// CHECK:       r43.in_bounds-after:                              ; preds = %[[VAL_2623]], %[[VAL_2625:.*]]
// CHECK:         ret void
// CHECK:       r43.in_bounds-true:                               ; preds = %[[VAL_2625]]
// CHECK:         %[[VAL_2626:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2594]] to i32*
// CHECK:         %[[VAL_2627:.*]] = getelementptr inbounds i32, i32* %[[VAL_2626]], i32 %[[VAL_2606]]
// CHECK:         %[[VAL_2628:.*]] = load i32, i32* %[[VAL_2627]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2629:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2597]] to i32*
// CHECK:         %[[VAL_2630:.*]] = getelementptr inbounds i32, i32* %[[VAL_2629]], i32 %[[VAL_2606]]
// CHECK:         %[[VAL_2631:.*]] = load i32, i32* %[[VAL_2630]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2632:.*]] = ashr i32 %[[VAL_2628]], %[[VAL_2631]]
// CHECK:         %[[VAL_2633:.*]] = icmp slt i32 %[[VAL_2628]], 0
// CHECK:         %[[VAL_2634:.*]] = select i1 %[[VAL_2633]], i32 -1, i32 0
// CHECK:         %[[VAL_2635:.*]] = icmp ult i32 %[[VAL_2631]], 32
// CHECK:         %[[VAL_2636:.*]] = select i1 %[[VAL_2635]], i32 %[[VAL_2632]], i32 %[[VAL_2634]]
// CHECK:         %[[VAL_2637:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2600]] to i32*
// CHECK:         %[[VAL_2638:.*]] = getelementptr inbounds i32, i32* %[[VAL_2637]], i32 %[[VAL_2606]]
// CHECK:         store i32 %[[VAL_2636]], i32* %[[VAL_2638]], align 4
// CHECK:         %[[VAL_2639:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2594]] to i32*
// CHECK:         %[[VAL_2640:.*]] = getelementptr inbounds i32, i32* %[[VAL_2639]], i32 %[[VAL_2610]]
// CHECK:         %[[VAL_2641:.*]] = load i32, i32* %[[VAL_2640]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2642:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2597]] to i32*
// CHECK:         %[[VAL_2643:.*]] = getelementptr inbounds i32, i32* %[[VAL_2642]], i32 %[[VAL_2610]]
// CHECK:         %[[VAL_2644:.*]] = load i32, i32* %[[VAL_2643]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2645:.*]] = ashr i32 %[[VAL_2641]], %[[VAL_2644]]
// CHECK:         %[[VAL_2646:.*]] = icmp slt i32 %[[VAL_2641]], 0
// CHECK:         %[[VAL_2647:.*]] = select i1 %[[VAL_2646]], i32 -1, i32 0
// CHECK:         %[[VAL_2648:.*]] = icmp ult i32 %[[VAL_2644]], 32
// CHECK:         %[[VAL_2649:.*]] = select i1 %[[VAL_2648]], i32 %[[VAL_2645]], i32 %[[VAL_2647]]
// CHECK:         %[[VAL_2650:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2600]] to i32*
// CHECK:         %[[VAL_2651:.*]] = getelementptr inbounds i32, i32* %[[VAL_2650]], i32 %[[VAL_2610]]
// CHECK:         store i32 %[[VAL_2649]], i32* %[[VAL_2651]], align 4
// CHECK:         %[[VAL_2652:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2594]] to i32*
// CHECK:         %[[VAL_2653:.*]] = getelementptr inbounds i32, i32* %[[VAL_2652]], i32 %[[VAL_2614]]
// CHECK:         %[[VAL_2654:.*]] = load i32, i32* %[[VAL_2653]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2655:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2597]] to i32*
// CHECK:         %[[VAL_2656:.*]] = getelementptr inbounds i32, i32* %[[VAL_2655]], i32 %[[VAL_2614]]
// CHECK:         %[[VAL_2657:.*]] = load i32, i32* %[[VAL_2656]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2658:.*]] = ashr i32 %[[VAL_2654]], %[[VAL_2657]]
// CHECK:         %[[VAL_2659:.*]] = icmp slt i32 %[[VAL_2654]], 0
// CHECK:         %[[VAL_2660:.*]] = select i1 %[[VAL_2659]], i32 -1, i32 0
// CHECK:         %[[VAL_2661:.*]] = icmp ult i32 %[[VAL_2657]], 32
// CHECK:         %[[VAL_2662:.*]] = select i1 %[[VAL_2661]], i32 %[[VAL_2658]], i32 %[[VAL_2660]]
// CHECK:         %[[VAL_2663:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2600]] to i32*
// CHECK:         %[[VAL_2664:.*]] = getelementptr inbounds i32, i32* %[[VAL_2663]], i32 %[[VAL_2614]]
// CHECK:         store i32 %[[VAL_2662]], i32* %[[VAL_2664]], align 4
// CHECK:         %[[VAL_2665:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2594]] to i32*
// CHECK:         %[[VAL_2666:.*]] = getelementptr inbounds i32, i32* %[[VAL_2665]], i32 %[[VAL_2618]]
// CHECK:         %[[VAL_2667:.*]] = load i32, i32* %[[VAL_2666]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2668:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2597]] to i32*
// CHECK:         %[[VAL_2669:.*]] = getelementptr inbounds i32, i32* %[[VAL_2668]], i32 %[[VAL_2618]]
// CHECK:         %[[VAL_2670:.*]] = load i32, i32* %[[VAL_2669]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2671:.*]] = ashr i32 %[[VAL_2667]], %[[VAL_2670]]
// CHECK:         %[[VAL_2672:.*]] = icmp slt i32 %[[VAL_2667]], 0
// CHECK:         %[[VAL_2673:.*]] = select i1 %[[VAL_2672]], i32 -1, i32 0
// CHECK:         %[[VAL_2674:.*]] = icmp ult i32 %[[VAL_2670]], 32
// CHECK:         %[[VAL_2675:.*]] = select i1 %[[VAL_2674]], i32 %[[VAL_2671]], i32 %[[VAL_2673]]
// CHECK:         %[[VAL_2676:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2600]] to i32*
// CHECK:         %[[VAL_2677:.*]] = getelementptr inbounds i32, i32* %[[VAL_2676]], i32 %[[VAL_2618]]
// CHECK:         store i32 %[[VAL_2675]], i32* %[[VAL_2677]], align 4
// CHECK:         br label %[[VAL_2624]]
// CHECK:       entry:
// CHECK:         %[[VAL_2678:.*]] = getelementptr inbounds i8, i8* %[[VAL_2679:.*]], i64 0
// CHECK:         %[[VAL_2680:.*]] = bitcast i8* %[[VAL_2678]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_2681:.*]] = getelementptr inbounds i8, i8* %[[VAL_2682:.*]], i64 0
// CHECK:         %[[VAL_2683:.*]] = bitcast i8* %[[VAL_2681]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_2684:.*]] = getelementptr inbounds i8, i8* %[[VAL_2685:.*]], i64 0
// CHECK:         %[[VAL_2686:.*]] = bitcast i8* %[[VAL_2684]] to [100 x [200 x i32]]*
// CHECK:         %[[VAL_2687:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2688:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2689:.*]] = mul nuw nsw i32 %[[VAL_2687]], 256
// CHECK:         %[[VAL_2690:.*]] = add nuw nsw i32 %[[VAL_2689]], %[[VAL_2688]]
// CHECK:         %[[VAL_2691:.*]] = icmp ult i32 %[[VAL_2690]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2691]])
// CHECK:         %[[VAL_2692:.*]] = mul nuw nsw i32 %[[VAL_2690]], 4
// CHECK:         %[[VAL_2693:.*]] = udiv i32 %[[VAL_2692]], 1
// CHECK:         %[[VAL_2694:.*]] = urem i32 %[[VAL_2693]], 200
// CHECK:         %[[VAL_2695:.*]] = udiv i32 %[[VAL_2692]], 200
// CHECK:         %[[VAL_2696:.*]] = add nuw nsw i32 %[[VAL_2692]], 1
// CHECK:         %[[VAL_2697:.*]] = udiv i32 %[[VAL_2696]], 1
// CHECK:         %[[VAL_2698:.*]] = urem i32 %[[VAL_2697]], 200
// CHECK:         %[[VAL_2699:.*]] = udiv i32 %[[VAL_2696]], 200
// CHECK:         %[[VAL_2700:.*]] = add nuw nsw i32 %[[VAL_2692]], 2
// CHECK:         %[[VAL_2701:.*]] = udiv i32 %[[VAL_2700]], 1
// CHECK:         %[[VAL_2702:.*]] = urem i32 %[[VAL_2701]], 200
// CHECK:         %[[VAL_2703:.*]] = udiv i32 %[[VAL_2700]], 200
// CHECK:         %[[VAL_2704:.*]] = add nuw nsw i32 %[[VAL_2692]], 3
// CHECK:         %[[VAL_2705:.*]] = udiv i32 %[[VAL_2704]], 1
// CHECK:         %[[VAL_2706:.*]] = urem i32 %[[VAL_2705]], 200
// CHECK:         %[[VAL_2707:.*]] = udiv i32 %[[VAL_2704]], 200
// CHECK:         %[[VAL_2708:.*]] = icmp ult i32 %[[VAL_2692]], 20000
// CHECK:         br i1 %[[VAL_2708]], label %[[VAL_2709:.*]], label %[[VAL_2710:.*]]
// CHECK:       r44.in_bounds-after:                              ; preds = %[[VAL_2709]], %[[VAL_2711:.*]]
// CHECK:         ret void
// CHECK:       r44.in_bounds-true:                               ; preds = %[[VAL_2711]]
// CHECK:         %[[VAL_2712:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2680]] to i32*
// CHECK:         %[[VAL_2713:.*]] = getelementptr inbounds i32, i32* %[[VAL_2712]], i32 %[[VAL_2692]]
// CHECK:         %[[VAL_2714:.*]] = load i32, i32* %[[VAL_2713]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2715:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2683]] to i32*
// CHECK:         %[[VAL_2716:.*]] = getelementptr inbounds i32, i32* %[[VAL_2715]], i32 %[[VAL_2692]]
// CHECK:         %[[VAL_2717:.*]] = load i32, i32* %[[VAL_2716]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2718:.*]] = lshr i32 %[[VAL_2714]], %[[VAL_2717]]
// CHECK:         %[[VAL_2719:.*]] = icmp ult i32 %[[VAL_2717]], 32
// CHECK:         %[[VAL_2720:.*]] = select i1 %[[VAL_2719]], i32 %[[VAL_2718]], i32 0
// CHECK:         %[[VAL_2721:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2686]] to i32*
// CHECK:         %[[VAL_2722:.*]] = getelementptr inbounds i32, i32* %[[VAL_2721]], i32 %[[VAL_2692]]
// CHECK:         store i32 %[[VAL_2720]], i32* %[[VAL_2722]], align 4
// CHECK:         %[[VAL_2723:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2680]] to i32*
// CHECK:         %[[VAL_2724:.*]] = getelementptr inbounds i32, i32* %[[VAL_2723]], i32 %[[VAL_2696]]
// CHECK:         %[[VAL_2725:.*]] = load i32, i32* %[[VAL_2724]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2726:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2683]] to i32*
// CHECK:         %[[VAL_2727:.*]] = getelementptr inbounds i32, i32* %[[VAL_2726]], i32 %[[VAL_2696]]
// CHECK:         %[[VAL_2728:.*]] = load i32, i32* %[[VAL_2727]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2729:.*]] = lshr i32 %[[VAL_2725]], %[[VAL_2728]]
// CHECK:         %[[VAL_2730:.*]] = icmp ult i32 %[[VAL_2728]], 32
// CHECK:         %[[VAL_2731:.*]] = select i1 %[[VAL_2730]], i32 %[[VAL_2729]], i32 0
// CHECK:         %[[VAL_2732:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2686]] to i32*
// CHECK:         %[[VAL_2733:.*]] = getelementptr inbounds i32, i32* %[[VAL_2732]], i32 %[[VAL_2696]]
// CHECK:         store i32 %[[VAL_2731]], i32* %[[VAL_2733]], align 4
// CHECK:         %[[VAL_2734:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2680]] to i32*
// CHECK:         %[[VAL_2735:.*]] = getelementptr inbounds i32, i32* %[[VAL_2734]], i32 %[[VAL_2700]]
// CHECK:         %[[VAL_2736:.*]] = load i32, i32* %[[VAL_2735]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2737:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2683]] to i32*
// CHECK:         %[[VAL_2738:.*]] = getelementptr inbounds i32, i32* %[[VAL_2737]], i32 %[[VAL_2700]]
// CHECK:         %[[VAL_2739:.*]] = load i32, i32* %[[VAL_2738]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2740:.*]] = lshr i32 %[[VAL_2736]], %[[VAL_2739]]
// CHECK:         %[[VAL_2741:.*]] = icmp ult i32 %[[VAL_2739]], 32
// CHECK:         %[[VAL_2742:.*]] = select i1 %[[VAL_2741]], i32 %[[VAL_2740]], i32 0
// CHECK:         %[[VAL_2743:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2686]] to i32*
// CHECK:         %[[VAL_2744:.*]] = getelementptr inbounds i32, i32* %[[VAL_2743]], i32 %[[VAL_2700]]
// CHECK:         store i32 %[[VAL_2742]], i32* %[[VAL_2744]], align 4
// CHECK:         %[[VAL_2745:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2680]] to i32*
// CHECK:         %[[VAL_2746:.*]] = getelementptr inbounds i32, i32* %[[VAL_2745]], i32 %[[VAL_2704]]
// CHECK:         %[[VAL_2747:.*]] = load i32, i32* %[[VAL_2746]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2748:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2683]] to i32*
// CHECK:         %[[VAL_2749:.*]] = getelementptr inbounds i32, i32* %[[VAL_2748]], i32 %[[VAL_2704]]
// CHECK:         %[[VAL_2750:.*]] = load i32, i32* %[[VAL_2749]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2751:.*]] = lshr i32 %[[VAL_2747]], %[[VAL_2750]]
// CHECK:         %[[VAL_2752:.*]] = icmp ult i32 %[[VAL_2750]], 32
// CHECK:         %[[VAL_2753:.*]] = select i1 %[[VAL_2752]], i32 %[[VAL_2751]], i32 0
// CHECK:         %[[VAL_2754:.*]] = bitcast [100 x [200 x i32]]* %[[VAL_2686]] to i32*
// CHECK:         %[[VAL_2755:.*]] = getelementptr inbounds i32, i32* %[[VAL_2754]], i32 %[[VAL_2704]]
// CHECK:         store i32 %[[VAL_2753]], i32* %[[VAL_2755]], align 4
// CHECK:         br label %[[VAL_2710]]
// CHECK:       entry:
// CHECK:         %[[VAL_2756:.*]] = getelementptr inbounds i8, i8* %[[VAL_2757:.*]], i64 0
// CHECK:         %[[VAL_2758:.*]] = bitcast i8* %[[VAL_2756]] to [100 x [200 x i8]]*
// CHECK:         %[[VAL_2759:.*]] = getelementptr inbounds i8, i8* %[[VAL_2760:.*]], i64 0
// CHECK:         %[[VAL_2761:.*]] = bitcast i8* %[[VAL_2759]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2762:.*]] = getelementptr inbounds i8, i8* %[[VAL_2763:.*]], i64 0
// CHECK:         %[[VAL_2764:.*]] = bitcast i8* %[[VAL_2762]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2765:.*]] = getelementptr inbounds i8, i8* %[[VAL_2766:.*]], i64 0
// CHECK:         %[[VAL_2767:.*]] = bitcast i8* %[[VAL_2765]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2768:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2769:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2770:.*]] = mul nuw nsw i32 %[[VAL_2768]], 256
// CHECK:         %[[VAL_2771:.*]] = add nuw nsw i32 %[[VAL_2770]], %[[VAL_2769]]
// CHECK:         %[[VAL_2772:.*]] = icmp ult i32 %[[VAL_2771]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2772]])
// CHECK:         %[[VAL_2773:.*]] = mul nuw nsw i32 %[[VAL_2771]], 4
// CHECK:         %[[VAL_2774:.*]] = udiv i32 %[[VAL_2773]], 1
// CHECK:         %[[VAL_2775:.*]] = urem i32 %[[VAL_2774]], 200
// CHECK:         %[[VAL_2776:.*]] = udiv i32 %[[VAL_2773]], 200
// CHECK:         %[[VAL_2777:.*]] = add nuw nsw i32 %[[VAL_2773]], 1
// CHECK:         %[[VAL_2778:.*]] = udiv i32 %[[VAL_2777]], 1
// CHECK:         %[[VAL_2779:.*]] = urem i32 %[[VAL_2778]], 200
// CHECK:         %[[VAL_2780:.*]] = udiv i32 %[[VAL_2777]], 200
// CHECK:         %[[VAL_2781:.*]] = add nuw nsw i32 %[[VAL_2773]], 2
// CHECK:         %[[VAL_2782:.*]] = udiv i32 %[[VAL_2781]], 1
// CHECK:         %[[VAL_2783:.*]] = urem i32 %[[VAL_2782]], 200
// CHECK:         %[[VAL_2784:.*]] = udiv i32 %[[VAL_2781]], 200
// CHECK:         %[[VAL_2785:.*]] = add nuw nsw i32 %[[VAL_2773]], 3
// CHECK:         %[[VAL_2786:.*]] = udiv i32 %[[VAL_2785]], 1
// CHECK:         %[[VAL_2787:.*]] = urem i32 %[[VAL_2786]], 200
// CHECK:         %[[VAL_2788:.*]] = udiv i32 %[[VAL_2785]], 200
// CHECK:         %[[VAL_2789:.*]] = icmp ult i32 %[[VAL_2773]], 20000
// CHECK:         br i1 %[[VAL_2789]], label %[[VAL_2790:.*]], label %[[VAL_2791:.*]]
// CHECK:       r45.in_bounds-after:                              ; preds = %[[VAL_2790]], %[[VAL_2792:.*]]
// CHECK:         ret void
// CHECK:       r45.in_bounds-true:                               ; preds = %[[VAL_2792]]
// CHECK:         %[[VAL_2793:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2758]] to i8*
// CHECK:         %[[VAL_2794:.*]] = getelementptr inbounds i8, i8* %[[VAL_2793]], i32 %[[VAL_2773]]
// CHECK:         %[[VAL_2795:.*]] = load i8, i8* %[[VAL_2794]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2796:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2761]] to float*
// CHECK:         %[[VAL_2797:.*]] = getelementptr inbounds float, float* %[[VAL_2796]], i32 %[[VAL_2773]]
// CHECK:         %[[VAL_2798:.*]] = load float, float* %[[VAL_2797]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2799:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2764]] to float*
// CHECK:         %[[VAL_2800:.*]] = getelementptr inbounds float, float* %[[VAL_2799]], i32 %[[VAL_2773]]
// CHECK:         %[[VAL_2801:.*]] = load float, float* %[[VAL_2800]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2802:.*]] = trunc i8 %[[VAL_2795]] to i1
// CHECK:         %[[VAL_2803:.*]] = select i1 %[[VAL_2802]], float %[[VAL_2798]], float %[[VAL_2801]]
// CHECK:         %[[VAL_2804:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2767]] to float*
// CHECK:         %[[VAL_2805:.*]] = getelementptr inbounds float, float* %[[VAL_2804]], i32 %[[VAL_2773]]
// CHECK:         store float %[[VAL_2803]], float* %[[VAL_2805]], align 4
// CHECK:         %[[VAL_2806:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2758]] to i8*
// CHECK:         %[[VAL_2807:.*]] = getelementptr inbounds i8, i8* %[[VAL_2806]], i32 %[[VAL_2777]]
// CHECK:         %[[VAL_2808:.*]] = load i8, i8* %[[VAL_2807]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2809:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2761]] to float*
// CHECK:         %[[VAL_2810:.*]] = getelementptr inbounds float, float* %[[VAL_2809]], i32 %[[VAL_2777]]
// CHECK:         %[[VAL_2811:.*]] = load float, float* %[[VAL_2810]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2812:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2764]] to float*
// CHECK:         %[[VAL_2813:.*]] = getelementptr inbounds float, float* %[[VAL_2812]], i32 %[[VAL_2777]]
// CHECK:         %[[VAL_2814:.*]] = load float, float* %[[VAL_2813]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2815:.*]] = trunc i8 %[[VAL_2808]] to i1
// CHECK:         %[[VAL_2816:.*]] = select i1 %[[VAL_2815]], float %[[VAL_2811]], float %[[VAL_2814]]
// CHECK:         %[[VAL_2817:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2767]] to float*
// CHECK:         %[[VAL_2818:.*]] = getelementptr inbounds float, float* %[[VAL_2817]], i32 %[[VAL_2777]]
// CHECK:         store float %[[VAL_2816]], float* %[[VAL_2818]], align 4
// CHECK:         %[[VAL_2819:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2758]] to i8*
// CHECK:         %[[VAL_2820:.*]] = getelementptr inbounds i8, i8* %[[VAL_2819]], i32 %[[VAL_2781]]
// CHECK:         %[[VAL_2821:.*]] = load i8, i8* %[[VAL_2820]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2822:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2761]] to float*
// CHECK:         %[[VAL_2823:.*]] = getelementptr inbounds float, float* %[[VAL_2822]], i32 %[[VAL_2781]]
// CHECK:         %[[VAL_2824:.*]] = load float, float* %[[VAL_2823]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2825:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2764]] to float*
// CHECK:         %[[VAL_2826:.*]] = getelementptr inbounds float, float* %[[VAL_2825]], i32 %[[VAL_2781]]
// CHECK:         %[[VAL_2827:.*]] = load float, float* %[[VAL_2826]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2828:.*]] = trunc i8 %[[VAL_2821]] to i1
// CHECK:         %[[VAL_2829:.*]] = select i1 %[[VAL_2828]], float %[[VAL_2824]], float %[[VAL_2827]]
// CHECK:         %[[VAL_2830:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2767]] to float*
// CHECK:         %[[VAL_2831:.*]] = getelementptr inbounds float, float* %[[VAL_2830]], i32 %[[VAL_2781]]
// CHECK:         store float %[[VAL_2829]], float* %[[VAL_2831]], align 4
// CHECK:         %[[VAL_2832:.*]] = bitcast [100 x [200 x i8]]* %[[VAL_2758]] to i8*
// CHECK:         %[[VAL_2833:.*]] = getelementptr inbounds i8, i8* %[[VAL_2832]], i32 %[[VAL_2785]]
// CHECK:         %[[VAL_2834:.*]] = load i8, i8* %[[VAL_2833]], align 1, !invariant.load !94
// CHECK:         %[[VAL_2835:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2761]] to float*
// CHECK:         %[[VAL_2836:.*]] = getelementptr inbounds float, float* %[[VAL_2835]], i32 %[[VAL_2785]]
// CHECK:         %[[VAL_2837:.*]] = load float, float* %[[VAL_2836]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2838:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2764]] to float*
// CHECK:         %[[VAL_2839:.*]] = getelementptr inbounds float, float* %[[VAL_2838]], i32 %[[VAL_2785]]
// CHECK:         %[[VAL_2840:.*]] = load float, float* %[[VAL_2839]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2841:.*]] = trunc i8 %[[VAL_2834]] to i1
// CHECK:         %[[VAL_2842:.*]] = select i1 %[[VAL_2841]], float %[[VAL_2837]], float %[[VAL_2840]]
// CHECK:         %[[VAL_2843:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2767]] to float*
// CHECK:         %[[VAL_2844:.*]] = getelementptr inbounds float, float* %[[VAL_2843]], i32 %[[VAL_2785]]
// CHECK:         store float %[[VAL_2842]], float* %[[VAL_2844]], align 4
// CHECK:         br label %[[VAL_2791]]
// CHECK:       entry:
// CHECK:         %[[VAL_2845:.*]] = getelementptr inbounds i8, i8* %[[VAL_2846:.*]], i64 0
// CHECK:         %[[VAL_2847:.*]] = bitcast i8* %[[VAL_2845]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2848:.*]] = getelementptr inbounds i8, i8* %[[VAL_2849:.*]], i64 0
// CHECK:         %[[VAL_2850:.*]] = bitcast i8* %[[VAL_2848]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2851:.*]] = getelementptr inbounds i8, i8* %[[VAL_2852:.*]], i64 0
// CHECK:         %[[VAL_2853:.*]] = bitcast i8* %[[VAL_2851]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2854:.*]] = getelementptr inbounds i8, i8* %[[VAL_2855:.*]], i64 0
// CHECK:         %[[VAL_2856:.*]] = bitcast i8* %[[VAL_2854]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2857:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2858:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2859:.*]] = mul nuw nsw i32 %[[VAL_2857]], 256
// CHECK:         %[[VAL_2860:.*]] = add nuw nsw i32 %[[VAL_2859]], %[[VAL_2858]]
// CHECK:         %[[VAL_2861:.*]] = icmp ult i32 %[[VAL_2860]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2861]])
// CHECK:         %[[VAL_2862:.*]] = mul nuw nsw i32 %[[VAL_2860]], 4
// CHECK:         %[[VAL_2863:.*]] = udiv i32 %[[VAL_2862]], 1
// CHECK:         %[[VAL_2864:.*]] = urem i32 %[[VAL_2863]], 200
// CHECK:         %[[VAL_2865:.*]] = udiv i32 %[[VAL_2862]], 200
// CHECK:         %[[VAL_2866:.*]] = add nuw nsw i32 %[[VAL_2862]], 1
// CHECK:         %[[VAL_2867:.*]] = udiv i32 %[[VAL_2866]], 1
// CHECK:         %[[VAL_2868:.*]] = urem i32 %[[VAL_2867]], 200
// CHECK:         %[[VAL_2869:.*]] = udiv i32 %[[VAL_2866]], 200
// CHECK:         %[[VAL_2870:.*]] = add nuw nsw i32 %[[VAL_2862]], 2
// CHECK:         %[[VAL_2871:.*]] = udiv i32 %[[VAL_2870]], 1
// CHECK:         %[[VAL_2872:.*]] = urem i32 %[[VAL_2871]], 200
// CHECK:         %[[VAL_2873:.*]] = udiv i32 %[[VAL_2870]], 200
// CHECK:         %[[VAL_2874:.*]] = add nuw nsw i32 %[[VAL_2862]], 3
// CHECK:         %[[VAL_2875:.*]] = udiv i32 %[[VAL_2874]], 1
// CHECK:         %[[VAL_2876:.*]] = urem i32 %[[VAL_2875]], 200
// CHECK:         %[[VAL_2877:.*]] = udiv i32 %[[VAL_2874]], 200
// CHECK:         %[[VAL_2878:.*]] = icmp ult i32 %[[VAL_2862]], 20000
// CHECK:         br i1 %[[VAL_2878]], label %[[VAL_2879:.*]], label %[[VAL_2880:.*]]
// CHECK:       r46.in_bounds-after:                              ; preds = %[[VAL_2879]], %[[VAL_2881:.*]]
// CHECK:         ret void
// CHECK:       r46.in_bounds-true:                               ; preds = %[[VAL_2881]]
// CHECK:         %[[VAL_2882:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2847]] to float*
// CHECK:         %[[VAL_2883:.*]] = getelementptr inbounds float, float* %[[VAL_2882]], i32 %[[VAL_2862]]
// CHECK:         %[[VAL_2884:.*]] = load float, float* %[[VAL_2883]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2885:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2850]] to float*
// CHECK:         %[[VAL_2886:.*]] = getelementptr inbounds float, float* %[[VAL_2885]], i32 %[[VAL_2862]]
// CHECK:         %[[VAL_2887:.*]] = load float, float* %[[VAL_2886]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2888:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2853]] to float*
// CHECK:         %[[VAL_2889:.*]] = getelementptr inbounds float, float* %[[VAL_2888]], i32 %[[VAL_2862]]
// CHECK:         %[[VAL_2890:.*]] = load float, float* %[[VAL_2889]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2891:.*]] = fcmp uge float %[[VAL_2884]], %[[VAL_2887]]
// CHECK:         %[[VAL_2892:.*]] = select i1 %[[VAL_2891]], float %[[VAL_2884]], float %[[VAL_2887]]
// CHECK:         %[[VAL_2893:.*]] = fcmp ule float %[[VAL_2890]], %[[VAL_2892]]
// CHECK:         %[[VAL_2894:.*]] = select i1 %[[VAL_2893]], float %[[VAL_2890]], float %[[VAL_2892]]
// CHECK:         %[[VAL_2895:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2856]] to float*
// CHECK:         %[[VAL_2896:.*]] = getelementptr inbounds float, float* %[[VAL_2895]], i32 %[[VAL_2862]]
// CHECK:         store float %[[VAL_2894]], float* %[[VAL_2896]], align 4
// CHECK:         %[[VAL_2897:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2847]] to float*
// CHECK:         %[[VAL_2898:.*]] = getelementptr inbounds float, float* %[[VAL_2897]], i32 %[[VAL_2866]]
// CHECK:         %[[VAL_2899:.*]] = load float, float* %[[VAL_2898]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2900:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2850]] to float*
// CHECK:         %[[VAL_2901:.*]] = getelementptr inbounds float, float* %[[VAL_2900]], i32 %[[VAL_2866]]
// CHECK:         %[[VAL_2902:.*]] = load float, float* %[[VAL_2901]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2903:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2853]] to float*
// CHECK:         %[[VAL_2904:.*]] = getelementptr inbounds float, float* %[[VAL_2903]], i32 %[[VAL_2866]]
// CHECK:         %[[VAL_2905:.*]] = load float, float* %[[VAL_2904]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2906:.*]] = fcmp uge float %[[VAL_2899]], %[[VAL_2902]]
// CHECK:         %[[VAL_2907:.*]] = select i1 %[[VAL_2906]], float %[[VAL_2899]], float %[[VAL_2902]]
// CHECK:         %[[VAL_2908:.*]] = fcmp ule float %[[VAL_2905]], %[[VAL_2907]]
// CHECK:         %[[VAL_2909:.*]] = select i1 %[[VAL_2908]], float %[[VAL_2905]], float %[[VAL_2907]]
// CHECK:         %[[VAL_2910:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2856]] to float*
// CHECK:         %[[VAL_2911:.*]] = getelementptr inbounds float, float* %[[VAL_2910]], i32 %[[VAL_2866]]
// CHECK:         store float %[[VAL_2909]], float* %[[VAL_2911]], align 4
// CHECK:         %[[VAL_2912:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2847]] to float*
// CHECK:         %[[VAL_2913:.*]] = getelementptr inbounds float, float* %[[VAL_2912]], i32 %[[VAL_2870]]
// CHECK:         %[[VAL_2914:.*]] = load float, float* %[[VAL_2913]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2915:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2850]] to float*
// CHECK:         %[[VAL_2916:.*]] = getelementptr inbounds float, float* %[[VAL_2915]], i32 %[[VAL_2870]]
// CHECK:         %[[VAL_2917:.*]] = load float, float* %[[VAL_2916]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2918:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2853]] to float*
// CHECK:         %[[VAL_2919:.*]] = getelementptr inbounds float, float* %[[VAL_2918]], i32 %[[VAL_2870]]
// CHECK:         %[[VAL_2920:.*]] = load float, float* %[[VAL_2919]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2921:.*]] = fcmp uge float %[[VAL_2914]], %[[VAL_2917]]
// CHECK:         %[[VAL_2922:.*]] = select i1 %[[VAL_2921]], float %[[VAL_2914]], float %[[VAL_2917]]
// CHECK:         %[[VAL_2923:.*]] = fcmp ule float %[[VAL_2920]], %[[VAL_2922]]
// CHECK:         %[[VAL_2924:.*]] = select i1 %[[VAL_2923]], float %[[VAL_2920]], float %[[VAL_2922]]
// CHECK:         %[[VAL_2925:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2856]] to float*
// CHECK:         %[[VAL_2926:.*]] = getelementptr inbounds float, float* %[[VAL_2925]], i32 %[[VAL_2870]]
// CHECK:         store float %[[VAL_2924]], float* %[[VAL_2926]], align 4
// CHECK:         %[[VAL_2927:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2847]] to float*
// CHECK:         %[[VAL_2928:.*]] = getelementptr inbounds float, float* %[[VAL_2927]], i32 %[[VAL_2874]]
// CHECK:         %[[VAL_2929:.*]] = load float, float* %[[VAL_2928]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2930:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2850]] to float*
// CHECK:         %[[VAL_2931:.*]] = getelementptr inbounds float, float* %[[VAL_2930]], i32 %[[VAL_2874]]
// CHECK:         %[[VAL_2932:.*]] = load float, float* %[[VAL_2931]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2933:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2853]] to float*
// CHECK:         %[[VAL_2934:.*]] = getelementptr inbounds float, float* %[[VAL_2933]], i32 %[[VAL_2874]]
// CHECK:         %[[VAL_2935:.*]] = load float, float* %[[VAL_2934]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2936:.*]] = fcmp uge float %[[VAL_2929]], %[[VAL_2932]]
// CHECK:         %[[VAL_2937:.*]] = select i1 %[[VAL_2936]], float %[[VAL_2929]], float %[[VAL_2932]]
// CHECK:         %[[VAL_2938:.*]] = fcmp ule float %[[VAL_2935]], %[[VAL_2937]]
// CHECK:         %[[VAL_2939:.*]] = select i1 %[[VAL_2938]], float %[[VAL_2935]], float %[[VAL_2937]]
// CHECK:         %[[VAL_2940:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2856]] to float*
// CHECK:         %[[VAL_2941:.*]] = getelementptr inbounds float, float* %[[VAL_2940]], i32 %[[VAL_2874]]
// CHECK:         store float %[[VAL_2939]], float* %[[VAL_2941]], align 4
// CHECK:         br label %[[VAL_2880]]
// CHECK:       entry:
// CHECK:         %[[VAL_2942:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2943:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2944:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2945:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2946:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2947:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2948:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2949:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2950:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2951:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2952:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2953:.*]] = alloca float, align 4
// CHECK:         %[[VAL_2954:.*]] = getelementptr inbounds i8, i8* %[[VAL_2955:.*]], i64 0
// CHECK:         %[[VAL_2956:.*]] = bitcast i8* %[[VAL_2954]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2957:.*]] = getelementptr inbounds i8, i8* %[[VAL_2958:.*]], i64 0
// CHECK:         %[[VAL_2959:.*]] = bitcast i8* %[[VAL_2957]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2960:.*]] = getelementptr inbounds i8, i8* %[[VAL_2961:.*]], i64 0
// CHECK:         %[[VAL_2962:.*]] = bitcast i8* %[[VAL_2960]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_2963:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !92
// CHECK:         %[[VAL_2964:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !93
// CHECK:         %[[VAL_2965:.*]] = mul nuw nsw i32 %[[VAL_2963]], 256
// CHECK:         %[[VAL_2966:.*]] = add nuw nsw i32 %[[VAL_2965]], %[[VAL_2964]]
// CHECK:         %[[VAL_2967:.*]] = icmp ult i32 %[[VAL_2966]], 5120
// CHECK:         call void @llvm.assume(i1 %[[VAL_2967]])
// CHECK:         %[[VAL_2968:.*]] = mul nuw nsw i32 %[[VAL_2966]], 4
// CHECK:         %[[VAL_2969:.*]] = udiv i32 %[[VAL_2968]], 1
// CHECK:         %[[VAL_2970:.*]] = urem i32 %[[VAL_2969]], 200
// CHECK:         %[[VAL_2971:.*]] = udiv i32 %[[VAL_2968]], 200
// CHECK:         %[[VAL_2972:.*]] = add nuw nsw i32 %[[VAL_2968]], 1
// CHECK:         %[[VAL_2973:.*]] = udiv i32 %[[VAL_2972]], 1
// CHECK:         %[[VAL_2974:.*]] = urem i32 %[[VAL_2973]], 200
// CHECK:         %[[VAL_2975:.*]] = udiv i32 %[[VAL_2972]], 200
// CHECK:         %[[VAL_2976:.*]] = add nuw nsw i32 %[[VAL_2968]], 2
// CHECK:         %[[VAL_2977:.*]] = udiv i32 %[[VAL_2976]], 1
// CHECK:         %[[VAL_2978:.*]] = urem i32 %[[VAL_2977]], 200
// CHECK:         %[[VAL_2979:.*]] = udiv i32 %[[VAL_2976]], 200
// CHECK:         %[[VAL_2980:.*]] = add nuw nsw i32 %[[VAL_2968]], 3
// CHECK:         %[[VAL_2981:.*]] = udiv i32 %[[VAL_2980]], 1
// CHECK:         %[[VAL_2982:.*]] = urem i32 %[[VAL_2981]], 200
// CHECK:         %[[VAL_2983:.*]] = udiv i32 %[[VAL_2980]], 200
// CHECK:         %[[VAL_2984:.*]] = icmp ult i32 %[[VAL_2968]], 20000
// CHECK:         br i1 %[[VAL_2984]], label %[[VAL_2985:.*]], label %[[VAL_2986:.*]]
// CHECK:       r47.in_bounds-after:                              ; preds = %[[VAL_2985]], %[[VAL_2987:.*]]
// CHECK:         ret void
// CHECK:       r47.in_bounds-true:                               ; preds = %[[VAL_2987]]
// CHECK:         %[[VAL_2988:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2956]] to float*
// CHECK:         %[[VAL_2989:.*]] = getelementptr inbounds float, float* %[[VAL_2988]], i32 %[[VAL_2968]]
// CHECK:         %[[VAL_2990:.*]] = load float, float* %[[VAL_2989]], align 4, !invariant.load !94
// CHECK:         %[[VAL_2991:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2959]] to float*
// CHECK:         %[[VAL_2992:.*]] = getelementptr inbounds float, float* %[[VAL_2991]], i32 %[[VAL_2968]]
// CHECK:         %[[VAL_2993:.*]] = load float, float* %[[VAL_2992]], align 4, !invariant.load !94
// CHECK:         store float %[[VAL_2990]], float* %[[VAL_2952]], align 4
// CHECK:         store float %[[VAL_2993]], float* %[[VAL_2951]], align 4
// CHECK:         call void @region_1_3(float* %[[VAL_2952]], float* %[[VAL_2951]], float* %[[VAL_2953]])
// CHECK:         %[[VAL_2994:.*]] = load float, float* %[[VAL_2953]], align 4
// CHECK:         %[[VAL_2995:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2962]] to float*
// CHECK:         %[[VAL_2996:.*]] = getelementptr inbounds float, float* %[[VAL_2995]], i32 %[[VAL_2968]]
// CHECK:         store float %[[VAL_2994]], float* %[[VAL_2996]], align 4
// CHECK:         %[[VAL_2997:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2956]] to float*
// CHECK:         %[[VAL_2998:.*]] = getelementptr inbounds float, float* %[[VAL_2997]], i32 %[[VAL_2972]]
// CHECK:         %[[VAL_2999:.*]] = load float, float* %[[VAL_2998]], align 4, !invariant.load !94
// CHECK:         %[[VAL_3000:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2959]] to float*
// CHECK:         %[[VAL_3001:.*]] = getelementptr inbounds float, float* %[[VAL_3000]], i32 %[[VAL_2972]]
// CHECK:         %[[VAL_3002:.*]] = load float, float* %[[VAL_3001]], align 4, !invariant.load !94
// CHECK:         store float %[[VAL_2999]], float* %[[VAL_2949]], align 4
// CHECK:         store float %[[VAL_3002]], float* %[[VAL_2948]], align 4
// CHECK:         call void @region_1_3(float* %[[VAL_2949]], float* %[[VAL_2948]], float* %[[VAL_2950]])
// CHECK:         %[[VAL_3003:.*]] = load float, float* %[[VAL_2950]], align 4
// CHECK:         %[[VAL_3004:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2962]] to float*
// CHECK:         %[[VAL_3005:.*]] = getelementptr inbounds float, float* %[[VAL_3004]], i32 %[[VAL_2972]]
// CHECK:         store float %[[VAL_3003]], float* %[[VAL_3005]], align 4
// CHECK:         %[[VAL_3006:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2956]] to float*
// CHECK:         %[[VAL_3007:.*]] = getelementptr inbounds float, float* %[[VAL_3006]], i32 %[[VAL_2976]]
// CHECK:         %[[VAL_3008:.*]] = load float, float* %[[VAL_3007]], align 4, !invariant.load !94
// CHECK:         %[[VAL_3009:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2959]] to float*
// CHECK:         %[[VAL_3010:.*]] = getelementptr inbounds float, float* %[[VAL_3009]], i32 %[[VAL_2976]]
// CHECK:         %[[VAL_3011:.*]] = load float, float* %[[VAL_3010]], align 4, !invariant.load !94
// CHECK:         store float %[[VAL_3008]], float* %[[VAL_2946]], align 4
// CHECK:         store float %[[VAL_3011]], float* %[[VAL_2945]], align 4
// CHECK:         call void @region_1_3(float* %[[VAL_2946]], float* %[[VAL_2945]], float* %[[VAL_2947]])
// CHECK:         %[[VAL_3012:.*]] = load float, float* %[[VAL_2947]], align 4
// CHECK:         %[[VAL_3013:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2962]] to float*
// CHECK:         %[[VAL_3014:.*]] = getelementptr inbounds float, float* %[[VAL_3013]], i32 %[[VAL_2976]]
// CHECK:         store float %[[VAL_3012]], float* %[[VAL_3014]], align 4
// CHECK:         %[[VAL_3015:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2956]] to float*
// CHECK:         %[[VAL_3016:.*]] = getelementptr inbounds float, float* %[[VAL_3015]], i32 %[[VAL_2980]]
// CHECK:         %[[VAL_3017:.*]] = load float, float* %[[VAL_3016]], align 4, !invariant.load !94
// CHECK:         %[[VAL_3018:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2959]] to float*
// CHECK:         %[[VAL_3019:.*]] = getelementptr inbounds float, float* %[[VAL_3018]], i32 %[[VAL_2980]]
// CHECK:         %[[VAL_3020:.*]] = load float, float* %[[VAL_3019]], align 4, !invariant.load !94
// CHECK:         store float %[[VAL_3017]], float* %[[VAL_2943]], align 4
// CHECK:         store float %[[VAL_3020]], float* %[[VAL_2942]], align 4
// CHECK:         call void @region_1_3(float* %[[VAL_2943]], float* %[[VAL_2942]], float* %[[VAL_2944]])
// CHECK:         %[[VAL_3021:.*]] = load float, float* %[[VAL_2944]], align 4
// CHECK:         %[[VAL_3022:.*]] = bitcast [100 x [200 x float]]* %[[VAL_2962]] to float*
// CHECK:         %[[VAL_3023:.*]] = getelementptr inbounds float, float* %[[VAL_3022]], i32 %[[VAL_2980]]
// CHECK:         store float %[[VAL_3021]], float* %[[VAL_3023]], align 4
// CHECK:         br label %[[VAL_2986]]
// CHECK:       entry:
// CHECK:         %[[VAL_3024:.*]] = alloca float, align 4
// CHECK:         %[[VAL_3025:.*]] = load float, float* %[[VAL_3026:.*]], align 4
// CHECK:         %[[VAL_3027:.*]] = load float, float* %[[VAL_3028:.*]], align 4
// CHECK:         %[[VAL_3029:.*]] = fadd float %[[VAL_3025]], %[[VAL_3027]]
// CHECK:         store float %[[VAL_3029]], float* %[[VAL_3024]], align 4
// CHECK:         %[[VAL_3030:.*]] = load float, float* %[[VAL_3024]], align 4
// CHECK:         store float %[[VAL_3030]], float* %[[VAL_3031:.*]], align 4
// CHECK:         ret void
// RUN: hlo_to_llvm_ir %s | FileCheck %s



HloModule Test

add_F32 {
  lhs = f32[] parameter(0)
  rhs = f32[] parameter(1)
  ROOT add = f32[] add(lhs, rhs)
}

ENTRY main {
  a = f32[100, 200]{1,0} parameter(0)
  b = f32[100, 200]{1,0} parameter(1)
  c = f32[100, 200]{1,0} parameter(2)
  i0 = s32[100, 200]{1,0} parameter(3)
  i1 = s32[100, 200]{1,0} parameter(4)
  cplx = c64[100, 200]{1,0} parameter(5)
  p0 = pred[100, 200]{1,0} parameter(6)
  p1 = pred[100, 200]{1,0} parameter(7)

  r0 = f32[100, 200]{1,0} abs(a)
  r1 = f32[100, 200]{1,0} round-nearest-afz(a)
  r2 = f32[100, 200]{1,0} ceil(a)
  r3 = s32[100, 200]{1,0} count-leading-zeros(i0)
  r4 = f32[100, 200]{1,0} convert(a)
  r5 = f32[100, 200]{1,0} bitcast-convert(a)
  r6 = f32[100, 200]{1,0} copy(a)
  r7 = f32[100, 200]{1,0} cosine(a)
  r8 = f32[100, 200]{1,0} exponential(a)
  r9 = f32[100, 200]{1,0} exponential-minus-one(a)
  r10 = f32[100, 200]{1,0} floor(a)
  r11 = f32[100, 200]{1,0} imag(cplx)
  r12 = pred[100, 200]{1,0} is-finite(a)
  r13 = f32[100, 200]{1,0} log(a)
  r14 = f32[100, 200]{1,0} log-plus-one(a)
  r15 = pred[100, 200]{1,0} not(p0)
  r16 = f32[100, 200]{1,0} negate(a)
  r17 = s32[100, 200]{1,0} popcnt(i0)
  r18 = f32[100, 200]{1,0} real(cplx)
  r19 = f32[100, 200]{1,0} reduce-precision(a), exponent_bits=5, mantissa_bits=12
  r20 = f32[100, 200]{1,0} rsqrt(a)
  // r21 = f32[100, 200]{1,0} logistic(a)
  r22 = f32[100, 200]{1,0} sign(a)
  r23 = f32[100, 200]{1,0} sine(a)
  r24 = f32[100, 200]{1,0} sqrt(a)
  r25 = f32[100, 200]{1,0} cbrt(a)
  r26 = f32[100, 200]{1,0} tanh(a)

  r27 = f32[100, 200]{1,0} add(a, b)
  r28 = f32[100, 200]{1,0} atan2(a, b)
  r29 = pred[100, 200]{1,0} compare(a, b), direction=EQ
  r30 = c64[100, 200]{1,0} complex(a, b)
  r31 = f32[100, 200]{1,0} divide(a, b)
  r32 = f32[100, 200]{1,0} maximum(a, b)
  r33 = f32[100, 200]{1,0} minimum(a, b)
  r34 = f32[100, 200]{1,0} multiply(a, b)
  r35 = f32[100, 200]{1,0} power(a, b)
  r36 = f32[100, 200]{1,0} remainder(a, b)
  r37 = f32[100, 200]{1,0} subtract(a, b)
  r38 = pred[100, 200]{1,0} and(p0, p1)
  r39 = pred[100, 200]{1,0} or(p0, p1)
  r40 = pred[100, 200]{1,0} xor(p0, p1)
  r41 = pred[100, 200]{1,0} add(p0, p1)
  r42 = s32[100, 200]{1,0} shift-left(i0, i1)
  r43 = s32[100, 200]{1,0} shift-right-arithmetic(i0, i1)
  r44 = s32[100, 200]{1,0} shift-right-logical(i0, i1)

  r45 = f32[100, 200]{1,0} select(p0, b, c)
  r46 = f32[100, 200]{1,0} clamp(a, b, c)

  ROOT r47 = f32[100, 200]{1,0} map(a, b), dimensions={0, 1}, to_apply=add_F32
}
